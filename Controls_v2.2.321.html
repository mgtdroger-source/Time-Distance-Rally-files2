<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width,initial-scale=1" name="viewport"/>
<title>Controls v2.2.321</title>
<script>window.refreshWorkspaceUi_ = window.refreshWorkspaceUi_ || function(){};</script>
<style>
  

:root{
  --nameColW: 200px; /* Driver/Navigator name col width */
  --console-w: 610px; /* console card width */
  --totalColW: 84px; /* Total Score col width */
    --bg:#f9fafb;
    --panel:#f5f5f7;
    --panel-soft:#e6e9f2;
    --border:#d3d7df; --border-w:1px;  --header-bottom-w:2px;
    
    --text:#111827;
    --accent:#2563eb;
    --accent-weak:#e0e7ff;
    --green:#16a34a;
    --gap-panels: 20px;
    --top-gap: 12px; 
    --sticky-top: 76px; 
    --sg1:#ffffff;
    --sg2:#FFF8CC;
    --sg3:#EAF2FF;
    --sg4:#EAF9EE;
    --header-gap-bottom: 0px; 
    --border-strong:#c5cad3;
    --header-bg:#eef0f5;  
    --row-alt:#fbfcfe;    

    --edge:var(--border);
    --blue:var(--accent);
    --red:#dc2626;
    --muted:#6b7280;
    --rowHi:rgba(37,99,235,0.12);
    --blue-d:#1d4ed8;
    --chip-border:#dbe3f0;
    --topStack:118px;

    }
  body { font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; margin: 0 24px 24px; color:#111827; }
  h1 { font-size:18px; margin:0 0 12px 0; }
  .controls { display:flex; gap:8px; margin-bottom:14px; flex-wrap: wrap; align-items:center; }
  button { padding:8px 12px; border:1px solid var(--edge); background:white; border-radius:8px; cursor:pointer; }
  button:hover { background:#f9fafb; }
  .audit-controls { margin-left:16px; display:flex; align-items:center; gap:8px; }
  .audit-number { width:70px; padding:6px 8px; border:1px solid var(--edge); border-radius:8px; }
  .sheet { display:grid; grid-template-columns: 1fr; gap:24px; align-items:start; }
  
  
  
  .totals .row:not(:first-child) { height:36px; border-top:0; }
  
  .grid { display:flex; gap:16px; overflow-x:auto; }
  
  .card { border:1px solid var(--edge); border-radius:12px; width: 288px; flex:0 0 auto; 
  overflow: hidden;
}
  .card{ background:#ffffff; }
.card-body{ background: transparent; }
  
  .card-head { 
    display:grid; 
    grid-template-columns: 108px 108px 72px; 
    grid-template-rows: 28px 24px;
    align-items:center; 
    height:52px;
    border-bottom:1px solid var(--edge); 
    padding:0; 
    background:#f2f2f2;
  }
  .card-head .title { grid-column: 1 / span 3; grid-row:1; display:flex; align-items:center; gap:6px; font-weight:700; justify-content:center; }
  .card-head .col { grid-row:2; text-align:center; color:var(--muted); font-weight:600; }
  .card-body { display:grid; grid-template-columns: 108px 108px 72px; row-gap:0; padding:0; position:relative; }
  
  .cell { 
    height:36px; 
    display:flex; align-items:center; justify-content:center;
    font-size:14px; line-height:1.35; 
    background: transparent;
  }
  input.time, input.num { width:80px; margin:4px auto; text-align:center; border:1px solid var(--edge); border-radius:6px; padding:0; outline:none; box-sizing:border-box; height:28px; background:#fff; }
  input[readonly] { background:#f9fafb; }
  .time.error { border-color: var(--red) !important; box-shadow: 0 0 0 1px var(--red) inset; }
  
  .scoreText { text-align:center; font-weight:600; color:var(--blue); }
  .scoreText.excluded { color:var(--red); }
  .etaText { text-align:left; color: var(--blue); }

  
  

  
  .card-body {
    background-image:
      linear-gradient(to bottom, var(--edge), var(--edge)), 
      linear-gradient(to bottom, var(--edge), var(--edge)), 
      repeating-linear-gradient(to bottom, var(--edge) 0, var(--edge) 1px, transparent 1px, transparent 36px), 
      repeating-linear-gradient(to bottom, transparent 0, transparent 36px, rgba(0,0,0,0.03) 36px, rgba(0,0,0,0.03) 72px); 
    background-size: 1px 100%, 1px 100%, 100% 36px, 100% 72px;
    background-position: 108px 0, 216px 0, 0 36px, 0 0;
    background-repeat: no-repeat, no-repeat, repeat-y, repeat-y;
  }

  
  
  .stcm-card .card-body{
    
    background-image:
      repeating-linear-gradient(to bottom, var(--edge) 0, var(--edge) 1px, transparent 1px, transparent 36px), 
      repeating-linear-gradient(to bottom, transparent 0, transparent 36px, rgba(0,0,0,0.03) 36px, rgba(0,0,0,0.03) 72px); 
    background-size: 100% 36px, 100% 72px;
    background-position: 0 36px, 0 0;
    background-repeat: repeat-y, repeat-y;
  }
  .stcm-card .cell.kind-eta,
  .stcm-card .cell.kind-score{
    border-left: 1px solid var(--edge);
    box-sizing: border-box;
  }

  
  .stcm-card{
    width:248px;
    min-width:248px;
    max-width:248px;
    flex: 0 0 248px;
  }
  .stcm-card .card-head,
  .stcm-card .card-body{
    grid-template-columns: 96px 96px 56px;
  }

  
  


  /* v2.1.167 — Start STC: single-column card (layout-only) */
  .sstc-card{
    width: 160px;
    min-width: 160px;
    max-width: 160px;
    flex: 0 0 160px;
  }
  .sstc-card .card-head,
  .sstc-card .card-body{
    grid-template-columns: 1fr;
  }
  .sstc-card .card-body input.time{ text-align:center; }
  .sstc-card .card-head{
    grid-template-rows: 28px 24px;
  }
  .sstc-card .card-head .title{ grid-column: 1 / span 1; }
  .sstc-card .card-body{
    /* single column: only horizontal row lines + subtle banding */
    background-image:
      repeating-linear-gradient(to bottom, var(--edge) 0, var(--edge) 1px, transparent 1px, transparent 36px), 
      repeating-linear-gradient(to bottom, transparent 0, transparent 36px, rgba(0,0,0,0.03) 36px, rgba(0,0,0,0.03) 72px); 
    background-size: 100% 36px, 100% 72px;
    background-position: 0 36px, 0 0;
    background-repeat: repeat-y, repeat-y;
  }
  .card-body[data-active-row="0"] .cell[data-row="0"] { background: var(--rowHi); }
  .card-body[data-active-row="1"] .cell[data-row="1"] { background: var(--rowHi); }
  .card-body[data-active-row="2"] .cell[data-row="2"] { background: var(--rowHi); }
  .card-body[data-active-row="3"] .cell[data-row="3"] { background: var(--rowHi); }
  .card-body[data-active-row="4"] .cell[data-row="4"] { background: var(--rowHi); }

  .scoreText.audit-fail { background-color: transparent !important; }

  
  .card-body .cell.kind-score.audit-fail { background-color: rgba(255,0,0,0.25) !important; }

.card.console-card { width: var(--console-w, 610px); }
/* v2.1.262 — Start Times strip (day-aware) */
.starts-toggle{
  margin-left:10px;
  height:34px;
  padding:0 10px;
  border-radius:16px;
  border:1px solid var(--edge);
  background:#fff;
  color:#111827;
  font-weight:700;
  font-size:13px;
  cursor:pointer;
  user-select:none;
}
.starts-toggle[aria-pressed="true"]{
  background:rgba(37,99,235,0.10);
  border-color:rgba(37,99,235,0.35);
}
.startstrip-card{
  width: 92px; /* just enough for header + HH:MM:SS */
  position: sticky;
  top: 0;
  left: calc(var(--console-w, 610px) + 8px);
  z-index: 800;
  border-left:1px solid var(--border);
}
.startstrip-card .card-head{
  grid-template-columns: 1fr;
  z-index: 820 !important; /* above scrolling cards (e.g., COC) */
}
.startstrip-card .card-head .title{
  grid-column: 1 / span 1;
  grid-row: 1;
  justify-content: center;
  text-align: center;
}
.startstrip-card .card-head .col{
  grid-column: 1 / span 1;
  grid-row: 2;
  justify-content: center;
  text-align: center;
}

.startstrip-card .card-body{
  grid-template-columns: 1fr;
}
.startstrip-card .startstrip-h1{
  font-size:13px; font-weight:800; line-height:1.05;
}
.startstrip-card .startstrip-h2{
  font-size:13px; font-weight:800; line-height:1.05; margin-top:2px;
}
.startstrip-card .startstrip-time{
  height:36px;
  display:flex; align-items:center; justify-content:center;
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  font-size:13px;
  color: var(--accent);
  white-space:nowrap;
}

.console-card .card-head { grid-template-columns: 200px 200px 56px var(--rallyColW, 70px) var(--totalColW, 84px); }
.console-card .card-body { grid-template-columns: var(--nameColW, 200px) var(--nameColW, 200px) 56px var(--rallyColW, 70px) var(--totalColW, 84px); }

/* v2.2.315 — Compact: shrink Total Score col + tidy header */
body.is-compact .console-card .card-head{
  grid-template-columns: var(--nameColW, 200px) var(--nameColW, 200px) 56px var(--rallyColW, 70px) var(--totalColW, 64px);
}
body.is-compact .console-card .card-body{
  grid-template-columns: var(--nameColW, 200px) var(--nameColW, 200px) 56px var(--rallyColW, 70px) var(--totalColW, 64px);
}
body.is-compact .console-card .card-head .col:last-child{
  font-size:12px;
  line-height:1.05;
  padding-left:2px;
  padding-right:2px;
}
body.is-compact .console-card .card-head .col:last-child span{
  font-size:11px;
  font-weight:600;
}

.console-card .card-body {
  background-image:
    linear-gradient(to bottom, var(--edge), var(--edge)), 
    linear-gradient(to bottom, var(--edge), var(--edge)), 
    linear-gradient(to bottom, var(--edge), var(--edge)), 
    linear-gradient(to bottom, var(--edge), var(--edge)), 
    repeating-linear-gradient(to bottom, var(--edge) 0, var(--edge) 1px, transparent 1px, transparent 36px), 
    repeating-linear-gradient(to bottom, transparent 0, transparent 36px, rgba(0,0,0,0.03) 36px, rgba(0,0,0,0.03) 72px); 
  background-size: 1px 100%, 1px 100%, 1px 100%, 1px 100%, 100% 36px, 100% 72px;
  background-position: var(--nameColW, 200px) 0, calc(var(--nameColW, 200px) * 2) 0, calc((var(--nameColW, 200px) * 2) + 56px) 0, calc((var(--nameColW, 200px) * 2) + 56px + var(--rallyColW, 70px)) 0, 0 36px, 0 0;
  background-repeat: no-repeat, no-repeat, no-repeat, no-repeat, repeat-y, repeat-y;
}

.console-card .console-driver{
  color: var(--blue);
  font-weight: 600;
  user-select: none;
}

.console-card .card-body .cell:nth-child(5n+1),
.console-card .card-body .cell:nth-child(5n+2) {
  justify-content: flex-start;
}
.console-card .card-body .cell:nth-child(5n+1) > *,
.console-card .card-body .cell:nth-child(5n+2) > * {
  margin-left: 0.6em;
  text-align: left;
}

/* Compact/Normal: allow name text to clip inside its column */
.console-card .card-body .cell:nth-child(5n+1),
.console-card .card-body .cell:nth-child(5n+2){
  min-width: 0;
}
.console-card .card-body .cell:nth-child(5n+1) > *,
.console-card .card-body .cell:nth-child(5n+2) > *{
  min-width: 0;
  max-width: 100%;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: clip;
}

.console-card .card-body .cell:nth-child(5n+5) {
  justify-content: flex-end;
}
.console-card .card-body .cell:nth-child(5n+5) .console-score {
  margin-right: 1.4em; 
  text-align: right;
  color: var(--blue);
  font-weight: 600; 
  min-width: 3ch; 
}

.console-card .card-body .cell:nth-child(5n+4) .rally-no {
  color: var(--blue);
  font-weight: 700;
}

.console-card {
  position: sticky;
  left: 0;
  z-index: 5;             
  background-color: white;      
  box-shadow: 8px 0 12px rgba(0,0,0,0.08); 
}

.coc-card { width: 248px; min-width: 248px; max-width: 248px; flex: 0 0 248px; }
.coc-card .card-head {
  grid-template-columns: 188px 60px;
  grid-template-rows: 28px 24px;
}
.coc-card .card-head .title{
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.coc-card .card-body {
  grid-template-columns: 188px 60px;
  
  background-image:
    repeating-linear-gradient(to bottom, var(--edge) 0, var(--edge) 1px, transparent 1px, transparent 36px), 
    repeating-linear-gradient(to bottom, transparent 0, transparent 36px, rgba(0,0,0,0.03) 36px, rgba(0,0,0,0.03) 72px); 
  background-size: 100% 36px, 100% 72px;
  background-position: 0 36px, 0 0;
  background-repeat: repeat-y, repeat-y;
}
.coc-card .card-body .cell:nth-child(2n) {
  border-left: 1px solid var(--edge);
  box-sizing: border-box;
}

.coc-text, .coc-num {
  height: 28px;
  border:1px solid var(--edge);
  border-radius:6px;
  background:#fff;
  outline:none;
  box-sizing:border-box;
  font-size:14px; line-height:1.35;
}
.coc-text {
  width: 92%;
  padding: 0 8px;
  text-align: left;
  color:#111827;
}
.coc-num {
  width: 52px;
  margin: 0 auto;
  text-align: center;
  color:#111827;
}
.coc-text::placeholder, .coc-num::placeholder { color:#9ca3af; }

.coc-card.excluded .coc-text, .coc-card.excluded .coc-num { color: var(--red); }

.coc-card .card-head .col { text-align: center; }
.coc-card .card-head .title { display:flex; align-items:center; justify-content:flex-start; gap:8px; padding:0 72px 0 14px; } 

.coc-card .coc-toggle {
  width: 16px;
  height: 16px;
  accent-color: var(--blue);
}

.console-card .card-head .col.top {
  color: #111827;
  font-weight: 700;
}

.controls-menu {
  position:absolute; top:100%; left:0; margin-top:6px; min-width:220px;
  border:1px solid var(--edge); border-radius:10px; background:white;
  box-shadow: 0 10px 18px rgba(0,0,0,0.12);
  padding:6px; display:flex; flex-direction:column; gap:4px;
  z-index: 1000;
}
.controls-menu .menu-item { text-align:left; border:none; background:transparent; padding:8px 10px; border-radius:8px; cursor:pointer; }
.controls-menu .menu-item:hover, .controls-menu .menu-item:focus { background:#ffffff; outline:none; }
.controls-menu hr { border:none; border-top:1px solid var(--edge); margin:4px 0; }

.controls-menu[hidden]{ display:none !important; }

.button-container{
  height:auto !important;
  flex-wrap:wrap;
  justify-content:flex-start !important;
  row-gap:8px;
}
.btn-softgap{
  flex:1 1 24px;
  min-width:8px;
  max-width:64px;
}
.day-cluster{
  flex:1 1 220px;
  min-width:180px;
  display:flex;
  align-items:center;
  justify-content:center;
}

  /* v2.2.284 — View toggle (Normal/Compact) */
  .btn.btn-view{
    background:#ffffff;
    color:#111827;
    border:1px solid #cbd5e1;
    padding:8px 12px;
    min-width:0;
    box-shadow:none;
    height:40px;
    border-radius:12px;
    font-weight:600;
  }
  .btn.btn-view[aria-pressed="true"]{
    background:#e5e7eb;
    border-color:#d1d5db;
  }
  .btn.btn-view:hover{ border-color:#94a3b8; }

  /* v2.2.284 — Compact via global zoom (single knob) */
  :root{ --compact-zoom: 0.92; }
  body.is-compact{
    zoom: var(--compact-zoom);
  
  --nameColW: 146px; /* compact: narrower names */
  --totalColW: 72px;
  --console-w: calc(var(--nameColW, 150px) + var(--nameColW, 150px) + 56px + var(--rallyColW, 70px) + var(--totalColW, 56px)); /* compact: narrower console card */
}
  body.is-compact .grid-scroll{
    height: calc((100vh - var(--topStack)) / var(--compact-zoom));
  }


.mid-gap{
  flex:1 1 320px;
  min-width:220px;
  display:flex;
  align-items:center;
  justify-content:center;
}
.right-cluster{
  margin-left:auto;
  display:flex;
  align-items:center;
  flex-wrap:wrap;
  justify-content:flex-end;
  gap:8px;
  max-width:520px;
}
@media (max-width: 900px){
  .btn-softgap{ flex-basis:12px; max-width:24px; }
  .day-cluster{ flex-basis:180px; min-width:160px; justify-content:flex-start; }
  .mid-gap{ flex-basis:240px; min-width:200px; }
}

.controls-menu { padding-top: 34px; }
.controls-menu .menu-close {
  position: absolute; top: 6px; right: 6px;
  width: 24px; height: 24px;
  border: none; border-radius: 6px;
  background: transparent;
  font-size: 16px; line-height: 1; cursor: pointer;
}
.controls-menu .menu-close:hover { background: #ffffff; }

  
  .tools-shelf { margin-top: 24px; padding-top: 8px; }

  
  .page-top-gap { height: 0px; }

  
  .top-gutter { height: 12px; background: #ffffff; }

  
  .button-container { height: 48px; padding: 12px 0; display: flex; align-items: center; gap: 8px; background: #f2f2f2; }
  
  .button-container {
    background: #f2f2f2;              
    border: 1px solid #cbd5e1;        
    border-radius: 12px;              
    box-shadow: 0 1px 2px rgba(0,0,0,.06), inset 0 1px 0 rgba(255,255,255,.9); 
    padding-left: 12px; padding-right: 12px; 
    justify-content: space-between;   
  }
  .button-container { box-shadow: 0 1px 2px rgba(0,0,0,.06), inset 0 1px 0 rgba(255,255,255,.9); }

  
  .gap-8-top, .gap-8-bottom { height: 8px; }
  .hproxy { height: 18px; background:#ffffff; border-top: 1px solid #ffffff; border-bottom: 1px solid #ffffff; overflow-x: auto; overflow-y: hidden; }

  
  html, body { background: #ffffff; }

  
  .hproxy-inner { height: 1px; width: 4000px; background: linear-gradient(90deg, #ffffff, #f8fafc); }
  .button-container { display:flex; align-items:center; gap:12px; }
  .left-cluster, .right-cluster { display:flex; gap:10px; align-items:center; }
  .center-chip {
    margin: 0 auto;
    display:flex; align-items:center; justify-content:center;
    height:44px; padding:0 18px; min-width:140px;
    border:1px solid var(--chip-border);
    background: linear-gradient(#f8fafc, #eef2f7);
    border-radius:999px; font-weight:800; letter-spacing:.5px;
  }
  .btn {
    height:38px; padding:0 16px;
    border-radius:12px; border:1px solid #cbd5e1;
    background: var(--blue); color:#fff; font-weight:700;
    cursor:pointer; transition: transform .05s ease, box-shadow .15s ease;
  }
  .btn:hover { transform: translateY(-1px); box-shadow: 0 6px 12px rgba(2,6,23,.08); }
  .btn.secondary { background: var(--blue-d); }
  .btn.success   { background: var(--green); border-color:#86efac; }

  
  .center-wrap { margin: 0 auto; display:flex; align-items:center; gap:12px; }
  .btn.warning { background:#f59e0b; border-color:#fbbf24; color:#fff; }
  .audit-inline { display:flex; align-items:center; gap:10px; }
  .audit-inline .audit-number { width: 72px; }

  
  .center-wrap { margin: 0 auto; display:flex; align-items:center; gap:12px; }
  .controls { display:inline-flex; align-items:center; gap:10px; margin:0; flex-wrap:nowrap; }
  .controls-dropdown { position: relative; display:inline-block; }
  .audit-inline { display:inline-flex; align-items:center; gap:10px; }
  .audit-inline label { display:inline-flex; align-items:center; gap:6px; margin:0; }
  .audit-inline .audit-number { height:38px; padding:0 10px; border:1px solid #cbd5e1; border-radius:10px; }

  
  .center-wrap { white-space: nowrap; }
  .center-wrap .center-chip { margin: 0; }
  .controls, .center-wrap .audit-inline { flex: 0 0 auto; }
  .controls-menu[hidden] { display: none !important; }

  
  .center-wrap {
    display: grid !important;
    grid-auto-flow: column;
    align-items: center;
    justify-content: center;
    column-gap: 12px;
    row-gap: 0;
  }
  .controls { display:inline-flex; align-items:center; gap:10px; margin:0; }
  .center-wrap .audit-inline { display:inline-flex; align-items:center; gap:10px; }
  .center-wrap .audit-number { height:38px; }

  
  .button-container .btn.warning {
    background:#f59e0b !important;
    border-color:#fbbf24 !important;
    color:#111827 !important; 
  }

  
  .audit-box {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    height: 44px;
    padding: 0 10px;
    border: 1px solid #fecaca;     
    background: #fee2e2;           
    border-radius: 12px;
    margin-left: 16px;              
  }
  .audit-box label { display:inline-flex; align-items:center; gap:6px; margin:0; }
  .audit-box .audit-number {
    height: 32px;
    padding: 0 10px;
    border: 1px solid #cbd5e1;
    border-radius: 10px;
  }

  
  .audit-box .audit-number { text-align: center; }
  
  .audit-box .audit-number { width: 44px; padding: 0 4px; }

  
  .row-buttons { display:inline-flex; gap:8px; margin-right:12px; align-items:center; }
  .small-btn {
    height:30px; padding:0 10px; font-size:12px;
    border-radius:10px; border:1px solid #cbd5e1;
    background:#ffffff; color:#111827; cursor:pointer;
    transition:transform .05s ease, box-shadow .15s ease;
  }
  .small-btn:hover { box-shadow: 0 4px 8px rgba(2,6,23,.06); transform: translateY(-1px); }
  .small-btn:active { transform: translateY(0); }

  
  :root { --topStack: 118px; }  
  html, body { height: 100%; }
  body { overflow-y: hidden; }  
  .grid-scroll { height: calc(100vh - var(--topStack)); }
  #panel.grid { overflow: visible !important; }  
  .card { overflow: visible !important; }       
  .card-head { position: sticky; top: 0; z-index: 60; background:#f2f2f2; box-shadow: 0 1px 0 rgba(2,6,23,.06); }
  
  .coc-card .card-head { position: sticky !important; top: 0; }

  
  .grid-scroll { overflow-x: scroll; overflow-y: auto; }                 
  #panel.grid { overflow: visible !important; }    
  .grid { width: max-content; min-width: 100%; }   

  
  .grid .card .card-head { z-index: 40 !important; }
  .grid .card.console-card .card-head { z-index: 200 !important; }

  
  #panel.grid .card .card-head { z-index: 40 !important; position: sticky !important; top: 0 !important; }
  #panel.grid .card:first-child .card-head { z-index: 300 !important; box-shadow: 6px 0 8px -6px rgba(2,6,23,.15); }

  
  #panel.grid .card .card-head { z-index: 40 !important; position: sticky !important; top: 0 !important; }
  #panel.grid .card.left-col .card-head { z-index: 300 !important; box-shadow: 6px 0 8px -6px rgba(2,6,23,.15); }

  
  .grid-scroll { position: relative; } 
  #panel.grid { position: relative; }
  #panel.grid .card.left-col {
    position: sticky;
    left: 0;
    z-index: 500 !important;           
    background: #fff;               
    box-shadow: 6px 0 12px -8px rgba(2,6,23,.20); 
  }
  
  #panel.grid .card.left-col .card-head { z-index: 510 !important; }

  
  .hproxy {
    position: relative;
    height: 18px;
    background: #e5e7eb;             
    border-top: 1px solid #ffffff;
    border-bottom: 1px solid #ffffff;
    overflow-x: auto;                 
    overflow-y: hidden;
    border-radius: 6px;
  }
  .hproxy-thumb {
    position: absolute;
    top: 4px;
    left: 0;
    height: 10px;
    border-radius: 6px;
    background: #6b7280;             
    box-shadow: 0 1px 2px rgba(0,0,0,0.15) inset;
    pointer-events: auto;             
  }
  .hproxy.dragging, .hproxy-thumb.dragging {
    cursor: grabbing;
  }

  
  .rally-drawer {
    position: absolute;
    top: 6px; 
    left: 438px; 
    width: 384px; 
    max-height: calc(100vh - 32px); 
    background: #fff;
    border: 1px solid #cbd5e1;
    border-radius: 12px;
    box-shadow: 0 14px 32px rgba(2,6,23,0.18), 0 2px 6px rgba(2,6,23,0.12);
    z-index: 700;
    display: none;
    box-sizing: border-box;
    flex-direction: column; 
  }
  .rally-drawer[aria-hidden="false"] { display: flex; }
  .rally-drawer .rd-head {
    display: grid;
    grid-template-rows: 26px 20px; 
    grid-template-columns: 1fr auto;
    align-items: center;
    padding: 8px 10px 6px;
    border-bottom: none;
    background: #ffffff;
    border-top-left-radius: 12px;
    border-top-right-radius: 12px;
  }
  .rally-drawer .rd-title {
    grid-row: 1;
    grid-column: 1 / span 1;
    font-size: 13px;
    font-weight: 700;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  .rally-drawer .rd-close {
    grid-row: 1;
    grid-column: 2 / span 1;
    border: 1px solid #cbd5e1;
    background: #fff;
    border-radius: 8px;
    padding: 4px 8px;
    font-size: 12px;
    font-weight: 600;
    color: #475569;
    cursor: pointer;
  }
  .rally-drawer .rd-head2 {
    grid-row: 2;
    grid-column: 1 / span 2;
    display: grid;
    grid-template-columns: 96px 100px 100px 72px; 
    font-size: 12px;
    font-weight: 600;
    color: #6b7280;
  }
  .rally-drawer .rd-head2 > div { text-align: center; }
  .rally-drawer .rd-body { 
    overflow-x: hidden;
    overflow-y: auto; 
    padding: 0 8px 10px; 
    margin-top: 0;
    flex: 1 1 auto; 
  }
  .rally-drawer .rd-row {
    display: grid;
    grid-template-columns: 96px 100px 100px 72px;
    align-items: center;
    height: 36px; 
    border-bottom: none;
    font-size: 13px;
  }
  .rally-drawer .rd-row:nth-child(even) {
    background: rgba(15,23,42,0.02); 
  }

  .rally-drawer .rd-row .rd-col { text-align: center; }
  .rally-drawer .rd-row .rd-col:first-child { text-align: center; padding-left: 0; }
  .rally-drawer .rd-row .rd-col:last-child { text-align: right; padding-right: 6px;   }

  
  
  .rally-drawer .rd-body {
    
    background-image:
      linear-gradient(to right, rgba(0,0,0,0.08), rgba(0,0,0,0.08)),
      linear-gradient(to right, rgba(0,0,0,0.08), rgba(0,0,0,0.08)),
      linear-gradient(to right, rgba(0,0,0,0.08), rgba(0,0,0,0.08));
    background-repeat: no-repeat, no-repeat, no-repeat;
    background-size: 1px 100%, 1px 100%, 1px 100%;
    background-position: 96px 0, 196px 0, 296px 0;
  }

  
  .console-card .card-body .cell.active { background: #fde68a; }

  
  .console-card .card-body .cell:has(.rally-no) {
    cursor: pointer;
  }

  
  .rally-drawer .rd-title { font-size: 15px; }                     
  .rally-drawer .rd-head2 { color: #111827; }                      
  .rally-drawer .rd-row { font-size: 14px; line-height: 1.35; }    
  .rally-drawer .rd-row .rd-col:first-child {                      
    color: #111827;
    font-weight: 600;
  }
  .rally-drawer .rd-row .rd-col:nth-child(3),                      
  .rally-drawer .rd-row .rd-col:nth-child(4) {                     
    color: var(--blue, #2563eb);
  }

  
  .rally-drawer .rd-body { scrollbar-gutter: stable; }              
  .rally-drawer .rd-row .rd-col:last-child { padding-right: 0px;   } 
  .rally-drawer .rd-head2 > div:last-child { text-align: right; padding-right: 0px;   }

  
  .rally-drawer .rd-time {
    width: 92px;
    height: 28px;
    border: 1px solid #e5e7eb;
    border-radius: 8px;
    background: #f9fafb;
    line-height: 28px;
    text-align: center;
    font-size: 14px;
    outline: none;
    box-shadow: inset 0 1px 0 rgba(255,255,255,0.8);
  }
  .rally-drawer .rd-time:focus {
    border-color: #bfdbfe;
    box-shadow: 0 0 0 2px rgba(191,219,254,0.6);
    background: #ffffff;
  }

  
  .rally-drawer .rd-row .rd-col:nth-child(2) {
    display: flex;
    justify-content: center;
    align-items: center;
  }
  .rally-drawer .rd-time {
    width: 84px;         
    margin: 0;           
  }

  
  .rally-drawer .rd-row .rd-col:nth-child(2) {
    padding: 0;                 
    display: flex;
    justify-content: center;
    align-items: center;
  }
  .rally-drawer .rd-time {
    box-sizing: border-box;     
    width: 80px;                
    margin: 0;
    font-variant-numeric: tabular-nums; 
  }
  
  .card-body input,
  .card-body input[readonly],
  .rally-drawer .rd-body input,
  .rally-drawer .rd-body input[readonly] {
    background-color: transparent;
  }

  
  .rally-drawer .rd-body { background-origin: content-box; }

  
  .rally-drawer .rd-time.error { border-color: var(--red) !important; box-shadow: 0 0 0 1px var(--red) inset; }

  
  .rally-drawer .rd-row .rd-col:last-child,
  .rally-drawer .rd-head2 > div:last-child {
    padding-right: 24px !important;
    padding-left: 0 !important;
    text-align: right;
  }

  
  #btnSavePage,
  #btnSavePage:hover,
  #btnSavePage:focus,
  #btnSavePage:active {
    background-color: var(--blue, #2563eb) !important;
    color: #ffffff !important;
    border-color: var(--blue, #2563eb) !important;
    transform: none !important;
    outline: none !important;
  }
  #btnSavePage:focus-visible {
    box-shadow: 0 0 0 2px rgba(191,219,254,0.9) !important; 
  }

  
  

  /* Workspace gating */
  button.btn:disabled{opacity:.45 !important; cursor:not-allowed !important;}
#btnLoadPage,
  #btnLoadPage:hover,
  #btnLoadPage:focus,
  #btnLoadPage:active {
    background-color: var(--blue, #2563eb) !important;
    color: #ffffff !important;
    border-color: var(--blue, #2563eb) !important;
    transform: none !important;
    outline: none !important;
  }
  #btnLoadPage:focus-visible {
    box-shadow: 0 0 0 2px rgba(191,219,254,0.9) !important;
  }
  #btnSavePage {
    -webkit-tap-highlight-color: transparent;
    user-select: none;
  }

  
  #btnSavePage, #btnLoadPage { display: inline-flex; flex-direction: column; align-items: center; justify-content: center; }
  #btnSavePage .btnline1, #btnLoadPage .btnline1 { font-weight: 800; font-size: 12px; line-height: 1.0; letter-spacing: 0.02em; }
  #btnSavePage .btnline2, #btnLoadPage .btnline2 { font-size: 11px; line-height: 1.0; opacity: 0.85; margin-top: 2px; }

  
  .status-pill{
    display:inline-flex;
    align-items:center;
    height:28px;
    padding:0 12px;
    border-radius:999px;
    border:1px solid #fbbf24;
    background:#fffbeb;
    color:#92400e;
    font-weight:700;
    font-size:12px;
    line-height:28px;
    white-space:nowrap;
  }

  /* v2.2.288 — allow Plan status to be two-line to save width */
  #controlsDataStatus.twoline{
    white-space:normal;
    height:auto;
    line-height:14px;
    padding:6px 12px;
    flex-direction:column;
    justify-content:center;
    text-align:center;
  }

  
  
  .status-pill.ok{
    border-color:#86efac;
    background:#ecfdf5;
    color:#065f46;
  }
  .status-pill.warn{
    border-color:#fbbf24;
    background:#fffbeb;
    color:#92400e;
  }
  .status-pill.bad{
    border-color:#fca5a5;
    background:#fef2f2;
    color:#991b1b;
  }
  .status-pill.pulse{
    animation: planSyncPulse 2.05s infinite ease-in-out;
  }

  .controls .ctl-btn{
    height:28px;
    padding: 0 8px;
    font-size: 10px;
    border-radius:9px;
    background:#f59e0b;
    border:1px solid #fbbf24;
    color:#111827;
    font-weight:800;
  }

  
  .controls-dropdown{ position: relative; display: inline-flex; align-items:center; }
  .controls{ display:inline-flex; align-items:center; gap:8px; }
  .controls-menu{ z-index: 50; }

  
  .button-container{
    display:flex;
    align-items:center;
    flex-wrap:nowrap;
    gap:14px;
  }
  .left-buttons{ flex:0 0 auto; }
  .center-wrap{
    flex:1 1 auto;
    display:flex;
    align-items:center;
    gap:14px;
    justify-content:center;
    min-width:0;
    flex-wrap:nowrap;
  }
  .right-cluster{
    flex:0 0 auto;
    display:flex;
    align-items:center;
    gap:8px;
    margin-left:auto;
    min-width:0;
    flex-wrap:nowrap;
  }
  .center-chip{
    display:inline-flex;
    align-items:center;
    justify-content:center;
    width:auto !important;
    max-width:100%;
    flex:0 0 auto;
    height:34px;
    padding:0 18px;
    border-radius:12px;           
    background:#f3f4f6;
    border:1px solid #d1d5db;
    font-weight:800;
    letter-spacing:0.2px;
    white-space:nowrap;
  }

  
  .right-cluster .controls-dropdown{ margin-left: 14px; } 
  .right-cluster #btnControlsData{ margin-left: 14px; }   

  
  .right-cluster #controlsDataStatus{ margin-left: 14px; }

  
  .center-chip.daydd{
    background: transparent !important;
    border: none !important;
    padding: 0 !important;
    height: auto !important;
  }
  #dayPillWrap{ position: relative; display:inline-flex; align-items:center; z-index: 10000; overflow: visible; }

  .daydd-btn{
    display:inline-flex;
    align-items:center;
    justify-content:space-between;
    gap:6px;
    width: 140px;
    height:40px;
    padding:0 10px;
    box-sizing:border-box;
    border-radius:12px;
    background:#ffffff;
    border:1px solid #d1d5db;
    color:#111827;
    font-weight:600;
    font-size:14px;
    line-height:40px;
    white-space:nowrap;
    cursor:pointer;
    overflow:hidden;
  }
  .daydd-select{
    width: 140px;
    height:40px;
    padding:0 10px;
    box-sizing:border-box;
    border-radius:12px;
    background:#ffffff;
    border:1px solid #d1d5db;
    color:#111827;
    font-weight:600;
    font-size:14px;
    line-height:40px;
    white-space:nowrap;
    cursor:pointer;
    overflow:hidden;
  }
  .daydd-select:focus{ outline: none; box-shadow: 0 0 0 3px rgba(59,130,246,0.25); }

  #dayPillLabel{
    flex:1 1 auto;
    min-width:0;
    overflow:hidden;
    text-overflow:ellipsis;
    white-space:nowrap;
  }
  .daydd-btn:focus{ outline: none; box-shadow: 0 0 0 3px rgba(59,130,246,.25); }
  .daydd-chev{ font-size:12px; opacity:.8; margin-top:1px; }

  .daydd-menu{
    position:absolute;
    top: calc(100% + 8px);
    left: 0;
    width: 140px;
min-width: 140px;
    max-width: 140px;
    background:#ffffff;
    border:1px solid #d1d5db;
    border-radius:12px;
    padding:8px;
    box-shadow: 0 8px 24px rgba(2,6,23,.08);
    z-index: 10001;
  }
  .daydd-item{
    width:100%;
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:10px;
    height:34px;
    padding:0 12px;
    border-radius:10px;
    border:1px solid transparent;
    background:transparent;
    font-size:14px;
    font-weight:700;
    color:#111827;
    cursor:pointer;
    text-align:left;
  }
  .daydd-item:hover{ background:#f3f4f6; }
  .daydd-item[aria-checked="true"]{ background:#eef2ff; border-color:#c7d2fe; }
  .daydd-sub{ font-weight:700; color:#6b7280; }

  
  .mid-gap{
    flex: 1 1 auto;
    min-width: 0;
    display: flex;
    align-items: center;
    justify-content: center; 
    pointer-events: none;    
  }
  .titlepack{
    display: inline-flex;
    align-items: center;
    gap: 10px;
    width: auto;
    max-width: 532px; 
    min-width: 0;
    pointer-events: auto;
  }
.mid-gap .daydd-btn{ justify-self: center; }

  .right-cluster{ margin-left: 0 !important; }

  .mid-pills{
    display: inline-flex;
    align-items: center;
    gap: 10px;
    min-width: 0;
    pointer-events: auto;
  }
  .mid-pill{
    height: 40px;
    display: inline-flex;
    align-items: center;
    border: 1px solid #d1d5db;
    background: #ffffff;
    border-radius: 12px;
    padding: 0 14px;
    font-size: 14px;
    line-height: 1.35;
    font-weight: 700; 
    color: #111827;
    box-shadow: 0 1px 0 rgba(0,0,0,0.03);
  }
    .title-pill{
    
    flex: 0 1 250px;
    width: 250px;
    max-width: 250px;
    min-width: 140px;
    overflow: hidden;
    white-space: nowrap;
    text-overflow: ellipsis;
  }
.issue-pill{
    flex: 0 0 62px;
    width: 62px;
    min-width: 62px;
    max-width: 62px;
    justify-content: center;
    padding: 0;
  }
  .issue-pill.is-placeholder{ color:#9ca3af; }

  
  @media (max-width: 1200px){
    .button-container{
      flex-wrap: wrap;
      height: auto;
      row-gap: 10px;
      align-items: center;
    }
    
    .mid-gap{
      order: 0;
      flex: 0 0 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
      pointer-events: auto;
    }
    
    .left-cluster{
      order: 1;
      flex: 1 1 auto;
    }
    .right-cluster{
      order: 1;
      flex: 1 1 auto;
      justify-content: flex-end;
    }
        
    .title-pill{
      flex: 0 1 250px;
      width: 250px;
      max-width: 250px;
      min-width: 120px;
      min-height: 40px;
      overflow: hidden;
      white-space: nowrap;
      text-overflow: ellipsis;
    }
}

#printOptionsWrap[aria-hidden="true"]{ display:none; }
#printOptionsWrap[aria-hidden="false"]{
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.35);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 9999;
}
#printOptions{
  background: #fff;
  border: 1px solid #e5e7eb;
  border-radius: 12px;
  padding: 18px;
  width: min(520px, 92vw);
  box-shadow: 0 10px 30px rgba(0,0,0,0.15);
  font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
  font-size: 14px;
  line-height: 1.35;
}
#printOptions h2{ font-size: 16px; margin: 0 0 12px; }
#printOptions .row{
  display: grid;
  grid-template-columns: 1fr 1.5fr;
  gap: 12px;
  margin: 8px 0;
  align-items: center;
}
#printOptions select{ font-size: 14px; line-height: 1.35; padding: 6px 8px; }
#printOptions .actions{ display:flex; gap:10px; justify-content:flex-end; margin-top:14px; }
#po-cancel, #po-print{
  font-size:14px; line-height:1.35; padding:8px 14px; border-radius:8px; border:1px solid transparent; cursor:pointer;
}
#po-cancel{ background:#f3f4f6; color:#111827; border-color:#e5e7eb; }
#po-cancel:hover{ background:#e5e7eb; }
#po-print{ background:#2563eb; color:white; }
#po-print:hover{ background:#1d4ed8; }

#printSnapshot{ display:none; }

@media print{
  
  #printSnapshot{ display:block !important; }

  
  .top-gutter,
  .button-container,
  .gap-8-top,
  .hproxy,
  .gap-8-bottom,
  .page-top-gap,
  .tools-shelf,
  #panel,
  .grid-scroll,
  #printOptionsWrap{
    display:none !important;
  }

  
  html, body{
    height:auto !important;
    overflow:visible !important;
    background:#fff !important;
    margin:0 !important;
  }

  /* v2.1.177 — Print table formatting (grid + spacing) */
  @page { size: A4 landscape; margin: 10mm; }

  .print-page{ page-break-after: always; }
  
.print-pagehdr{ font-size: 11pt; font-weight: 600; margin: 0 0 6mm 0; }
.print-page:last-child{ page-break-after: auto; }

  .print-table{
    border-collapse: collapse;
    table-layout: fixed;
    width: auto;
    font-size: 11pt;
    line-height: 1.15;
    font-variant-numeric: tabular-nums;
  }
  .print-table th, .print-table td{
    border: 1px solid #9ca3af;
    padding: 4px 6px;
    vertical-align: middle;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  .print-table thead th{
    background: #f3f4f6;
    font-weight: 600;
    color: #111827;
    border-bottom: 2px solid #6b7280;
  }
  .print-table th.th-left{ text-align: left; }
  .print-table td.nowrap{ text-align: left; }
  .print-table td.center, .print-table th.center{ text-align: center; }
  .print-table td.right{ text-align: right; }
  .print-table td.mono{ font-variant-numeric: tabular-nums; }

  .print-table .hdr2{ font-size: 10pt; font-weight: 700; opacity: .85; margin-top: 0; }

  .print-table .td-tot{ text-align:center !important; }
  .print-table .td-pos{ font-weight: 400; }

  .print-table tbody tr:nth-child(even) td{ background: rgba(15,23,42,0.02); }

}

.stcm-card input:focus,
.coc-card input:focus{
  outline: 1px solid #000 !important;
  outline-offset: 0px !important;
  box-shadow: none !important;
}

.day-layer{ display:none; }
.day-layer.is-active{ display:contents; }

</style>

<style id="controlsCardModuleCss">

#ccRoot { --gap: 10px; --radius: 12px; --line: #e5e7eb; --ink:#111827; --muted:#6b7280; }

#ccRoot{font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif !important;font-size:14px !important;line-height:1.35 !important;color:var(--ink) !important;}

#ccRoot, #ccRoot *{box-sizing:border-box !important;}

#ccRoot h1, #ccRoot h2, #ccRoot h3, #ccRoot strong{ text-transform:none !important; letter-spacing:normal !important; }

#ccRoot button, #ccRoot input, #ccRoot select{ font:inherit !important; }

#ccRoot .cc-btn{appearance:none !important;border:0 !important;border-radius:999px !important;padding:10px 14px !important;font-weight:600 !important;background:#2563eb !important;color:#fff !important;cursor:pointer !important;}

#ccRoot .cc-btn.small{padding:7px 10px !important;font-size:12px !important;}

#ccRoot .cc-btn.micro{padding:5px 9px !important;font-size:10px !important;}

#ccRoot .cc-btn.secondary{background:#374151 !important;}

#ccRoot .cc-btn.whatsapp{background:#16a34a !important;}

#ccRoot .cc-btn.ghost{background:#e5e7eb !important;color:#111827 !important;border:1px solid #9ca3af !important;}

#ccRoot .cc-btn.busy{opacity:.45 !important;cursor:default !important;box-shadow:none !important;}

#ccRoot .cc-btn.off{background:#9ca3af !important;color:#f9fafb !important;}

#ccRoot .cc-btn:disabled{opacity:.9 !important;cursor:default !important;}

#ccRoot .cc-chip{background:#f3f4f6 !important;border-radius:999px !important;padding:4px 8px !important;color:#374151 !important;font-weight:600 !important;}

#ccRoot .chip-input{background:#f3f4f6 !important;border-radius:999px !important;padding:4px 8px !important;border:1px solid #d1d5db !important;color:#111827 !important;font-weight:600 !important;outline:none !important;}

#ccRoot .chip-input:focus{border-color:#93c5fd !important;box-shadow:0 0 0 3px rgba(59,130,246,.15) !important;}

#ccRoot .cc-section{border:1px solid var(--line) !important;border-radius:var(--radius) !important;padding:12px 14px !important;background:#f9fafb !important;}

#ccRoot .cc-section.compact{padding:8px 12px !important;margin-top:6px !important;}

#ccRoot .cc-section-actions{display:flex !important;flex-wrap:wrap !important;gap:8px !important;}

#ccRoot .cc-badge{display:inline-flex !important;align-items:center !important;font-size:12px !important;border-radius:999px !important;padding:2px 8px !important;background:#e5e7eb !important;color:#374151 !important;}

#ccRoot .cc-badge.ok{background:#dcfce7 !important;color:#166534 !important;}

#ccRoot .cc-badge.warn{background:#fee2e2 !important;color:#b91c1c !important;}

#ccRoot .cc-toast{background:#111827 !important;color:#fff !important;border-radius:10px !important;padding:10px 14px !important;white-space:nowrap !important;}

.topbar .cc-btn, #ccRoot .cc-btn{appearance:none;border:0;border-radius:999px;padding:10px 14px;font-weight:600;background:#2563eb;color:#fff;cursor:pointer}

.topbar .cc-btn.whatsapp, #ccRoot .cc-btn.whatsapp{background:#16a34a;}

.topbar .cc-btn.secondary, #ccRoot .cc-btn.secondary{background:#374151}

.topbar .cc-btn.busy, #ccRoot .cc-btn.busy{opacity:0.7;cursor:default;}

.topbar .cc-btn.ghost, #ccRoot .cc-btn.ghost{background:#e5e7eb;color:#111827;border:1px solid #9ca3af}

.topbar .cc-btn:disabled, #ccRoot .cc-btn:disabled{opacity:0.9;cursor:default}

.topbar .cc-chip, main .cc-chip, #ccRoot .cc-chip{background:#f3f4f6;border-radius:999px;padding:4px 8px;color:#374151;font-weight:600}

.topbar .chip-input, main .chip-input, #ccRoot .chip-input{background:#f3f4f6;border-radius:999px;padding:4px 8px;border:1px solid #d1d5db;color:#111827;font-weight:600;outline:none;}

.topbar .chip-input:focus, main .chip-input:focus, #ccRoot .chip-input:focus{border-color:#93c5fd;box-shadow:0 0 0 3px rgba(59,130,246,.15);}

#ccRoot .cc-modal-overlay{position:fixed;inset:0;background:rgba(15,23,42,.45);display:none;align-items:flex-start;justify-content:center;padding:40px 16px;z-index:20;}

#ccRoot .cc-modal-overlay.open{display:flex;}

/* Load Rally File confirm modal */
#loadConfirmOverlay{
  position:fixed;
  inset:0;
  z-index:2147483640;
  display:none;
  align-items:center;
  justify-content:center;
  background:rgba(0,0,0,.25);
}
#loadConfirmOverlay.open{display:flex;}
#loadConfirmPanel{
  background:#fff;
  border-radius:16px;
  box-shadow:0 20px 60px rgba(0,0,0,.25);
  width:min(560px, calc(100vw - 32px));
  padding:18px 18px 14px;
  color:#111827;
}
#loadConfirmPanel h2{margin:0 0 8px;font-size:18px;font-weight:700;color:#111827;}
#loadConfirmPanel p{margin:0 0 14px;font-size:13px;color:#6b7280;line-height:1.35;}
#loadConfirmPanel .actions{display:flex;gap:12px;justify-content:flex-end;padding-top:6px;}
#loadConfirmPanel .actions button{
  border:1px solid #d1d5db;
  background:#fff;
  border-radius:12px;
  padding:10px 18px;
  font-weight:600;
  cursor:pointer;
}
#loadConfirmPanel .actions button.primary{background:#111827;color:#fff;border-color:#111827;}

#ccRoot #entriesPanel{position:relative;background:#fff;border-radius:16px;max-width:720px;width:100%;max-height:90vh;overflow:auto;padding:20px 24px;box-shadow:0 20px 45px rgba(15,23,42,.35);}

#ccRoot .cc-modal-header{display:flex;align-items:center;justify-content:space-between;gap:12px;margin-bottom:8px;}

#ccRoot .cc-modal-header h2{margin:0;font-size:18px;}

#ccRoot .cc-sections{display:flex;flex-direction:column;gap:6px;margin-top:8px;}

main .cc-section, #ccRoot .cc-section{border:1px solid var(--line);border-radius:var(--radius);padding:12px 14px;background:#f9fafb;}

main .cc-section.compact, #ccRoot .cc-section.compact{padding:8px 12px;margin-top:6px;}

main .cc-section h3, #ccRoot .cc-section h3{margin:0 0 4px;font-size:15px;}

main .cc-section p, #ccRoot .cc-section p{margin:0 0 6px;}

main .cc-section-actions, #ccRoot .cc-section-actions{display:flex;flex-wrap:wrap;gap:8px;}

#ccRoot .cc-badge, main .cc-badge{display:inline-flex;align-items:center;font-size:12px;border-radius:999px;padding:2px 8px;background:#e5e7eb;color:#374151;}

#ccRoot .cc-badge.ok, main .cc-badge.ok{background:#dcfce7;color:#166534;}

#ccRoot .cc-badge.warn, main .cc-badge.warn{background:#fee2e2;color:#b91c1c;}

.topbar .cc-btn.small, #ccRoot .cc-btn.small{padding:7px 10px;font-size:12px;}

.topbar .cc-btn.micro, #ccRoot .cc-btn.micro{padding:5px 9px;font-size:10px;}

.topbar .cc-btn.off, #ccRoot .cc-btn.off{background:#9ca3af;color:#f9fafb;}

.topbar .cc-btn.off:hover, #ccRoot .cc-btn.off:hover{background:#9ca3af;}

#ccRoot #webAppUrl.nudge{box-shadow:0 0 0 2px #fca5a5;}

main .cc-row, #ccRoot .cc-row{display:flex;gap:8px;margin:10px 0}

main .cc-row > label, #ccRoot .cc-row > label{min-width:120px;color:#374151;padding-top:8px}

main input[type="text"], main input[type="email"], main input[type="number"], main input[type="tel"], #ccRoot input[type="text"], #ccRoot input[type="email"], #ccRoot input[type="number"], #ccRoot input[type="tel"]{flex:1;border:1px solid var(--line);border-radius:8px;padding:10px 12px}

main .hr, #ccRoot .hr{height:1px;background:var(--line);margin:14px 0}

main .links a, #ccRoot .links a{display:inline-block;margin-right:8px}

main .note, #ccRoot .note{color:var(--muted)}

#ccRoot .cc-toast-slot{flex:1;min-width:160px;display:flex;justify-content:center;align-items:center;}

#ccRoot .cc-toast{position:static;background:#111827;color:#fff;border-radius:10px;padding:10px 14px;opacity:0;transform:translateY(10px);transition:.25s;z-index:30;white-space:nowrap}

#ccRoot .cc-toast.show{opacity:1;transform:translateY(0)}

#ccRoot .sg-grid{display:grid;grid-template-columns:repeat(4,1fr);gap:8px}

#ccRoot .sg-grid input{width:100%;box-sizing:border-box;text-align:center}

.topbar .pill, main .pill, #ccRoot .pill{display:inline-flex;align-items:center;gap:8px}

.topbar .small, main .small, #ccRoot .small{font-size:12px}

.topbar .small, main .small, #ccRoot .small{font-size:12px}

    .topbar .cc-btn.busy, #ccRoot .cc-btn.busy{
      opacity: 0.45 !important;
      cursor: default;
      box-shadow: none;
    }

    .topbar .cc-btn.has-wave, #ccRoot .cc-btn.has-wave{display:inline-flex;align-items:center;justify-content:center;gap:8px;}

#ccRoot .wave-dots{display:inline-flex;gap:3px;width:28px;justify-content:flex-start;}

#ccRoot .wave-dots i{display:inline-block;width:4px;height:4px;border-radius:999px;background:currentColor;opacity:.85;
      animation:waveDot 1.1s infinite ease-in-out;}

#ccRoot .cc-btn .wave-dots i:nth-child(1){animation-delay:0s;}

#ccRoot .cc-btn .wave-dots i:nth-child(2){animation-delay:.1s;}

#ccRoot .cc-btn .wave-dots i:nth-child(3){animation-delay:.2s;}

#ccRoot .cc-btn .wave-dots i:nth-child(4){animation-delay:.3s;}

#ccRoot .cc-btn .wave-dots i:nth-child(5){animation-delay:.4s;}

#ccRoot .cc-toast .wave-dots i:nth-child(1){animation-delay:0s;}

#ccRoot .cc-toast .wave-dots i:nth-child(2){animation-delay:.1s;}

#ccRoot .cc-toast .wave-dots i:nth-child(3){animation-delay:.2s;}

#ccRoot .cc-toast .wave-dots i:nth-child(4){animation-delay:.3s;}

#ccRoot .cc-toast .wave-dots i:nth-child(5){animation-delay:.4s;}

@keyframes waveDot{0%,100%{transform:translateY(0);opacity:.55;}50%{transform:translateY(-4px);opacity:1;}}

@keyframes planSyncPulse{
  0%{box-shadow:0 0 0 0 rgba(245,158,11,0);filter:none;}
  50%{box-shadow:0 0 0 6px rgba(245,158,11,.55);filter:brightness(1.06);}
  100%{box-shadow:0 0 0 0 rgba(245,158,11,0);filter:none;}
}

#ccRoot .cc-btn{
  all: unset !important;
  box-sizing: border-box !important;
  display: inline-flex !important;
  align-items: center !important;
  justify-content: center !important;
  gap: 8px !important;
  padding: 10px 14px !important;
  border-radius: 999px !important;
  font: 600 14px/1.35 system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif !important;
  background: #2563eb !important;
  color: #fff !important;
  border: 0 !important;
  cursor: pointer !important;
}

#ccRoot .cc-btn.small{ padding: 7px 10px !important; font-size: 12px !important; }

#ccRoot .cc-btn.micro{ padding: 5px 9px !important; font-size: 10px !important; }

#ccRoot .cc-btn.secondary{ background:#374151 !important; }

#ccRoot .cc-btn.whatsapp{ background:#16a34a !important; }

#ccRoot .cc-btn.ghost{ background:#e5e7eb !important; color:#111827 !important; border:1px solid #9ca3af !important; }

#ccRoot .cc-btn.off{ background:#9ca3af !important; color:#f9fafb !important; }

#ccRoot .cc-btn.busy{ opacity:.45 !important; cursor: default !important; box-shadow:none !important; }

#ccRoot .cc-chip{
  background:#f3f4f6 !important;
  border-radius:999px !important;
  padding:4px 8px !important;
  color:#374151 !important;
  font-weight:600 !important;
}

#ccRoot .chip-input{
  all: unset !important;
  box-sizing:border-box !important;
  background:#f3f4f6 !important;
  border-radius:999px !important;
  padding:4px 8px !important;
  border:1px solid #d1d5db !important;
  color:#111827 !important;
  font-weight:600 !important;
}

#ccRoot .cc-badge{
  display:inline-flex !important;
  align-items:center !important;
  font-size:12px !important;
  border-radius:999px !important;
  padding:2px 8px !important;
  background:#e5e7eb !important;
  color:#374151 !important;
}

#ccRoot .cc-badge.ok{ background:#dcfce7 !important; color:#166534 !important; }

#ccRoot .cc-badge.warn{ background:#fee2e2 !important; color:#b91c1c !important; }

#ccRoot .cc-section{
  background:#f9fafb !important;
  border:1px solid var(--line) !important;
  border-radius: var(--radius) !important;
  padding:12px 14px !important;
}

#ccRoot .cc-section.compact{ padding:8px 12px !important; margin-top:6px !important; }

#ccRoot .cc-section-actions{ display:flex !important; flex-wrap:wrap !important; gap:8px !important; }

#ccRoot .cc-row{ display:flex !important; gap:8px !important; margin:10px 0 !important; }

#ccRoot .cc-toast{
  background:#111827 !important;
  color:#fff !important;
  border-radius:10px !important;
  padding:10px 14px !important;
  white-space:nowrap !important;
}
</style>

<style id="cc-overlay-zfix">

#ccRoot .cc-modal-overlay{
  z-index: 20000 !important;
}
#ccRoot #entriesPanel{
  z-index: 20001 !important;
}
</style>

<style id="rc-color-recipe">
  
  html, body { background: #f3f4f6 !important; }
  .top-gutter { background: #f3f4f6 !important; } 
  .button-container, .buttons-bar, .hproxy { background: #e9edf3 !important; } 
  .card-head { background: #e5e7eb !important; } 
</style>
</head>
<body>

<div aria-hidden="true" class="top-gutter"></div>

<div aria-label="Top buttons" class="button-container">
<div aria-label="Primary actions" class="left-cluster" role="group">
<button class="btn" id="btnSavePage" type="button">Save</button>
<button class="btn" id="btnLoadPage" type="button">Load</button>
<button class="btn secondary" id="btnExportXLSX" type="button">Export</button>
<button class="btn secondary" type="button">Print</button>
</div>
<div aria-label="Day selector" class="day-cluster" role="group">
  <div aria-label="Day selector" class="center-chip daydd" id="dayPillWrap" role="group">
    <button aria-expanded="false" aria-haspopup="menu" class="daydd-btn" id="dayPillBtn" type="button">
      <span id="dayPillLabel">Day 1 - --</span>
      <span aria-hidden="true" class="daydd-chev">▾</span>
    </button>
    <div aria-label="Select day" class="daydd-menu" hidden="" id="dayPillMenu" role="menu"></div>
  </div>
  <button class="starts-toggle" id="btnStartsStrip" type="button" aria-pressed="false" title="Show Start Times">Starts</button>
</div>
<div aria-label="Rally info" class="mid-gap"><div class="titlepack" id="rallyTitlePack"><div class="mid-pill title-pill" id="rallyTitlePill" title="Rally Title">Rally Title</div><div class="mid-pill issue-pill is-placeholder" id="rallyIssuePill" title="Version">r000</div>
        <button class="btn btn-view" id="pageZoomBtn" type="button" aria-pressed="false" title="Normal view (screen only)">Normal</button></div></div>
<div aria-label="More actions" class="right-cluster" role="group">
<div class="audit-box">
<label style="display:flex; align-items:center; gap:6px;">
<input id="auditToggle" type="checkbox"/> Audit
      </label>
<input class="audit-number" id="auditValue" max="600" min="0" step="10" type="number" value="0"/>
</div>
<span aria-label="Controls data status" class="status-pill" id="controlsDataStatus">Plan changed</span>
<button class="btn secondary" id="btnControlsData" type="button">Controls data</button>
</div>
</div>

<div aria-hidden="true" class="gap-8-top"></div>
<div aria-label="Horizontal scroll proxy" class="hproxy"><div class="hproxy-inner"></div><div aria-hidden="true" class="hproxy-thumb"></div></div>
<div aria-hidden="true" class="gap-8-bottom"></div>
<div aria-hidden="true" class="page-top-gap"></div>
<div class="grid-scroll">
<div class="grid" id="panel"></div>
<div aria-hidden="true" class="rally-drawer" id="rallyDrawer">
<div class="rd-head">
<div class="rd-title">Car —</div>
<button aria-label="Close" class="rd-close" type="button">Close</button>
<div class="rd-head2"><div>Cont.</div><div>ATA</div><div>ETA</div><div>Score</div></div>
</div>
<div class="rd-body" id="rdBody"></div>
</div>
</div>

<div aria-label="Tools (moved below)" class="tools-shelf">
</div>

<script>

(function(){
  // v2.1.38 — Debug gate (default OFF)
// Align with TD_DEBUG: enable via window.TD_DEBUG.sst = true
const __sstDebug_ = () => !!(window.TD_DEBUG && window.TD_DEBUG.sst);
const __sstLog_  = (...a) => { if (__sstDebug_()) console.log('[SST]', ...a); };
const __sstWarn_ = (...a) => { if (__sstDebug_()) console.warn('[SST]', ...a); };

  // v2.1.38 — Payload shape warnings (log-only; never throws)
  function __sstWarnSheetShape_(label, sheet){
    if (!__sstDebug_()) return;
    try{
      if (!sheet || typeof sheet !== 'object'){
        __sstWarn_(label, 'missing/invalid sheet object', sheet);
        return;
      }
      const h = sheet.header;
      const r = sheet.rows;
      if (!Array.isArray(h)) __sstWarn_(label, 'header is not an array', h);
      if (!Array.isArray(r)) __sstWarn_(label, 'rows is not an array', r);
      if (Array.isArray(r) && r.length){
        if (!Array.isArray(r[0])) __sstWarn_(label, 'rows[0] is not an array', r[0]);
      }
    }catch(e){
      __sstWarn_(label, 'shape check failed', e);
    }
  }

  const model = {
    rows: 5,
    drivers: ["","","","",""],
    navigators: ["","","","",""],
    sgs: Array.from({length:5}, () => 60),
    coc: { included: false, cells: Array.from({length:5}, () => ({ text:"", score:"" })) },
    cards: []
  };
  // v2.1.108 — Entries from TD_RALLIES (Admin) => read-only console mapping
  // Controls rows are anchored by RallyNo slots (1..N). We only paint surname + SG for each row.
  function __sstApplyEntriesFromTdRallies_(entries){
    try{
      if(!entries || typeof entries !== 'object') return;

      // Auto-size rows to match Admin's RallyNo slots (1..N)
      const n = (window.__sstDeriveRowCountFromEntries_ ? window.__sstDeriveRowCountFromEntries_(entries) : 0);
      if(n && window.__sstEnsureRowCount_) window.__sstEnsureRowCount_(n);

            const rows = window.__sstDeriveRowCountFromEntries_ ? window.__sstDeriveRowCountFromEntries_(entries) : 0;
      if(rows <= 0) return;
      if(!Array.isArray(model.drivers) || model.drivers.length !== rows) model.drivers = Array.from({length: rows}, () => "");
      if(!Array.isArray(model.navigators) || model.navigators.length !== rows) model.navigators = Array.from({length: rows}, () => "");
      if(!Array.isArray(model.sgs)     || model.sgs.length     !== rows) model.sgs     = Array.from({length: rows}, () => 60);
      if(!Array.isArray(model.sgTiers) || model.sgTiers.length !== rows) model.sgTiers = Array.from({length: rows}, () => 1);

      for(let i=1;i<=rows;i++){
        const rec = entries[i] || entries[String(i)];
        if(!rec) continue;

        {
          // Prefer full name from Admin entries (UI); fallback to stored surname
          let d = "";
          try{
            const nm = (window.__CTRL_nameByRallyNo && (window.__CTRL_nameByRallyNo[i] || window.__CTRL_nameByRallyNo[String(i)])) || "";
            if(nm) d = String(nm).trim();
          }catch(_e){}
          if(!d && typeof rec.surname === 'string') d = rec.surname.trim();
          if(d !== undefined) model.drivers[i-1] = d;
        }


        {
          let nname = "";
          try{
            const nm = (window.__CTRL_navByRallyNo && (window.__CTRL_navByRallyNo[i] || window.__CTRL_navByRallyNo[String(i)])) || "";
            if(nm) nname = String(nm).trim();
          }catch(_e){}
          if(nname !== undefined) model.navigators[i-1] = nname;
        }
        const sgRaw = rec.sg;
        if(sgRaw !== undefined && sgRaw !== null && String(sgRaw).trim() !== ''){
          const n = Number(sgRaw);
          if(!Number.isNaN(n)) model.sgs[i-1] = n;
        }

        const tierRaw = rec.sgTier;
        if(tierRaw !== undefined && tierRaw !== null && String(tierRaw).trim() !== ''){
          const t = Number(tierRaw);
          if(!Number.isNaN(t) && t >= 1 && t <= 4) model.sgTiers[i-1] = t;
        }
      }
    }catch(e){}
  }
  window.__sstApplyEntriesFromTdRallies_ = __sstApplyEntriesFromTdRallies_;

  // v2.1.146 — Normalize Admin Controls entries feed (array or map) into the keyed map expected by Controls.
  // Expected keyed map shape:
  //   entries[rallyNo] = { surname: "SMITH", sg: 60, sgTier: 1 }
  // Admin Controls entries may arrive as an array:
  //   [{rallyNo:1, driversSurname:"SMITH", sgIdx:1, speed:60, startTime:"08:30:00"}, ...]
  function __sstNormalizeEntriesFromControls_(raw){
    try{
      if(!raw) return {};
      // If already keyed map, keep.
      if(typeof raw === 'object' && !Array.isArray(raw)) return raw;
      if(!Array.isArray(raw)) return {};
      const out = {};
      for(const it of raw){
        if(!it) continue;
        const rn = Number(it.rallyNo ?? it.rallyNO ?? it.rally_no ?? it.no ?? it.rallyNumber ?? it.rally_number);
        if(!Number.isFinite(rn) || rn < 1) continue;

        const surname = (it.driversSurname ?? it.driverSurname ?? it.surname ?? it.drivers_surname ?? it.driver_surname ?? "");
        const sgIdx = (it.sgIdx ?? it.sgIndex ?? it.sgTier ?? it.sg_tier ?? it.tier ?? it.sg ?? "");
        const speed = (it.speed ?? it.sgSpeed ?? it.speedKph ?? it.sg_speed ?? it.kph ?? "");

        const rec = {};
        if(surname !== undefined && surname !== null) rec.surname = String(surname);
        if(speed !== undefined && speed !== null && String(speed).trim() !== "") rec.sg = speed;
        if(sgIdx !== undefined && sgIdx !== null && String(sgIdx).trim() !== "") rec.sgTier = sgIdx;

        out[String(rn)] = rec;
      }
      return out;
    }catch(_e){
      return {};
    }
  }
  window.__sstNormalizeEntriesFromControls_ = __sstNormalizeEntriesFromControls_;

  // v2.1.158 — Build driver display name map from Admin entries (for UI only; Google matching still uses surname)
  function __sstBuildDriverNameMapFromAdminEntries_(adminEntriesRaw){
    const map = {};
    try{
      const arr =
        (Array.isArray(adminEntriesRaw) ? adminEntriesRaw :
        (Array.isArray(adminEntriesRaw?.entries) ? adminEntriesRaw.entries :
        (Array.isArray(adminEntriesRaw?.list) ? adminEntriesRaw.list :
        (Array.isArray(adminEntriesRaw?.rows) ? adminEntriesRaw.rows : null))));
      if(!arr) return map;

      for(const e of arr){
        if(!e) continue;
        const rn = Number(e.rallyNo ?? e.rallyNO ?? e.rally_no ?? e.no ?? e.rallyNumber ?? e.rally_number);
        if(!Number.isFinite(rn) || rn < 1) continue;

        const df = (e.driver && (e.driver.first ?? e.driverFirst ?? e.driver_first)) ?? e.driverFirst ?? e.first ?? "";
        const dl = (e.driver && (e.driver.last ?? e.driverSurname ?? e.driverLast ?? e.driver_last)) ?? e.driverSurname ?? e.last ?? "";

        const first = String(df || "").trim();
        const last  = String(dl || "").trim();
        const full  = (first && last) ? (first + " " + last) : (first || last);

        if(full) map[rn] = full;
      }
    }catch(_e){}
    return map;
  }
  window.__sstBuildDriverNameMapFromAdminEntries_ = __sstBuildDriverNameMapFromAdminEntries_;

  // v2.1.177 — Build navigator display name map from Admin entries (for UI/print)
  function __sstBuildNavigatorNameMapFromAdminEntries_(adminEntriesRaw){
    const map = {};
    try{
      const arr =
        (Array.isArray(adminEntriesRaw) ? adminEntriesRaw :
        (Array.isArray(adminEntriesRaw?.entries) ? adminEntriesRaw.entries :
        (Array.isArray(adminEntriesRaw?.list) ? adminEntriesRaw.list :
        (Array.isArray(adminEntriesRaw?.rows) ? adminEntriesRaw.rows : null))));
      if(!arr) return map;

      for(const e of arr){
        if(!e) continue;
        const rn = Number(e.rallyNo ?? e.rallyNO ?? e.rally_no ?? e.no ?? e.rallyNumber ?? e.rally_number);
        if(!Number.isFinite(rn) || rn < 1) continue;

        const nf = (e.navigator && (e.navigator.first ?? e.navFirst ?? e.navigatorFirst ?? e.navigator_first)) ?? e.navFirst ?? e.navigatorFirst ?? "";
        const nl = (e.navigator && (e.navigator.last ?? e.navSurname ?? e.navigatorSurname ?? e.navigatorLast ?? e.navigator_last)) ?? e.navSurname ?? e.navigatorSurname ?? "";

        const first = String(nf || "").trim();
        const last  = String(nl || "").trim();
        const full  = (first && last) ? (first + " " + last) : (first || last);

        if(full) map[rn] = full;
      }
    }catch(_e){}
    return map;
  }
  window.__sstBuildNavigatorNameMapFromAdminEntries_ = __sstBuildNavigatorNameMapFromAdminEntries_;


  // v2.1.108 — Derive row-count (N) from TD_RALLIES entries slots and auto-resize the page rows.
  // Rules:
  //  - RallyNo slots are 1..N (fixed order). Controls must size to N and then paint surname+SG per slot.
  //  - "Remove slot" means the entry key is removed (entries becomes shorter). Controls shrinks accordingly.
  function __sstDeriveRowCountFromEntries_(entries){
    try{
      if(!entries || typeof entries !== 'object') return 0;
      const ks = Object.keys(entries);
      let maxN = 0;
      for(const k of ks){
        const n = Number(k);
        if(Number.isFinite(n) && n > maxN) maxN = n;
      }
      return maxN;
    }catch(e){ return 0; }
  }

  function __sstEnsureRowCount_(n){
    try{
      const target = Number(n);
      if(!Number.isFinite(target) || target < 1) return;
      const cur = Number(model.rows || 0);
      if(cur === target) return;

      // Ensure core arrays exist
      if(!Array.isArray(model.drivers)) model.drivers = [];
        if(!Array.isArray(model.navigators)) model.navigators = [];
      if(!Array.isArray(model.sgs))     model.sgs     = [];
      if(model.coc && !Array.isArray(model.coc.cells)) model.coc.cells = [];
      if(!Array.isArray(model.cards)) model.cards = [];

      // Grow
      while(model.rows < target){
        model.rows += 1;
        model.drivers.push("");
        model.navigators.push("");
        model.sgs.push(60);

        if(model.coc && Array.isArray(model.coc.cells)){
          model.coc.cells.push({ text:"", score:"" });
        }
        if(Array.isArray(model.cards)){
          model.cards.forEach(card => {
            if(!Array.isArray(card.cells)) card.cells = [];
            card.cells.push({ ata:"", eta:"", score:"0" });
          });
        }
      }

      // Shrink
      while(model.rows > target){
        model.rows -= 1;
        if(Array.isArray(model.drivers)) model.drivers.pop();
        model.navigators.pop();
        if(Array.isArray(model.sgs))     model.sgs.pop();
        if(model.coc && Array.isArray(model.coc.cells)) model.coc.cells.pop();
        if(Array.isArray(model.cards)) model.cards.forEach(card => { if(card && Array.isArray(card.cells)) card.cells.pop(); });
      }
    }catch(e){}
  }

  window.__sstDeriveRowCountFromEntries_ = __sstDeriveRowCountFromEntries_;
  window.__sstEnsureRowCount_ = __sstEnsureRowCount_;

  let activeRow = null; // global row highlight across all cards
 // global row highlight index

  // v2.1.36 — Time helpers (dedup; no behaviour change)
  const __SST_TIME_RE = /^([01]\d|2[0-3]):([0-5]\d):([0-5]\d)$/;
  function __sstIsValidTime_(t){ return !!(t && __SST_TIME_RE.test(t)); }
  function __sstTimeToSeconds_(t){
    const m = __SST_TIME_RE.exec(t || "");
    if(!m) return NaN;
    return (parseInt(m[1],10) * 3600) + (parseInt(m[2],10) * 60) + parseInt(m[3],10);
  }
  function __sstNormalizeTimeOrBlank_(raw){
    let v = (raw == null ? "" : String(raw)).trim();
    if(!v) return "";
    // Accept longhand HH:MM:SS
    if(v.includes(":")){
      return (__SST_TIME_RE.test(v) ? v : "");
    }
    // Digits-only shorthand:
    //  1-2 => SS
    //  3-4 => MMSS
    //  5-6 => HHMMSS
    if(!/^\d+$/.test(v)) return "";
    if(v.length > 6) return "";

    let hh = 0, mm = 0, ss = 0;
    if(v.length <= 2){
      ss = parseInt(v,10);
    }else if(v.length <= 4){
      const s = v.padStart(4,"0");
      mm = parseInt(s.slice(0,2),10);
      ss = parseInt(s.slice(2,4),10);
    }else{
      const s = v.padStart(6,"0");
      hh = parseInt(s.slice(0,2),10);
      mm = parseInt(s.slice(2,4),10);
      ss = parseInt(s.slice(4,6),10);
    }

    if(!(Number.isFinite(hh) && Number.isFinite(mm) && Number.isFinite(ss))) return "";
    if(mm > 59 || ss > 59) return "";
    // Keep hours within 0-23 to match __SST_TIME_RE
    if(hh > 23) return "";

    const out = String(hh).padStart(2,"0")+":"+String(mm).padStart(2,"0")+":"+String(ss).padStart(2,"0");
    return (__SST_TIME_RE.test(out) ? out : "");
  }

  function toSeconds(t){
    return __sstTimeToSeconds_(t);
  }
  function addSeconds(t, secs){
    if(!__sstIsValidTime_(t)) return t;
    let tot = (__sstTimeToSeconds_(t) + secs) % 86400;
    if(tot < 0) tot += 86400;
    const hh = String(Math.floor(tot/3600)).padStart(2,"0");
    const mm = String(Math.floor((tot%3600)/60)).padStart(2,"0");
    const ss = String(tot%60).padStart(2,"0");
    return `${hh}:${mm}:${ss}`;
  }

  
  
  // v2.1.158 — STC ETA: use Schedule control times directly (no start times)
  function __sstRefreshStcEtas_(){
    try{
      const root = JSON.parse(localStorage.getItem('TD_RALLIES') || '{}');
      const rid = (typeof __sstPickActiveRid_ === 'function') ? __sstPickActiveRid_(root) : (root.global && root.global.activeRallyId);
      if(!rid) return;
      const rally = (root && root.rallies && root.rallies[rid]) ? root.rallies[rid] : null;
      if(!rally) return;

      const day = (typeof sstCurrentDay !== 'undefined' && sstCurrentDay) ? sstCurrentDay : (rally.ui && rally.ui.activeDay) || 1;
      const dk = String(day);

      const controls = rally.schedule && rally.schedule.days && rally.schedule.days[dk] ? rally.schedule.days[dk].controls : null;
      if(!controls || !Array.isArray(controls)) return;

      const stcTimesByN = {};
      const startStcTimesByN = {};
      for(const c of controls){
        const label = c && c.label ? String(c.label).trim() : '';
        const sgTimes = (c && c.sgTimes && typeof c.sgTimes === 'object') ? c.sgTimes : {};
        let mm = /^STC\s+(\d+)\s*$/i.exec(label);
        if(mm){
          stcTimesByN[mm[1]] = sgTimes;
          continue;
        }
        mm = /^START\s+STC\s+(\d+)\s*$/i.exec(label);
        if(mm){
          startStcTimesByN[mm[1]] = sgTimes;
          continue;
        }
      }

            // Entrant SG index per row (authoritative: admin.controls.days[day].entries[].sgIdx)
      let __dayEntries = null;
      try{
        __dayEntries = (rally.admin && rally.admin.controls && rally.admin.controls.days && rally.admin.controls.days[dk] && Array.isArray(rally.admin.controls.days[dk].entries))
          ? rally.admin.controls.days[dk].entries : null;
      }catch(_e){}

let touched = false;
      for(const card of (model.cards||[])){
        const ctype = getCardType(card);
        if(ctype !== 'STC') continue; // Start STC times are owned by Controls (do not refresh from Schedule)

        const name = (card && (card.name || card.id)) ? String(card.name || card.id) : '';
        const mm = /(Start\s+)?STC\s+(\d+)/i.exec(name);
        const n = mm ? mm[2] : null;
        if(!n) continue;

        const sgTimes = (ctype === 'Start STC') ? (startStcTimesByN[n] || stcTimesByN[n]) : stcTimesByN[n];
        if(!sgTimes) continue;
        if(!Array.isArray(card.cells)) continue;

        for(let r=0; r<model.rows; r++){
          const tier = (__dayEntries && __dayEntries[r] && (__dayEntries[r].sgIdx!=null)) ? String(__dayEntries[r].sgIdx) : ((Array.isArray(model.sgTiers) && model.sgTiers[r]) ? String(model.sgTiers[r]) : '1');
          const elapsed = sgTimes ? String(sgTimes[String(tier)] || '').trim() : '';
          const eta = (__sstIsValidTime_(elapsed)) ? elapsed : '';
          if(card.cells[r] && card.cells[r].eta !== eta){
            card.cells[r].eta = eta;
            // keep score consistent with refreshed ETA
            try{ card.cells[r].score = computeScore(card.cells[r].ata, eta, getCardType(card)); }catch(_e){}
            touched = true;
          }
        }
      }

      if(touched){
        render();
      }
    }catch(_e){}
  }
  window.__sstRefreshStcEtas_ = __sstRefreshStcEtas_;

// v2.1.136 — Marshal ETA: derive from Admin start times + Schedule control elapsed times
  function __sstRefreshMarshalEtas_(){
    try{
      const root = JSON.parse(localStorage.getItem('TD_RALLIES') || '{}');
      const rid = (typeof __sstPickActiveRid_ === 'function') ? __sstPickActiveRid_(root) : (root.global && root.global.activeRallyId);
      if(!rid) return;

      // Support both schemas: root[rid] (new) and root.rallies[rid] (legacy)
      const rally = (root && root[rid]) ? root[rid] : ((root && root.rallies && root.rallies[rid]) ? root.rallies[rid] : null);
      if(!rally) return;

      const day = (typeof sstCurrentDay !== 'undefined' && sstCurrentDay) ? sstCurrentDay : (rally.ui && rally.ui.activeDay) || 1;
      const dk = String(day);

      // Start times map by rallyNo
      // SOURCE OF TRUTH: admin.controls.days[day].entries[].startTime (day-scoped, precomputed).
      let startMap = null;
      try{
        const entries =
          (rally.admin && rally.admin.controls && rally.admin.controls.days && rally.admin.controls.days[dk] && Array.isArray(rally.admin.controls.days[dk].entries))
            ? rally.admin.controls.days[dk].entries
            : null;

        if(entries && entries.length){
          startMap = {};
          for(const e of entries){
            if(!e) continue;
            const rn = String(e.rallyNo ?? '').trim();
            const st = String(e.startTime ?? '').trim();
            if(rn && st) startMap[rn] = st;
          }
        }
      }catch(_e){}

      // Day controls list (Schedule)


      const dayControls =
        (rally.schedule && rally.schedule.days && Array.isArray(rally.schedule.days.controls)) ? rally.schedule.days.controls :
        (rally.schedule && rally.schedule.days && rally.schedule.days[dk] && Array.isArray(rally.schedule.days[dk].controls)) ? rally.schedule.days[dk].controls :
        (rally.schedule && rally.schedule[dk] && Array.isArray(rally.schedule[dk].controls)) ? rally.schedule[dk].controls :
        (rally.schedul && rally.schedul[dk] && Array.isArray(rally.schedul[dk].controls)) ? rally.schedul[dk].controls :
        null;

      // Helper: parse "HH:MM:SS" to seconds
      function _tsec(hms){
        const s = String(hms||"").trim();
        if(!s) return null;
        const parts = s.split(":").map(x=>parseInt(x,10));
        if(parts.length < 2) return null;
        const hh = parts.length===3 ? parts[0] : 0;
        const mm = parts.length===3 ? parts[1] : parts[0];
        const ss = parts.length===3 ? parts[2] : parts[1];
        if(!Number.isFinite(hh)||!Number.isFinite(mm)||!Number.isFinite(ss)) return null;
        return hh*3600 + mm*60 + ss;
      }
      function _fmt(sec){
        if(!Number.isFinite(sec)) return "";
        sec = Math.max(0, Math.round(sec));
        const hh = Math.floor(sec/3600);
        const mm = Math.floor((sec%3600)/60);
        const ss = sec%60;
        const z = (n)=>String(n).padStart(2,"0");
        return `${z(hh)}:${z(mm)}:${z(ss)}`;
      }

      // Find card elements of type Marshal OR Open Control (same ETA logic)
      const cards = Array.from(document.querySelectorAll('.card')).filter(c=>{
        const t = (c.querySelector('.card-head .title')?.textContent || c.textContent || "").toLowerCase();
        return t.includes('marshal') || t.includes('open control');
      });

      if(!cards.length) return;

      let touched = false;

      for(const cardEl of cards){
        // Determine control label, e.g. "Marshal 1" or "Open Control 1"
        const title = (cardEl.querySelector('.card-head .title')?.textContent || "").trim();
        // Determine control index in schedule by matching type + n (best-effort)
        let ctrlObj = null;
        if(dayControls && title){
          const lower = title.toLowerCase();
          ctrlObj = dayControls.find(c=>{
            if(!c || !c.type) return false;
            const ty = String(c.type).toLowerCase();
            if(lower.startsWith('marshal') && !ty.includes('marshal')) return false;
            if(lower.startsWith('open control') && !ty.includes('open control')) return false;
            // match n if present
            const m = lower.match(/\b(\d+)\b/);
            if(m){
              const n = parseInt(m[1],10);
              return (c.n!=null ? (parseInt(c.n,10)===n) : (String(c.label||"").toLowerCase().includes(String(n))));
            }
            return true;
          }) || null;
        }

        // For each row (entrant) compute ETA into the ETA cells
        const etaCells = Array.from(cardEl.querySelectorAll('.cell.kind-eta'));
        for(const cell of etaCells){
          const row = parseInt(cell.getAttribute('data-row')||"",10);
          if(!Number.isFinite(row)) continue;

          // find rallyNo for this row: row index is 1-based in UI; use controls.entries array
          const eArr = (rally.controls && Array.isArray(rally.controls.entries)) ? rally.controls.entries :
                       (rally.admin && rally.admin.controls && Array.isArray(rally.admin.controls.entries)) ? rally.admin.controls.entries :
                       null;
          const ent = (eArr && eArr[row]) ? eArr[row] : null;
          const rallyNo = ent ? String(ent.rallyNo ?? '') : String(row+1);
          const sgIdx = ent ? String(ent.sgIdx ?? ent.sg ?? '') : '';
          let base = null;
          let hasUpstreamStartStc = false;

          // v2.1.241 — ETA base: if a Start STC card exists earlier in the controls sequence,
          // Marshal/Open Control ETA uses that committed Start STC time + elapsed (schedule).
          // Otherwise use rally start time (admin data).
          try{
            const cid = cardEl.dataset ? cardEl.dataset.cardId : null;
            if(cid && Array.isArray(model.cards)){
              const ci = model.cards.findIndex(c=>String(c.id||"")===String(cid));
              if(ci > 0){
                for(let j=ci-1; j>=0; j--){
                  const prev = model.cards[j];
                  if(getCardType(prev) === 'Start STC'){ hasUpstreamStartStc = true;
                    if(prev && Array.isArray(prev.cells)){
                      const ccell = prev.cells[row] || {};
                      const v = (ccell.eta != null) ? String(ccell.eta).trim() : '';
                      const committed = !!ccell.etaCommitted;
                      if(committed && v && v !== '00:00:00' && _tsec(v)!=null){
                        base = v;
                      }
                    }
                    break;
                  }
                }
              }
            }
          }catch(_e){}

          if(!base){
            // v2.1.242 — If a Start STC exists upstream but no committed Start STC time is set for this row,
            // leave ETA blank (do NOT fall back to Admin start time).
            if(hasUpstreamStartStc){
              const tgtBlank = cell.querySelector('.etaText, span');
              if(tgtBlank) tgtBlank.textContent = '';
              try{
                const cid2 = cardEl.dataset ? cardEl.dataset.cardId : null;
                if(cid2 && Array.isArray(model.cards)){
                  const ci2 = model.cards.findIndex(c=>String(c.id||"")===String(cid2));
                  if(ci2>=0 && model.cards[ci2] && Array.isArray(model.cards[ci2].cells) && model.cards[ci2].cells[row]){
                    model.cards[ci2].cells[row].eta = '';
                  }
                }
              }catch(_e){}
              continue;
            }
            base = (startMap && rallyNo) ? startMap[rallyNo] : null; // TIDY-ONLY: single source of truth
}
          if(!base) continue;

          // elapsed from schedule: ctrlObj.sgTimes[sgIdx]
          let elapsed = null;
          try{
            if(ctrlObj && ctrlObj.sgTimes && sgIdx){
              elapsed = ctrlObj.sgTimes[sgIdx] || ctrlObj.sgTimes[String(sgIdx)];
            }
          }catch(_e){}

          // If no schedule match, skip (do not invent)
          if(!elapsed) continue;

          const bsec = _tsec(base);
          const esec = _tsec(elapsed);
          if(bsec==null || esec==null) continue;

          const out = _fmt(bsec + esec);
          const tgt = cell.querySelector('.etaText, span');
          const old = tgt ? String(tgt.textContent||"").trim() : "";
          if(tgt && out && old !== out){
            tgt.textContent = out;

            // Also update in-memory model (drawer uses model.cards[*].cells[*].eta)
            try{
              const cid = cardEl.dataset ? cardEl.dataset.cardId : null;
              if(cid && Array.isArray(model.cards)){
                const mc = model.cards.find(c=>String(c.id||"")===String(cid));
                if(mc && Array.isArray(mc.cells) && mc.cells[row]){
                  mc.cells[row].eta = out;
                }
              }
            }catch(_e){}
            touched = true;
          }
        }
      }

      if(touched){
        try{ if(typeof render === 'function') render(); }catch(_e){}
      }
    }catch(_e){}
  }
  window.__sstRefreshMarshalEtas_ = __sstRefreshMarshalEtas_;
// v2.1.159 — Open Control ETA: Admin start time + Schedule control elapsed times (per SG)
  // v2.1.237 — Open Control ETA: same logic as Marshal (entrant start time + schedule control sgTimes elapsed)
  function __sstRefreshOpenControlEtas_(){
    try{
      // Open Control ETAs are computed in __sstRefreshMarshalEtas_ (shared path).
      // Keep this shim for compatibility with older call sites.
      if(window.__sstRefreshMarshalEtas_) window.__sstRefreshMarshalEtas_();
    }catch(_e){}
  }
  window.__sstRefreshOpenControlEtas_ = __sstRefreshOpenControlEtas_;
  try{
    window.addEventListener('TD_CONTROLS_CHANGED', (ev)=>{
      try{
        const d = ev && ev.detail ? ev.detail : {};
        if(d && d.day && typeof sstCurrentDay !== 'undefined' && String(d.day) !== String(sstCurrentDay)) return;
        try{ if(window.__sstRefreshStcEtas_) window.__sstRefreshStcEtas_(); }catch(_e){}
        try{ if(window.__sstRefreshOpenControlEtas_) window.__sstRefreshOpenControlEtas_(); }catch(_e){}
        __sstRefreshMarshalEtas_();
      }catch(_e){}
    });
  }catch(_e){}

function getCardType(card){
    if(card.type) return card.type;
    const n = String(card.name||"").toLowerCase();
    if(n.startsWith("marshal")) return "Marshal";
    if(n.startsWith("open control")) return "Open Control";
    if(n.startsWith("start stc")) return "Start STC";
    return "STC";
  }
  function computeScore(ata, eta, type){
    // Score = ATA - ETA (signed seconds). If ATA is unset (00:00:00) => 0.
    // Rule: COC is uncapped; Marshal/STC/Open Control are clamped to ±600.
    const a = (ata == null ? "" : String(ata)).trim();
    const e = (eta == null ? "" : String(eta)).trim();
    if(!a || !e) return "0";
    if(a === "00:00:00") return "0";
    if(!__sstIsValidTime_(a) || !__sstIsValidTime_(e)) return "0";

    let diff = __sstTimeToSeconds_(a) - __sstTimeToSeconds_(e);

    // Clamp for all non-COC types
    if(String(type || "").toLowerCase() !== "coc"){
      if(diff > 600) diff = 600;
      else if(diff < -600) diff = -600;
    }

    return String(diff);
  }
  // Persist computed day totals to TD_RALLIES (derived cache for Days Results print)
  function tdGetActiveRidSafe(){
    try{ if(typeof getActiveRid==='function') return getActiveRid(); }catch(_e){}
    try{ if(window.TD_ACTIVE_RID) return window.TD_ACTIVE_RID; }catch(_e){}
    return 'RID-DEV';
  }
  function tdGetActiveDaySafe(){
    try{
      const rid = tdGetActiveRidSafe();
      const raw = localStorage.getItem('TD_RALLIES');
      const obj = raw ? JSON.parse(raw) : null;
      const v = obj && obj.rallies && obj.rallies[rid] && obj.rallies[rid].ui ? Number(obj.rallies[rid].ui.activeDay) : NaN;
      if(v>=1) return v;
    }catch(_e){}
    try{ if(window.sstCurrentDay) return parseInt(window.sstCurrentDay,10)||1; }catch(_e){}
    try{ if(window.TD_ACTIVE_DAY) return parseInt(window.TD_ACTIVE_DAY,10)||1; }catch(_e){}
    return 1;
  }
  function tdPersistDayTotals(_totals){ /* v2.2.315: derived totals are never persisted */ }

  function recomputeTotals(){
    const totals = new Array(model.rows).fill(0);
    if(model.coc && model.coc.included){
      for(let r=0;r<model.rows;r++){
        const s = parseInt(model.coc.cells[r].score||"0",10);
        if(!isNaN(s)) totals[r]+=Math.abs(s);
      }
    }
    model.cards.forEach(card => {
      for(let r=0;r<model.rows;r++){
        const s = parseInt(card.cells[r].score||"0", 10);
        if(card.included) totals[r]+= (isNaN(s)?0:Math.abs(s));
      }
    });
    // v2.2.315: derived totals are not persisted
    return totals;
  }
  function validateAgainstPrevETA(rowIndex, cardIndex, currentValue, inputEl){
    // v2.1.248 — "Can't go backwards" warning:
    // - Only applies to STC ATA entries (same time-domain).
    // - Prior reference ignores Marshal / Open Control / Start STC.
    // - Start STC breaks the chain (no cross-domain compare).
    let bad = false;
    try{
      const curCard = (model.cards && model.cards[cardIndex]) ? model.cards[cardIndex] : null;
      const curType = curCard ? getCardType(curCard) : '';
      if(curType !== 'STC'){
        // Different domains: no monotonic warning
        bad = false;
      }else{
        let prevVal = null;
        for(let j=cardIndex-1; j>=0; j--){
          const pc = model.cards[j];
          const pt = pc ? getCardType(pc) : '';
          if(pt === 'Start STC'){ prevVal = null; break; } // chain break
          if(pt === 'Marshal' || pt === 'Open Control'){ continue; } // ignore
          if(pt === 'STC'){
            const cell = (pc.cells && pc.cells[rowIndex]) ? pc.cells[rowIndex] : null;
            const v = cell ? String(cell.ata || '').trim() : '';
            if(v && __sstIsValidTime_(v)) prevVal = v;
            break;
          }
        }
        const cur = (currentValue == null) ? '' : String(currentValue).trim();
        if(cur && prevVal && __sstIsValidTime_(cur) && __sstIsValidTime_(prevVal)){
          bad = (toSeconds(cur) < toSeconds(prevVal));
        }else{
          bad = false;
        }
      }
    }catch(_e){ bad = false; }

    try{ inputEl.classList.toggle("error", !!bad); }catch(_e){}
    if(model.cards[cardIndex] && model.cards[cardIndex].cells[rowIndex]){
      model.cards[cardIndex].cells[rowIndex].monoError = !!bad;
    }
    return !!bad;
  }

  function applyActiveRow(){
  document.querySelectorAll('.card-body').forEach(el => {
    if(activeRow === null || activeRow === undefined) el.removeAttribute('data-active-row');
    else el.setAttribute('data-active-row', String(activeRow));
  });
}
  function setActiveRowGlobal(row){ activeRow = row; applyActiveRow(); }
  function clearActiveRowGlobal(){ activeRow = null; applyActiveRow(); }

  function render(){
    // cards
    const panel = document.getElementById("panel");
    panel.innerHTML = "";
    // --- Console Card injected as first card in the panel (mirrors left totals) ---
    (function(){
      const totalsCardEl = document.createElement("div"); totalsCardEl.className="card console-card"; totalsCardEl.dataset.cardId = "console-card";

      // Header: two rows of labels for 4 cols
      const head = document.createElement("div"); head.className="card-head";
      // Column 1 (Driver/Name, left with indent)
      const h1top = document.createElement("div"); h1top.className="col top"; h1top.textContent="Driver"; h1top.style.gridRow="1"; h1top.style.textAlign="left"; h1top.style.paddingLeft="0.6em"; head.appendChild(h1top);
      const h1bot = document.createElement("div"); h1bot.className="col"; h1bot.textContent="Name"; h1bot.style.gridRow="2"; h1bot.style.textAlign="left"; h1bot.style.paddingLeft="0.6em"; head.appendChild(h1bot);
      // Column 2 (Navigator/Name, left with indent)
      const hnTop = document.createElement("div"); hnTop.className="col top"; hnTop.textContent="Navigator"; hnTop.style.gridRow="1"; hnTop.style.textAlign="left"; hnTop.style.paddingLeft="0.6em"; head.appendChild(hnTop);
      const hnBot = document.createElement("div"); hnBot.className="col"; hnBot.textContent="Name"; hnBot.style.gridRow="2"; hnBot.style.textAlign="left"; hnBot.style.paddingLeft="0.6em"; head.appendChild(hnBot);
      // Column 3 (Speed/Group centered)
      const h2top = document.createElement("div"); h2top.className="col top"; h2top.textContent="Speed"; h2top.style.gridRow="1"; h2top.style.textAlign="center"; head.appendChild(h2top);
      const h2bot = document.createElement("div"); h2bot.className="col"; h2bot.textContent="Group"; h2bot.style.gridRow="2"; h2bot.style.textAlign="center"; head.appendChild(h2bot);
      // Column 4 (Rally/No centered)
      const h3top = document.createElement("div"); h3top.className="col top"; h3top.textContent="Rally"; h3top.style.gridRow="1"; h3top.style.textAlign="center"; head.appendChild(h3top);
      const h3bot = document.createElement("div"); h3bot.className="col"; h3bot.textContent="No"; h3bot.style.gridRow="2"; h3bot.style.textAlign="center"; head.appendChild(h3bot);
      // Column 5 (Total/Score OR Start/Time centered in header)
      const h4top = document.createElement("div"); h4top.className="col top";
      h4top.textContent = (sstShowStartsStrip ? "Start" : "Total");
      h4top.style.gridRow="1"; h4top.style.textAlign="center"; head.appendChild(h4top);
      const h4bot = document.createElement("div"); h4bot.className="col";
      h4bot.textContent = (sstShowStartsStrip ? "Time" : "Score");
      h4bot.style.gridRow="2"; h4bot.style.textAlign="center"; head.appendChild(h4bot); h4bot.style.gridRow="2"; h4bot.style.textAlign="center"; head.appendChild(h4bot);

      const body = document.createElement("div"); body.className="card-body";

      // Row activation
      body.addEventListener("focusin", (e)=>{
        const cell = e.target.closest(".cell");
        if(cell && body.contains(cell)){ setActiveRowGlobal(Number(cell.dataset.row)); }
      });
      body.addEventListener("mousedown", (e)=>{
        const cell = e.target.closest(".cell");
        if(cell && body.contains(cell)){ setActiveRowGlobal(Number(cell.dataset.row)); }
      });
      body.addEventListener("focusout", (e)=>{
        setTimeout(()=>{
          const stillInsideAny = Array.from(document.querySelectorAll('.card-body')).some(el => el.contains(document.activeElement));
          if(!stillInsideAny){ clearActiveRowGlobal(); }
        }, 0);
      });

      const totalsVals = recomputeTotals();
      const startMap = (sstShowStartsStrip && (typeof sstGetStartsMapForDay_ === "function")) ? sstGetStartsMapForDay_(sstGetActiveDayNo_()) : null;
      for(let r=0;r<model.rows;r++){
        // col1: Driver name
        const c1 = document.createElement("div"); c1.className = "cell"; c1.dataset.row = String(r);
        const d = document.createElement("div"); d.className = "console-driver";
        d.textContent = (model.drivers[r] == null ? "" : String(model.drivers[r]));
        c1.appendChild(d); body.appendChild(c1);
        // col2: Navigator name
        const cn = document.createElement("div"); cn.className = "cell"; cn.dataset.row = String(r);
        const nv = document.createElement("div"); nv.className = "console-driver";
        nv.textContent = (model.navigators && model.navigators[r] != null ? String(model.navigators[r]) : "");
        cn.appendChild(nv); body.appendChild(cn);
        // col3: Speed group
        const c2 = document.createElement("div"); c2.className = "cell"; c2.dataset.row = String(r);
        const s = document.createElement("div"); 
        const sgVal = (model.sgs && model.sgs[r] != null ? String(model.sgs[r]) : "60");
        const tier = (model.sgTiers && model.sgTiers[r] != null ? Number(model.sgTiers[r]) : 1);
        s.textContent = String(sgVal);

        // Tier tint (SG1 = no tint)
// Note: use an inset stroke so the table border stays crisp under tinted backgrounds.
        if(tier === 2) c2.style.backgroundColor = "var(--sg2)";
        else if(tier === 3) c2.style.backgroundColor = "var(--sg3)";
        else if(tier === 4) c2.style.backgroundColor = "var(--sg4)";
        else c2.style.backgroundColor = "transparent";

        // Preserve border visibility (collapsed borders can look washed out on tinted cells)
        c2.style.boxShadow = (tier >= 2 ? "inset 0 0 0 1px var(--border)" : "");
s.style.fontFamily = "ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif";
        s.style.fontSize = "14px"; s.style.lineHeight = "1.35"; s.style.textAlign="center"; s.style.color="blue";
        c2.appendChild(s); body.appendChild(c2);
        // col3: Rally number (blue + bold, centered)
        const c3 = document.createElement("div"); c3.className = "cell"; c3.dataset.row = String(r);
        const rn = document.createElement("div"); rn.className = "rally-no"; rn.textContent= String(r+1);
        rn.style.fontFamily = "ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif";
        rn.style.fontSize = "14px"; rn.style.lineHeight = "1.35"; rn.style.textAlign="center";
        c3.appendChild(rn); body.appendChild(c3);
        // col5: Total score OR Start time (swap-only)
        const c4 = document.createElement("div"); c4.className = "cell"; c4.dataset.row = String(r);
        if(sstShowStartsStrip){
          const v = (startMap && startMap[String(r+1)] != null) ? String(startMap[String(r+1)]) : "";
          const st = document.createElement("span"); st.className = "console-start";
          st.textContent = v;
          st.style.fontFamily = 'ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
          st.style.fontSize = "13px"; st.style.lineHeight = "1.35";
          st.style.color = "var(--accent)";
          st.style.textAlign = "center";
          c4.style.justifyContent = "center";
          c4.appendChild(st);
        }else{
          const score = document.createElement("span"); score.className = "console-score"; score.textContent = String(totalsVals[r] || 0);
          score.style.fontFamily = "ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif";
          score.style.fontSize = "14px"; score.style.lineHeight = "1.35";
          c4.appendChild(score);
        }
        body.appendChild(c4);
      }

      totalsCardEl.appendChild(head); totalsCardEl.appendChild(body);
      panel.appendChild(totalsCardEl);
    })();


    // v2.1.119 — "cake layers": 7 day layers (console stays outside; all other cards render into active layer)
    let __activeDayNo = 1;
    // v2.2.315 — active day must follow the canonical day pill (TD_ACTIVE_DAY / sstCurrentDay),
    // not a stale rally.ui.activeDay snapshot.
    try{
      const __vPill = Number(localStorage.getItem('TD_ACTIVE_DAY'));
      if(__vPill>=1 && __vPill<=7) __activeDayNo = __vPill;
    }catch(_e){}
    try{
      const __vMem = Number(sstCurrentDay);
      if(__vMem>=1 && __vMem<=7) __activeDayNo = __vMem;
    }catch(_e){}
    if(!(__activeDayNo>=1 && __activeDayNo<=7)){
      __activeDayNo = 1;
      try{
        const __root = JSON.parse(localStorage.getItem('TD_RALLIES') || '{}') || {};
        const __rid = (__root && __root.global && typeof __root.global.activeRallyId === 'string') ? __root.global.activeRallyId : '';
        const __rally = (__root && __root.rallies && __rid) ? __root.rallies[__rid] : null;
        const __ui = (__rally && __rally.ui) ? __rally.ui : null;
        const __v = __ui ? Number(__ui.activeDay) : NaN;
        if(__v>=1 && __v<=7) __activeDayNo = __v;
      }catch(_e){}
    }

    const __dayLayers = [];
    for(let __d=1; __d<=7; __d++){
      const __layer = document.createElement('div');
      __layer.className = 'day-layer' + (__d===__activeDayNo ? ' is-active' : '');
      __layer.setAttribute('data-day', String(__d));
      __dayLayers.push(__layer);
      panel.appendChild(__layer);
    }
    const __activeLayer = __dayLayers[__activeDayNo-1] || panel;

// --- Permanent CoC card (Clerk of the Course) inserted after Console ---
(function(){
  const cocEl = document.createElement("div"); cocEl.className="card coc-card"; cocEl.dataset.cardId = "coc-card";
  if(!(model.coc && model.coc.included)) cocEl.classList.add('excluded');

  // Header (row1 title + checkbox, row2 labels)
  const head = document.createElement("div"); head.className="card-head"; head.style.position="relative";
  const h2a = document.createElement("div"); h2a.className="col"; h2a.textContent="Penalties"; h2a.style.gridRow="2"; head.appendChild(h2a);
  const h2b = document.createElement("div"); h2b.className="col"; h2b.textContent="Score"; h2b.style.gridRow="2"; head.appendChild(h2b);
  const title = document.createElement("div"); title.className="title"; title.style.gridRow="1"; title.style.gridColumn="1 / span 2";
const cb = document.createElement("input"); cb.type="checkbox"; cb.className="coc-toggle";
cb.checked = !!(model.coc && model.coc.included);
cb.addEventListener("change", ()=>{ model.coc.included = cb.checked; render(); });
const label = document.createElement("span"); label.textContent = "Clerk of the Course";
      // v2.0.243 — day tag in header (skip Day 1) (boring nudge)
      if(typeof sstCurrentDay === "number" && sstCurrentDay > 1){
        title.style.position = "relative";
        const dayTag = document.createElement("span");
        dayTag.textContent = "Day " + sstCurrentDay;
        dayTag.style.position = "absolute";
        dayTag.style.right = "22px";
        dayTag.style.top = "6px";
        dayTag.style.fontSize = "12px";
        dayTag.style.fontWeight = "700";
        dayTag.style.color = "var(--muted)";
        dayTag.style.pointerEvents = "none";
        title.appendChild(dayTag);
      }
title.appendChild(cb); title.appendChild(label); head.appendChild(title);
const body = document.createElement("div"); body.className="card-body";

  // Row activation parity
  body.addEventListener("focusin", (e)=>{
    const cell = e.target.closest(".cell");
    if(cell && body.contains(cell)){ setActiveRowGlobal(Number(cell.dataset.row)); }
  });
  body.addEventListener("mousedown", (e)=>{
    const cell = e.target.closest(".cell");
    if(cell && body.contains(cell)){ setActiveRowGlobal(Number(cell.dataset.row)); }
  });
  body.addEventListener("focusout", (e)=>{
    setTimeout(()=>{
      const stillInsideAny = Array.from(document.querySelectorAll('.card-body')).some(el => el.contains(document.activeElement));
      if(!stillInsideAny){ clearActiveRowGlobal(); }
    }, 0);
  });

  for(let r=0;r<model.rows;r++){
    // Col 1: text entry
    const c1 = document.createElement("div"); c1.className="cell"; c1.dataset.row=String(r);
    const t = document.createElement("input"); t.type="text"; t.className="coc-text"; t.placeholder="Edit as required";
    t.value = model.coc.cells[r].text || "";
    t.addEventListener("change", ()=>{ model.coc.cells[r].text = t.value; if(!window.__TD_DAY_MIRROR_APPLYING){ try{ sstPersistDay(sstCurrentDay); }catch(_e){} } });
    c1.appendChild(t); body.appendChild(c1);

    // Col 2: numeric score (up to 9999), placeholder 'xxxx'
    const c2 = document.createElement("div"); c2.className="cell"; c2.dataset.row=String(r);
    const n = document.createElement("input"); n.type="text"; n.className="coc-num"; n.placeholder="xxx"; n.maxLength = 7; n.inputMode = "text";
    n.value = model.coc.cells[r].score || "";
    n.addEventListener("input", ()=>{
      // allow optional leading '-' and digits (COC is uncapped)
      const s = String(n.value||"");
      const m = s.match(/^-?\d{0,6}/);
      n.value = (m && m[0] != null) ? m[0] : "";
    });
    n.addEventListener("focus", ()=>{ try{ n.select(); }catch(_e){} });
    n.addEventListener("mouseup", (e)=>{ try{ e.preventDefault(); }catch(_e){} });
n.addEventListener("change", ()=>{
      model.coc.cells[r].score = n.value;
      if(!window.__TD_DAY_MIRROR_APPLYING){ try{ sstPersistDay(sstCurrentDay); }catch(_e){} }
      render();
    });
    c2.appendChild(n); body.appendChild(c2);
  }

  cocEl.appendChild(head); cocEl.appendChild(body);
  __activeLayer.appendChild(cocEl);
  // v2.0.109 — expose safe row add/remove that use internal model + render
  if (!window.__appRow) window.__appRow = {};
  window.__appRow.add = function(){
    model.rows += 1;
    const r = model.rows - 1;
    model.drivers.push("#" + (r+1));
    if (model.coc && Array.isArray(model.coc.cells)) {
      model.coc.cells.push({ text:"", score:"" });
    }
    if (Array.isArray(model.cards)) {
      model.cards.forEach(card => {
        if(!Array.isArray(card.cells)) card.cells = [];
            card.cells.push({ ata:"", eta:"", score:"0" });
      });
    }
    render();
  };
  window.__appRow.remove = function(){
    if (model.rows <= 1) return;
    model.rows -= 1;
    model.drivers.pop();
    if (model.coc && Array.isArray(model.coc.cells)) model.coc.cells.pop();
    if (Array.isArray(model.cards)) model.cards.forEach(card => { card.cells.pop(); });
    render();
  };
  // hook up buttons when DOM is ready
  window.addEventListener('DOMContentLoaded', function(){
    const addBtn = document.getElementById('btnRowAdd');
    const remBtn = document.getElementById('btnRowRemove');
    const saveBtn = document.getElementById('btnSavePage');
    const loadBtn = document.getElementById('btnLoadPage');
    refreshWorkspaceUi_();
    const exportBtn = document.getElementById('btnExportXLSX');
    if (addBtn) addBtn.addEventListener('click', window.__appRow.add);
    if (remBtn) remBtn.addEventListener('click', window.__appRow.remove);
// Post-save UX parity helpers (toast + issue pill refresh)
const tdShowToast_ = (msg) => {
  try {
    const el = document.getElementById('cc-toast');
    // Prefer overlay toast only if it's actually visible; otherwise use fallback.
    if (el) {
      const cs = getComputedStyle(el);
      const visible = (cs.display !== 'none') && (el.getClientRects().length > 0);
      if (visible) {
        el.textContent = msg;
        el.style.display = 'inline-block';
        el.style.opacity = '1';
        clearTimeout(el.__tdTimer);
        el.__tdTimer = setTimeout(()=>{ el.style.opacity='0'; }, 2200);
        return;
      }
    }
    let t = document.getElementById('td-toast-fallback');
    if (!t) {
      t = document.createElement('div');
      t.id = 'td-toast-fallback';
      t.style.position = 'fixed';
      t.style.left = '50%';
      t.style.bottom = '18px';
      t.style.transform = 'translateX(-50%)';
      t.style.background = '#111827';
      t.style.color = '#fff';
      t.style.padding = '10px 14px';
      t.style.borderRadius = '10px';
      t.style.zIndex = '99999';
      t.style.whiteSpace = 'nowrap';
      t.style.fontSize = '13px';
      t.style.pointerEvents = 'none';
      document.body.appendChild(t);
    }
    t.textContent = msg;
    t.style.display = 'block';
    t.style.opacity = '1';
    clearTimeout(t.__tdTimer);
    t.__tdTimer = setTimeout(()=>{ t.style.opacity='0'; }, 2200);
  } catch(e) {}
};

const tdRefreshIssuePill_ = () => {
  try {
    const td = JSON.parse(localStorage.getItem('TD_RALLIES') || 'null');
    const rid = (typeof window.getRid_ === 'function' ? window.getRid_() : (td && td.global && td.global.activeRallyId)) || null;
    const issue = rid && td && td.rallies && td.rallies[rid] && td.rallies[rid].meta ? td.rallies[rid].meta.issue : null;
    const pill = document.getElementById('rallyIssuePill');
    if (pill && issue) {
      pill.textContent = issue;
      pill.classList.remove('is-placeholder');
    }
  } catch(e) {}
};
    if (saveBtn && !saveBtn.__tdBoundSave){
      saveBtn.__tdBoundSave = true;
      saveBtn.addEventListener('click', async ()=>{
        if(!window.tdWorkspaceSaveSnapshot){ alert('Save not available.'); return; }
        const ok = await window.tdWorkspaceSaveSnapshot();
        // Parity: visible confirmation + pill refresh
        if (ok) {
          tdRefreshIssuePill_();
          try {
            const td = JSON.parse(localStorage.getItem('TD_RALLIES') || 'null');
            const rid = (typeof window.getRid_ === 'function' ? window.getRid_() : td?.global?.activeRallyId) || '';
            const title = td?.rallies?.[rid]?.meta?.title || 'Rally';
            const issue = td?.rallies?.[rid]?.meta?.issue || '';
            tdShowToast_(`Saved ${title} ${issue}`.trim());
          } catch(e) {
            tdShowToast_('Saved');
          }
        }
      });
    }
    if (loadBtn && !loadBtn.__tdBoundLoad){
      loadBtn.__tdBoundLoad = true;
      const ov = document.getElementById('loadConfirmOverlay');
      // Portal confirm overlay to <body> so it cannot be trapped by stacking/transform contexts
      if(ov && !ov.__tdPortaled){ try{ document.body.appendChild(ov); ov.__tdPortaled = true; }catch(_e){} }

      const btnC = document.getElementById('btnLoadConfirmCancel');
      const btnG = document.getElementById('btnLoadConfirmGo');
      const openLoadConfirm = ()=>{
        if(!ov){ if(window.tdWorkspaceLoadSnapshot) window.tdWorkspaceLoadSnapshot(); return; }
        ov.classList.add('open'); ov.setAttribute('aria-hidden','false');
        setTimeout(()=>{ try{ (btnC||btnG||ov).focus(); }catch(_e){} }, 0);
      };
      const closeLoadConfirm = ()=>{
        if(!ov) return;
        ov.classList.remove('open'); ov.setAttribute('aria-hidden','true');
        setTimeout(()=>{ try{ loadBtn.focus(); }catch(_e){} }, 0);
      };
      loadBtn.addEventListener('click', (e)=>{ e.preventDefault(); openLoadConfirm(); });

      if(btnC && !btnC.__tdBound){ btnC.__tdBound=true; btnC.addEventListener('click', (e)=>{ e.preventDefault(); closeLoadConfirm(); }); }
      if(btnG && !btnG.__tdBound){ btnG.__tdBound=true; btnG.addEventListener('click', async (e)=>{
        e.preventDefault(); closeLoadConfirm();
        if(window.tdWorkspaceLoadSnapshot) await window.tdWorkspaceLoadSnapshot();
        else alert('Load not available.');
      }); }
      if(ov && !ov.__tdBound){ ov.__tdBound=true; ov.addEventListener('click', (e)=>{ if(e.target===ov) closeLoadConfirm(); }); }
    }
    if (exportBtn && !exportBtn.__tdBoundExport){ exportBtn.__tdBoundExport = true; exportBtn.addEventListener('click', ()=>{ 
      try{
        const H = ['Rally No','Driver Name','Speed Group','Total Score','Clerk Penalty','Clerk Score','STC 1 ATA','STC 1 ETA','STC 1 Score','Marshal 1 ATA','Marshal 1 ETA','Marshal 1 Score','Open Control 1 ATA','Open Control 1 ETA','Open Control 1 Score','Start STC 1 Time'];

        const getCard = (type, n)=> (Array.isArray(model.cards)? model.cards.find(c=>String(c.type||'')===type && Number(c.n||0)===n) : null);
        const cSTC = getCard('STC',1);
        const cMar = getCard('Marshal',1);
        const cOpen = getCard('Open Control',1);
        const cStart = getCard('Start STC',1);

        const toInt = (v)=>{ const x = parseInt(String(v||'').trim(),10); return Number.isFinite(x)? x:0; };
        const rows = [];
        for(let r=0; r< (model.rows||0); r++){
          const rallyNo = r+1;
          const driver = (model.drivers && model.drivers[r]!=null)? String(model.drivers[r]) : '';
          const sg = (model.sgs && model.sgs[r]!=null)? String(model.sgs[r]) : '';
          const cocText = (model.coc && model.coc.cells && model.coc.cells[r]) ? (model.coc.cells[r].text||'') : '';
          const cocScore = (model.coc && model.coc.cells && model.coc.cells[r]) ? (model.coc.cells[r].score||'') : '';
          const stcAta = cSTC && cSTC.cells && cSTC.cells[r] ? (cSTC.cells[r].ata||'') : '';
          const stcEta = cSTC && cSTC.cells && cSTC.cells[r] ? (cSTC.cells[r].eta||'') : '';
          const stcSc  = cSTC && cSTC.cells && cSTC.cells[r] ? (cSTC.cells[r].score||'') : '';
          const marAta = cMar && cMar.cells && cMar.cells[r] ? (cMar.cells[r].ata||'') : '';
          const marEta = cMar && cMar.cells && cMar.cells[r] ? (cMar.cells[r].eta||'') : '';
          const marSc  = cMar && cMar.cells && cMar.cells[r] ? (cMar.cells[r].score||'') : '';
          const opAta  = cOpen && cOpen.cells && cOpen.cells[r] ? (cOpen.cells[r].ata||'') : '';
          const opEta  = cOpen && cOpen.cells && cOpen.cells[r] ? (cOpen.cells[r].eta||'') : '';
          const opSc   = cOpen && cOpen.cells && cOpen.cells[r] ? (cOpen.cells[r].score||'') : '';
          const startT = cStart && cStart.cells && cStart.cells[r] ? (cStart.cells[r].ata||'') : '';
          const total = toInt(cocScore)+toInt(stcSc)+toInt(marSc)+toInt(opSc);

          rows.push([rallyNo, driver, sg, total, cocText, cocScore, stcAta, stcEta, stcSc, marAta, marEta, marSc, opAta, opEta, opSc, startT]);
        }

        const safeTitle = (document.title||'Controls').replace(/\s+/g,'_').replace(/[^A-Za-z0-9_\-\.]/g,'');
        const fn = (safeTitle ? safeTitle : 'Controls') + '.xlsx';

        if(window.ExcelJS){
          const wb = new ExcelJS.Workbook();
          const ws = wb.addWorksheet('Controls');

          const col = (header, width, align)=> ({ header, width, style: { alignment: { horizontal: align || 'left' } } });
          ws.columns = [
            col(H[0], 10, 'center'), // Rally No
            col(H[1], 26, 'left'),   // Driver Name
            col(H[2], 12, 'center'), // Speed Group
            col(H[3], 12, 'center'), // Total Score
            col(H[4], 32, 'left'),   // Clerk Penalty
            col(H[5], 12, 'center'), // Clerk Score
            col(H[6], 12, 'center'), // STC ATA
            col(H[7], 12, 'center'), // STC ETA
            col(H[8], 10, 'center'), // STC Score
            col(H[9], 12, 'center'), // Marshal ATA
            col(H[10],12, 'center'), // Marshal ETA
            col(H[11],10, 'center'), // Marshal Score
            col(H[12],14, 'center'), // Open ATA
            col(H[13],14, 'center'), // Open ETA
            col(H[14],10, 'center'), // Open Score
            col(H[15],14, 'center')  // Start STC Time
          ];

          // Header row: bold + centered where appropriate
          const headerRow = ws.getRow(1);
          headerRow.font = { bold: true };
          headerRow.alignment = { vertical: 'middle' };
          headerRow.commit();

          // Data rows
          for(const row of rows){ ws.addRow(row); }

          // Download
          wb.xlsx.writeBuffer().then((buf)=>{
            const blob = new Blob([buf], {type:'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = fn;
            document.body.appendChild(a);
            a.click();
            setTimeout(()=>{ URL.revokeObjectURL(url); a.remove(); }, 0);
          }).catch((e)=>{ throw e; });

          return;
        }

        if(!window.XLSX){
          if(typeof window.toastSet === 'function'){ window.toastSet('XLSX export library not loaded (online CDN blocked).', 'warn', 4000); }
          else { alert('XLSX export library not loaded (online CDN blocked).'); }
          return;
        }
        const aoa = [H, ...rows.map(r=>r.map(v=>v==null?'':String(v)))];
        const ws = XLSX.utils.aoa_to_sheet(aoa);
        ws['!cols'] = [{wch:10},{wch:26},{wch:12},{wch:12},{wch:32},{wch:12},{wch:12},{wch:12},{wch:10},{wch:12},{wch:12},{wch:10},{wch:14},{wch:14},{wch:10},{wch:14}];
        const wb = XLSX.utils.book_new();
        XLSX.utils.book_append_sheet(wb, ws, 'Controls');
        XLSX.writeFile(wb, fn);
      }catch(e){
        console.error(e);
        if(typeof window.toastSet === 'function'){ window.toastSet('Export failed (see console).', 'warn', 4000); }
        else { alert('Export failed (see console).'); }
      }
    }); }
  });

})();

    const familyCounts = {};
    model.cards.forEach((card, cardIdx) => {
      const cardEl = document.createElement("div"); cardEl.className="card";
      const fam = getCardType(card).toLowerCase();
      if(fam === "start stc"){
        cardEl.classList.add("sstc-card"); // v2.1.161: Start STC is a 2-col card (A + START)
      }else if(fam === "stc" || fam === "marshal" || fam === "open control"){
        cardEl.classList.add("stcm-card"); // control cards use border dividers (no fixed-stop gradients)
      }
      cardEl.dataset.cardId = card.id;

      // Header
      const head = document.createElement("div"); head.className="card-head";
      const rawType = getCardType(card);
      const isStartStc = (rawType === "Start STC");
      const colSpan = isStartStc ? 1 : 3;

      // Column labels (row 2)
      if(isStartStc){
        const hc = document.createElement("div"); hc.className="col"; hc.textContent = "START TIME"; hc.style.gridRow="2"; hc.style.gridColumn="1"; head.appendChild(hc);
      }else{
        const hc1 = document.createElement("div"); hc1.className="col"; hc1.textContent = "ATA"; hc1.style.gridRow="2"; head.appendChild(hc1);
        const hc2 = document.createElement("div"); hc2.className="col"; hc2.textContent = "ETA"; hc2.style.gridRow="2"; head.appendChild(hc2);
        const hc3 = document.createElement("div"); hc3.className="col"; hc3.textContent="Score"; hc3.style.gridRow="2"; head.appendChild(hc3);
      }
// Title row (row 1)
      const title = document.createElement("div"); title.className="title"; title.style.gridRow="1"; title.style.gridColumn = "1 / span " + colSpan;

      const cb = document.createElement("input"); cb.type="checkbox"; cb.checked = !!card.included;
      cb.addEventListener("change", () => { card.included = cb.checked; if(!window.__TD_DAY_MIRROR_APPLYING){ try{ sstPersistDay(sstCurrentDay); }catch(_e){} } render(); });

      const label = document.createElement("span");
      const familyKey = isStartStc ? "STC" : rawType;
      familyCounts[familyKey] = (familyCounts[familyKey]||0) + 1;
      const display = card.label ? card.label : (rawType + " " + familyCounts[familyKey]);
      label.textContent = display;

      if(!isStartStc){ title.appendChild(cb); }
      title.appendChild(label);

      // v2.0.243 — day tag in header (skip Day 1) (boring nudge)
      if(typeof sstCurrentDay === "number" && sstCurrentDay > 1){
        title.style.position = "relative";
        const dayTag = document.createElement("span");
        dayTag.textContent = "Day " + sstCurrentDay;
        dayTag.style.position = "absolute";
        dayTag.style.right = "22px";
        dayTag.style.top = "6px";
        dayTag.style.fontSize = "12px";
        dayTag.style.fontWeight = "700";
        dayTag.style.color = "var(--muted)";
        dayTag.style.pointerEvents = "none";
        title.appendChild(dayTag);
      }
      head.appendChild(title);

      cardEl.appendChild(head);

const body = document.createElement("div"); body.className="card-body";

      // Row activation handlers (set global)
      body.addEventListener("focusin", (e)=>{
        const cell = e.target.closest(".cell");
        if(cell && body.contains(cell)){ setActiveRowGlobal(Number(cell.dataset.row)); }
      });
      body.addEventListener("mousedown", (e)=>{
        const cell = e.target.closest(".cell");
        if(cell && body.contains(cell)){ setActiveRowGlobal(Number(cell.dataset.row)); }
      });
      body.addEventListener("focusout", (e)=>{
        setTimeout(()=>{
          const stillInsideAny = Array.from(document.querySelectorAll('.card-body')).some(el => el.contains(document.activeElement));
          if(!stillInsideAny){ clearActiveRowGlobal(); }
        }, 0);
      });

      for(let r=0;r<model.rows;r++){
        if(isStartStc){
          // Start STC (layout-only): single centred START TIME input (no score column)
          const cellStartTime = document.createElement("div"); cellStartTime.className = "cell kind-eta sstc-starttime"; cellStartTime.dataset.row = String(r);
          const stIn = document.createElement("input");
          stIn.className = "time";
          if(card.cells[r].monoError){ stIn.classList.add("error"); }
          stIn.placeholder = "00:00:00";

          // v2.1.210 — Start STC default semantics:
          // treat 00:00:00 as a grey placeholder unless explicitly committed
          const __rawStart = (card.cells[r].eta || "");
          const __committed = !!card.cells[r].etaCommitted;
          stIn.value = (__rawStart && (__rawStart !== "00:00:00" || __committed)) ? __rawStart : "";

          stIn.setAttribute("aria-label", `Start time for Driver ${model.drivers[r]} on ${display}`);
          stIn.dataset.atFocusVal = stIn.dataset.atFocusVal || "00:00:00";

          const __commitStartTime = () => {
            let v = __sstNormalizeTimeOrBlank_(stIn.value);
            // default/blank collapses back to placeholder (not a committed value)
            if(!v || v === "00:00:00"){
              stIn.value = "";
              card.cells[r].eta = "";
              card.cells[r].etaCommitted = false;
            }else{
              stIn.value = v;
              card.cells[r].eta = v;
              card.cells[r].etaCommitted = true;
            }
            if(!window.__TD_DAY_MIRROR_APPLYING){ try{ sstPersistDay(sstCurrentDay); }catch(_e){} }
            // v2.1.225 — Start STC commit should refresh downstream control ETAs (Marshal/Open).
            try{ if(typeof __sstRefreshMarshalEtas_==='function'){ __sstRefreshMarshalEtas_(); } }catch(_e){}
            try{ if(typeof __sstRefreshOpenControlEtas_==='function'){ __sstRefreshOpenControlEtas_(); } }catch(_e){}
            render();
          };

          stIn.addEventListener("focus", ()=>{
            stIn.classList.remove("error");
            stIn.dataset.lastGood = (card.cells[r].eta && String(card.cells[r].eta).trim()) ? card.cells[r].eta : "";
            stIn.dataset.synthetic = "0";
            if (!stIn.value) {
              stIn.value = stIn.dataset.atFocusVal || "00:00:00";
              stIn.dataset.synthetic = "1";
            }
            try{ stIn.select(); }catch(_e){}
          });
          stIn.addEventListener("input", ()=>{
            if (stIn.dataset.synthetic === "1") stIn.dataset.synthetic = "0";
          });
          stIn.addEventListener("blur", ()=>{
            if (stIn.dataset.synthetic === "1") {
              stIn.value = stIn.dataset.lastGood || "";
              stIn.dataset.synthetic = "0";
              return;
            }
            __commitStartTime();
          });
          stIn.addEventListener("change", __commitStartTime);
          cellStartTime.appendChild(stIn);
          body.appendChild(cellStartTime);
          continue;
        }
// ATA cell
        const cellATA = document.createElement("div"); cellATA.className = "cell kind-ata"; cellATA.dataset.row = String(r);
        const ata = document.createElement("input");
        ata.className = "time"; if(card.cells[r].monoError){ ata.classList.add("error"); }
        ata.placeholder = "00:00:00";
        ata.value = card.cells[r].ata;
        ata.setAttribute("aria-label", `ATA for Driver ${model.drivers[r]} on ${display}`);
        ata.dataset.atFocusVal = ata.dataset.atFocusVal || "00:00:00";
        ata.dataset.lastGood = (card.cells[r].ata && String(card.cells[r].ata).trim()) ? card.cells[r].ata : "";
        ata.dataset.synthetic = "0";
        const __commitAta = () => {
          const raw = (ata.value == null ? "" : String(ata.value));
          const trimmed = raw.trim();
          const v = __sstNormalizeTimeOrBlank_(raw);
          if (trimmed && !v) {
            ata.classList.add("error");
            ata.value = ata.dataset.lastGood || "";
            ata.dataset.synthetic = "0";
            return;
          }
          ata.classList.remove("error");
          ata.value = v;
          ata.dataset.lastGood = v;
          ata.dataset.synthetic = "0";
          if (v !== card.cells[r].ata) {
            card.cells[r].ata = v;
            card.cells[r].score = computeScore(card.cells[r].ata, card.cells[r].eta, getCardType(card));
            validateAgainstPrevETA(r, cardIdx, v, ata);
            if(!window.__TD_DAY_MIRROR_APPLYING){ try{ sstPersistDay(sstCurrentDay); }catch(_e){} }
            // v2.1.225 — Start STC commit should refresh downstream control ETAs (Marshal/Open).
            try{ if(typeof __sstRefreshMarshalEtas_==='function'){ __sstRefreshMarshalEtas_(); } }catch(_e){}
            try{ if(typeof __sstRefreshOpenControlEtas_==='function'){ __sstRefreshOpenControlEtas_(); } }catch(_e){}
            render();
          }
        };
        ata.addEventListener("focus", ()=>{
          ata.classList.remove("error");
          ata.dataset.lastGood = (card.cells[r].ata && String(card.cells[r].ata).trim()) ? card.cells[r].ata : "";
          ata.dataset.synthetic = "0";
          if (!ata.value) {
            ata.value = ata.dataset.atFocusVal || "00:00:00";
            ata.dataset.synthetic = "1";
          }
          try{ ata.select(); }catch(_e){}
        });
        ata.addEventListener("input", ()=>{
          if (ata.dataset.synthetic === "1") ata.dataset.synthetic = "0";
        });
        ata.addEventListener("blur", ()=>{
          if (ata.dataset.synthetic === "1") {
            ata.value = ata.dataset.lastGood || "";
            ata.dataset.synthetic = "0";
            return;
          }
          __commitAta();
        });
        ata.addEventListener("change", __commitAta);
        cellATA.appendChild(ata);
        body.appendChild(cellATA);

        // ETA cell
        const cellETA = document.createElement("div"); cellETA.className = "cell kind-eta"; cellETA.dataset.row = String(r);
        const etaEl = document.createElement("div"); etaEl.className = "etaText"; etaEl.textContent = card.cells[r].eta;
        cellETA.appendChild(etaEl);
        body.appendChild(cellETA);

        // Score cell
        const cellScore = document.createElement("div"); cellScore.className = "cell kind-score"; cellScore.dataset.row = String(r);
        const scoreEl = document.createElement("div"); scoreEl.className = "scoreText" + (card.included? "" : " excluded"); scoreEl.textContent = card.cells[r].score || "0";
        cellScore.appendChild(scoreEl);
        body.appendChild(cellScore);
      }
cardEl.appendChild(body);
      __activeLayer.appendChild(cardEl);
    });

    applyActiveRow();
  }
  if (typeof applyAudit === 'function') { applyAudit(); }

  window.__sstControlsRender_ = render;

// --- Global clear for row highlight ---
  document.addEventListener('mousedown', (e) => {
  const inCard = e.target.closest('.card-body');
  if (!inCard) { clearActiveRowGlobal(); }
});
document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
      clearActiveRowGlobal();
    }
  });

  // v2.0.135 — Rally No pop-out drawer (scaffold)
  const drawerEl = document.getElementById('rallyDrawer');
  const rdBody = document.getElementById('rdBody');
  const rdClose = drawerEl ? drawerEl.querySelector('.rd-close') : null;
  const rdTitle = drawerEl ? drawerEl.querySelector('.rd-title') : null;
  let drawerRow = null; // active row index
  let highlightedCell = null;

  function shortTypeLabel(type, idxMap){
    // type: "STC" | "Marshal" | "Open Control" | "Start STC"
    let key, prefix;
    if (type === 'STC') { key = 'STC'; prefix = 'STC'; }
    else if (type === 'Marshal') { key = 'Mar'; prefix = 'Mar'; }
    else if (type === 'Open Control') { key = 'OC'; prefix = 'OC'; }
    else if (type === 'Start STC') { key = 'SSTC'; prefix = 'SSTC'; }  
    else { key = 'STC'; prefix = 'STC'; }
    idxMap[key] = (idxMap[key] || 0) + 1;
    return prefix + ' ' + idxMap[key];
  }

  function positionDrawer(){
    if (!drawerEl) return;
    // Compute left = console width + grid gap
    const panel = document.getElementById('panel');
    const consoleCard = panel && panel.querySelector('.card.console-card');
    let gap = 16;
    if (panel){
      const cs = getComputedStyle(panel);
      const g = parseInt(cs.columnGap || cs.gap || '16', 10);
      if (!isNaN(g)) gap = g;
    }
    let left = 438; // default 422 + 16
    if (consoleCard){
      left = consoleCard.offsetLeft + consoleCard.offsetWidth + gap;
    }
    drawerEl.style.left = left + 'px';

    // Dynamic vertical max-height so the drawer never runs off-screen
    const rect = drawerEl.getBoundingClientRect();
    const viewportHeight = window.innerHeight || document.documentElement.clientHeight || 800;
    const top = rect.top < 0 ? 0 : rect.top;
    const available = Math.max(200, viewportHeight - top - 16); // leave 16px gap at bottom
    drawerEl.style.maxHeight = available + 'px';
  }

  function clearRallyNoHighlight(){
    if (highlightedCell){
      highlightedCell.classList.remove('active');
      highlightedCell = null;
    }
  }

  function highlightRallyNoCell(rowIndex){
    clearRallyNoHighlight();
    const consoleCard = document.querySelector('.card.console-card');
    if (!consoleCard) return;
    const body = consoleCard.querySelector('.card-body');
    if (!body) return;
    // Find the col-3 cell for this row that contains the rally-no
    const cells = body.querySelectorAll('.cell[data-row=\"' + rowIndex + '\"]');
    let target = null;
    for (const c of cells){ if (c.querySelector('.rally-no')) { target = c; break; } }
    if (target){
      target.classList.add('active');
      highlightedCell = target;
    }
  }

  function buildDrawerContent(rowIndex){
    if (!drawerEl || !rdBody) return;
    rdBody.innerHTML = '';
    const idxMap = {};
    // Title: Car No - Surname (placeholder surname for now)
    const carNo = (rowIndex + 1);
    const surname = 'Driver ' + (model.drivers[rowIndex] || ('#' + carNo));
    if (rdTitle){
      rdTitle.textContent = 'Car ' + carNo + ' – ' + surname;
    }
    // Rows: iterate cards in order
    model.cards.forEach((card, cardIdx)=>{
      const type = getCardType(card);
      const label = shortTypeLabel(type, idxMap);
      const cell = card.cells[rowIndex] || { ata:'', eta:'', score:'0' };
      const row = document.createElement('div');
      row.className = 'rd-row';
      const c1 = document.createElement('div'); c1.className='rd-col'; c1.textContent = label;
      const c2 = document.createElement('div'); c2.className='rd-col';
const ataInput = document.createElement('input');
ataInput.type = 'text';
ataInput.className = 'rd-time';
ataInput.value = (cell.ata && String(cell.ata).trim()) ? cell.ata : '';
ataInput.placeholder = '00:00:00';
ataInput.setAttribute('inputmode','numeric');
ataInput.setAttribute('aria-label', 'ATA for ' + label);
    ataInput.dataset.cardIdx = String(cardIdx);
// Select-all on first click/focus to mimic card behavior (first digit clears)
ataInput.addEventListener('mousedown', (e)=>{ if (document.activeElement !== ataInput) { e.preventDefault(); ataInput.focus(); }});
ataInput.dataset.atFocusVal = ataInput.dataset.atFocusVal || "00:00:00";
ataInput.dataset.lastGood = (ataInput.value && String(ataInput.value).trim()) ? ataInput.value : "";
ataInput.dataset.synthetic = "0";
const __commitDrawerAta = () => {
  const raw = (ataInput.value == null ? "" : String(ataInput.value));
  const trimmed = raw.trim();
  const v = __sstNormalizeTimeOrBlank_(raw);
  if (trimmed && !v) {
    ataInput.classList.add('error');
    ataInput.value = ataInput.dataset.lastGood || "";
    ataInput.dataset.synthetic = "0";
    return;
  }
  ataInput.classList.remove('error');
  ataInput.value = v;
  ataInput.dataset.lastGood = v;
  ataInput.dataset.synthetic = "0";
  try {
    const idx = cardIdx;
    // Update model
    model.cards[idx].cells[rowIndex].ata = v;
    model.cards[idx].cells[rowIndex].score = computeScore(model.cards[idx].cells[rowIndex].ata, model.cards[idx].cells[rowIndex].eta, getCardType(model.cards[idx]));
    // Keep start-stc propagation (if applicable)
    const isStart = (String(getCardType(model.cards[idx])).toLowerCase() === 'start stc');
    if(isStart && v){ for(let k=idx+1; k<model.cards.length; k++){ model.cards[k].cells[rowIndex].eta = v; } }
    // Validate against previous ETA (monotonic check) and style this input
    validateAgainstPrevETA(rowIndex, idx, v, ataInput);
    // Re-render cards; MutationObserver will refresh drawer and we preserve scroll there
    render();
  } catch(err) {}
};
ataInput.addEventListener('focus', ()=>{
  ataInput.classList.remove('error');
  ataInput.dataset.lastGood = (ataInput.value && String(ataInput.value).trim()) ? ataInput.value : "";
  ataInput.dataset.synthetic = "0";
  if (!ataInput.value) {
    ataInput.value = ataInput.dataset.atFocusVal || "00:00:00";
    ataInput.dataset.synthetic = "1";
  }
  try{ ataInput.select(); }catch(_e){}
});
ataInput.addEventListener('input', ()=>{
  if (ataInput.dataset.synthetic === "1") ataInput.dataset.synthetic = "0";
});
ataInput.addEventListener('blur', ()=>{
  if (ataInput.dataset.synthetic === "1") {
    ataInput.value = ataInput.dataset.lastGood || "";
    ataInput.dataset.synthetic = "0";
    return;
  }
  __commitDrawerAta();
});
ataInput.addEventListener('change', __commitDrawerAta);
  // Enter: commit and auto-advance to next row's ATA
  ataInput.addEventListener('keydown', (e)=>{
    if (e.key !== 'Enter') return;
    e.preventDefault();
    const thisIdx = parseInt(ataInput.dataset.cardIdx || '-1', 10);
    // Blur to trigger change handler (normalize → validate → render)
    ataInput.blur();
    // After render & drawer refresh (debounced ~50ms), move focus to next ATA
    setTimeout(()=>{
      const nextSelector = 'input.rd-time[data-card-idx="' + (thisIdx + 1) + '"]';
      const next = rdBody && rdBody.querySelector(nextSelector);
      if (next) {
        next.focus();
        if (next.select) next.select();
        // keep it visible without jumping the whole drawer
        if (next.scrollIntoView) next.scrollIntoView({block:'nearest'});
      }
    }, 90);
  });

c2.appendChild(ataInput);
      const c3 = document.createElement('div'); c3.className='rd-col'; c3.textContent = cell.eta || '—';
      const c4 = document.createElement('div'); c4.className='rd-col'; c4.textContent = (cell.score == null ? '0' : String(cell.score));
      row.appendChild(c1); row.appendChild(c2); row.appendChild(c3); row.appendChild(c4);
      rdBody.appendChild(row);
    });
  }

  function openRallyDrawer(rowIndex){
    drawerRow = rowIndex;
    buildDrawerContent(rowIndex);
    if (drawerEl) drawerEl.setAttribute('aria-hidden','false');
    positionDrawer();
    highlightRallyNoCell(rowIndex);
  }

  function closeRallyDrawer(){
    drawerRow = null;
    if (drawerEl) drawerEl.setAttribute('aria-hidden','true');
    clearRallyNoHighlight();
  }

  // Wire close button
  if (rdClose){ rdClose.addEventListener('click', closeRallyDrawer); }

  // ESC closes
  document.addEventListener('keydown', (e)=>{ if (e.key === 'Escape') closeRallyDrawer(); });

  // Outside click close disabled by spec (v2.0.137)

  // Reposition on resize
  window.addEventListener('resize', positionDrawer);

  // Delegated click: open when Rally No cell is clicked
  let openingDrawer = false;
  document.addEventListener('click', (e)=>{
    const cell = e.target.closest('.cell');
    if (!cell) return;
    // Only if this is the Rally No cell (contains .rally-no)
    if (!cell.querySelector('.rally-no')) return;
    // prevent other delegates from acting on this click
    openingDrawer = true;
    e.stopPropagation();
    const row = parseInt(cell.dataset.row || '-1', 10);
    if (row >= 0){ openRallyDrawer(row); }
    requestAnimationFrame(()=>{ openingDrawer = false; });
  });

  // v2.0.141 — Keep Rally Drawer in sync when cards change
  (function(){
    if (!drawerEl || !rdBody) return;
    const panel = document.getElementById('panel');
    let drawerRefreshTimer = null;
    function refreshDrawerSoon(){
      if (!drawerEl || drawerEl.getAttribute('aria-hidden') === 'true') return;
      clearTimeout(drawerRefreshTimer);
      drawerRefreshTimer = setTimeout(()=>{
        const y = rdBody.scrollTop;
        buildDrawerContent(drawerRow || 0);
        positionDrawer();
        rdBody.scrollTop = y;
      }, 50);
    }
    // Observe structural changes to the cards panel
    if (panel){
      const mo = new MutationObserver(refreshDrawerSoon);
      mo.observe(panel, { childList: true, subtree: true });
    }
    // Also react to an explicit event if emitted elsewhere
    document.addEventListener('cards-changed', refreshDrawerSoon);
  })();

  // v2.0.159 — Save current page to a local JSON file (download)
  function serializeCurrentPage(){
    const auditToggle = document.getElementById('auditToggle');
    const auditValue = document.getElementById('auditValue');
    const data = {
      version: '2.0.182',
      day: (typeof model.day !== 'undefined' ? model.day : 1),
      drivers: (model.drivers || []).slice(),
      cards: (model.cards || []).map((card)=>{
        const type = getCardType(card);
        const cells = (card.cells || []).map(c => ({ ata: c.ata || '', eta: c.eta || '', score: (typeof c.score === 'number' ? c.score : parseInt(c.score||'0',10) || 0) }));
        return { type, title: card.title || null, enabled: (card.enabled !== false), included: (card.included !== false), cells };
      }),
      settings: {
        audit: {
          enabled: !!(auditToggle && auditToggle.checked),
          threshold: (auditValue ? (parseInt(auditValue.value,10)||0) : 0)
        }
      
      ,
      toolsEmails: (window.__toolsEmails_get && window.__toolsEmails_get()) || undefined
}
    };
    return data;
  }
  // v2.0.164 — Restore controls page from JSON
  function restoreControlsFromObject(obj){
    try {
      const page = (obj && obj.pages && obj.pages.controls) ? obj.pages.controls : obj;
      if (!page || !Array.isArray(page.cards) || !Array.isArray(page.drivers)) throw new Error('Invalid controls JSON');
      model.drivers = page.drivers.slice();
      model.cards = page.cards.map((c)=>{
        const type = c.type || getCardType(c);
        const title = c.title || null;
        const enabled = (c.enabled !== false);
        const cells = (c.cells || []).map(cell => ({
          ata: (cell.ata || '').trim(),
          eta: (cell.eta || '').trim(),
          score: (typeof cell.score === 'number') ? cell.score : (parseInt(cell.score||'0',10) || 0)
        }));
        return { type, title, enabled, included: (c.included !== false), cells };
      });
      if (page.settings && page.settings.audit){
        const auditToggle = document.getElementById('auditToggle');
        const auditValue = document.getElementById('auditValue');
        if (auditToggle) auditToggle.checked = !!page.settings.audit.enabled;
        if (auditValue && typeof page.settings.audit.threshold === 'number') auditValue.value = String(page.settings.audit.threshold);
      }
      if (typeof recomputeTotals === 'function') recomputeTotals();
      
      // Restore tools email list if present
      if (page.toolsEmails && window.__toolsEmails_set) {
        try { window.__toolsEmails_set(page.toolsEmails); } catch(e){}
      }

  // --- Post-load recompute to restore styles, totals, and score colors (v2.0.181) ---
  try {
    requestAnimationFrame(() => {
      if (typeof recomputeAllScores === 'function') recomputeAllScores();
      if (typeof updateTotals === 'function') updateTotals();
      if (typeof applyScoreStyles === 'function') applyScoreStyles();
    });
  } catch(e) {  }
  

render();
      applyAudit();
    } catch(err){
      console.error('Restore failed:', err);
      alert('Could not load this JSON. It may not be a Controls page file.');
    }
  }
    // v2.1.136 — TD_RALLIES glue helpers (self-contained in this file)
    // These were previously expected to exist globally; define them here to guarantee persistence works.
    if(typeof tdrGetRoot_ !== 'function'){
      window.tdrGetRoot_ = function(){
        try{ return JSON.parse(localStorage.getItem('TD_RALLIES') || '{}') || {}; }catch(_){ return {}; }
      };
    }
    if(typeof __sstPickActiveRid_ !== 'function'){
      window.__sstPickActiveRid_ = function(root){
        try{ return (root && root.global && root.global.activeRallyId) ? String(root.global.activeRallyId) : ''; }catch(_){ return ''; }
      };
    }
    if(typeof tdrGetActiveRid_ !== 'function'){
      window.tdrGetActiveRid_ = function(){
        try{
          const root = window.tdrGetRoot_();
          const rid = (typeof window.__sstPickActiveRid_ === 'function') ? window.__sstPickActiveRid_(root) : (root.global && root.global.activeRallyId);
          return rid ? String(rid) : '';
        }catch(_){ return ''; }
      };
    }
    if(typeof tdrSetRoot_ !== 'function'){
      window.tdrSetRoot_ = function(root, _reason){
        try{ if(__tdWriteIsFenced_()) return; if(localStorage.getItem('TD_RALLIES')===null) return; localStorage.setItem('TD_RALLIES', JSON.stringify(root||{})); }catch(_){}
      };
    }

    function sstGetActiveRid_(){
      try{ return (typeof tdrGetActiveRid_ === 'function' ? String(tdrGetActiveRid_()||'') : '') || ''; }catch(_){}
      return '';
    }
    function sstGetRoot_(){
      try{ return (typeof tdrGetRoot_ === 'function' ? tdrGetRoot_() : null) || {}; }catch(_){}
      return {};
    }
    function sstWriteRoot_(root, reason){
        // TIDY-ONLY: hard gate all TD_RALLIES writes until Controls is hydrated/settled.
  if (window.__sstWritesEnabled !== true) return false;
try{ if(localStorage.getItem('TD_RALLIES')===null) return; }catch(_){ return; }
      try{
        if(typeof tdrSetRoot_ === 'function'){ tdrSetRoot_(root||{}, reason||'controls_autosave'); return; }
      }catch(_){}
      try{ localStorage.setItem('TD_RALLIES', JSON.stringify(root||{})); }catch(_){}
    }
    
    // v2.1.167 — TD_RALLIES write safeguard: block writes during boot/hydrate, arm after settle.
    window.__sstWritesEnabled = false;
    try{
      setTimeout(()=>{ window.__sstHydrateReady = true; }, 400);
      setTimeout(()=>{ window.__sstWritesEnabled = true; }, 800);
    }catch(_e){}

    function sstEnsureControlsNode_(root, rid){
      // Canonical ControlsData subtree:
      //   r.controlsData.ui
      //   r.controlsData.days[day].cocData  (array)
      //   r.controlsData.days[day].ataData  (object)
      root = (root && typeof root === 'object') ? root : {};
      root.rallies = (root.rallies && typeof root.rallies === 'object') ? root.rallies : {};
      if(!root.rallies[rid] || typeof root.rallies[rid] !== 'object') root.rallies[rid] = {};
      const r = root.rallies[rid];

      r.controlsData = (r.controlsData && typeof r.controlsData === 'object') ? r.controlsData : {};
      r.controlsData.ui = (r.controlsData.ui && typeof r.controlsData.ui === 'object') ? r.controlsData.ui : {};
      r.controlsData.days = (r.controlsData.days && typeof r.controlsData.days === 'object') ? r.controlsData.days : {};

      return r.controlsData;
    }

    
    // v2.1.167 — ScoresControls storage (ATA only)
    function sstEnsureScoresControlsNode_(root, rid){
      // Canonical ControlsData subtree: r.controlsData.days[day].ataData (minimal)
      root = (root && typeof root === 'object') ? root : {};
      root.rallies = (root.rallies && typeof root.rallies === 'object') ? root.rallies : {};
      if(!root.rallies[rid] || typeof root.rallies[rid] !== 'object') root.rallies[rid] = {};
      const r = root.rallies[rid];

      r.controlsData = (r.controlsData && typeof r.controlsData === 'object') ? r.controlsData : {};
      r.controlsData.days = (r.controlsData.days && typeof r.controlsData.days === 'object') ? r.controlsData.days : {};

      return r.controlsData;
    }
    function sstReadScoresControlsDay_(dayKey){
      const rid = sstGetActiveRid_();
      if(!rid) return null;
      const root = sstGetRoot_();
      sstEnsureScoresControlsNode_(root, rid);
      const r = (root && root.rallies && root.rallies[rid]) ? root.rallies[rid] : null;
      const k = String(dayKey);
      if(!r) return null;

      r.controlsData = (r.controlsData && typeof r.controlsData === 'object') ? r.controlsData : {};
      r.controlsData.days = (r.controlsData.days && typeof r.controlsData.days === 'object') ? r.controlsData.days : {};
      r.controlsData.days[k] = (r.controlsData.days[k] && typeof r.controlsData.days[k] === 'object') ? r.controlsData.days[k] : {};
      const dayObj = r.controlsData.days[k];

      // Canonical: ataData minimal: {controls:{}}
      dayObj.ataData = (dayObj.ataData && typeof dayObj.ataData === 'object') ? dayObj.ataData : {};
      dayObj.ataData.controls = (dayObj.ataData.controls && typeof dayObj.ataData.controls === 'object') ? dayObj.ataData.controls : {};

      // DEV migration (no history): if legacy r.scoresControls.days[k].controls exists and ataData.controls is empty, copy once.
      try{
        const legacyControls = (r.scoresControls && r.scoresControls.days && r.scoresControls.days[k] && r.scoresControls.days[k].controls && typeof r.scoresControls.days[k].controls==='object') ? r.scoresControls.days[k].controls : null;
        const empty = (Object.keys(dayObj.ataData.controls).length === 0);
        if(legacyControls && empty){
          dayObj.ataData.controls = JSON.parse(JSON.stringify(legacyControls));
        }
      }catch(_e){}

      // Return a legacy-shaped view (NOT persisted): {controls:{...}}
      return { controls: dayObj.ataData.controls };
    }
    function sstWriteScoresControlsDay_(dayKey, patch){
      if(!window.__sstWritesEnabled) return false;
      const rid = sstGetActiveRid_();
      if(!rid) return false;
      const root = sstGetRoot_();
      sstEnsureScoresControlsNode_(root, rid);
      const r = (root && root.rallies && root.rallies[rid]) ? root.rallies[rid] : null;
      if(!r) return false;

      const k = String(dayKey);
      r.controlsData = (r.controlsData && typeof r.controlsData === 'object') ? r.controlsData : {};
      r.controlsData.days = (r.controlsData.days && typeof r.controlsData.days === 'object') ? r.controlsData.days : {};
      r.controlsData.days[k] = (r.controlsData.days[k] && typeof r.controlsData.days[k] === 'object') ? r.controlsData.days[k] : {};
      const dayObj = r.controlsData.days[k];

      dayObj.ataData = (dayObj.ataData && typeof dayObj.ataData === 'object') ? dayObj.ataData : {};
      dayObj.ataData.controls = (dayObj.ataData.controls && typeof dayObj.ataData.controls === 'object') ? dayObj.ataData.controls : {};

      if(patch && typeof patch === 'function'){
        patch(dayObj.ataData);
      }else if(patch && typeof patch === 'object'){
        // Expect legacy shape {controls:{...}} or direct controls map
        if(patch.controls && typeof patch.controls === 'object'){
          dayObj.ataData.controls = JSON.parse(JSON.stringify(patch.controls));
        }else{
          // treat as direct controls map
          dayObj.ataData.controls = JSON.parse(JSON.stringify(patch));
        }
      }

      return sstWriteRoot_(root, 'scores_controls_autosave');
    }

    function sstControlKeyFromCard_(card){
      const type = getCardType(card);
      let n = 1;
      try{
        const m = String(card && card.name || '').match(/(\d+)/);
        if(m) n = parseInt(m[1],10) || 1;
      }catch(_e){}
      return `${type}:${n}`;
    }
    function sstAtaByControlFromModel_(){
      const out = {};
      try{
        if(!model || !Array.isArray(model.cards)) return out;
        for(const card of model.cards){
          if(!card || !Array.isArray(card.cells)) continue;
          const type = getCardType(card);
          if(!(type === 'STC' || type === 'Marshal' || type === 'Open Control' || type === 'Start STC')) continue;
          const key = sstControlKeyFromCard_(card);

          // ATA (all control cards)
          const ataByRallyNo = {};
          for(let r=0; r<card.cells.length; r++){
            const v = (card.cells[r] && card.cells[r].ata != null) ? String(card.cells[r].ata).trim() : '';
            if(v !== '') ataByRallyNo[String(r+1)] = v;
          }

          // Start STC start-times (Controls-owned, not Schedule-owned)
          const startByRallyNo = {};
          if(type === 'Start STC'){
            for(let r=0; r<card.cells.length; r++){
              const cell = card.cells[r] || {};
              const v = (cell.eta != null) ? String(cell.eta).trim() : '';
              const committed = !!cell.etaCommitted;
              if(committed && v && __sstIsValidTime_(v) && v !== '00:00:00'){
                startByRallyNo[String(r+1)] = v;
              }
            }
          }

          out[key] = { ataByRallyNo };
          if(type === 'Start STC') out[key].startByRallyNo = startByRallyNo;
        }
      }catch(_e){}
      return out;
    }

    function sstReadControlsDay_(dayKey){
      const rid = sstGetActiveRid_();
      if(!rid) return null;
      const root = sstGetRoot_();
      sstEnsureControlsNode_(root, rid);
      const r = (root && root.rallies && root.rallies[rid]) ? root.rallies[rid] : null;
      const k = String(dayKey);
      if(!r) return null;

      r.controlsData = (r.controlsData && typeof r.controlsData === 'object') ? r.controlsData : {};
      r.controlsData.days = (r.controlsData.days && typeof r.controlsData.days === 'object') ? r.controlsData.days : {};
      r.controlsData.days[k] = (r.controlsData.days[k] && typeof r.controlsData.days[k] === 'object') ? r.controlsData.days[k] : {};
      const dayObj = r.controlsData.days[k];

      // Canonical: cocData is an array of {text, score}
      dayObj.cocData = Array.isArray(dayObj.cocData) ? dayObj.cocData : [];

      // Canonical: dayTotalByNo is an object map {rallyNo: totalScore}
      dayObj.dayTotalByNo = (dayObj.dayTotalByNo && typeof dayObj.dayTotalByNo === 'object') ? dayObj.dayTotalByNo : {};

      // Canonical: includedByCardId is an object map {cardId: boolean}
      dayObj.includedByCardId = (dayObj.includedByCardId && typeof dayObj.includedByCardId === 'object') ? dayObj.includedByCardId : {};

      // DEV migration (no history): if legacy r.controls.days[k].coc exists and cocData is empty, copy once.
      try{
        const legacyCoc = (r.controls && r.controls.days && r.controls.days[k] && Array.isArray(r.controls.days[k].coc)) ? r.controls.days[k].coc : null;
        if(legacyCoc && dayObj.cocData.length === 0){
          dayObj.cocData = JSON.parse(JSON.stringify(legacyCoc));
        }
      }catch(_e){}

      // Return a legacy-shaped view (NOT persisted): {coc: [...], ...other persisted fields}
      const view = dayObj;
      view.coc = dayObj.cocData;
      return view;
    }
    function sstWriteControlsDay_(dayKey, patch){
      if(!window.__sstWritesEnabled) return false;
      const rid = sstGetActiveRid_();
      if(!rid) return false;
      const root = sstGetRoot_();
      sstEnsureControlsNode_(root, rid);
      const r = (root && root.rallies && root.rallies[rid]) ? root.rallies[rid] : null;
      if(!r) return false;

      const k = String(dayKey);
      r.controlsData = (r.controlsData && typeof r.controlsData === 'object') ? r.controlsData : {};
      r.controlsData.ui = (r.controlsData.ui && typeof r.controlsData.ui === 'object') ? r.controlsData.ui : {};
      r.controlsData.days = (r.controlsData.days && typeof r.controlsData.days === 'object') ? r.controlsData.days : {};
      r.controlsData.days[k] = (r.controlsData.days[k] && typeof r.controlsData.days[k] === 'object') ? r.controlsData.days[k] : {};
      const dayObj = r.controlsData.days[k];

      // Canonical shapes
      dayObj.cocData = Array.isArray(dayObj.cocData) ? dayObj.cocData : [];

      // Canonical: dayTotalByNo is an object map {rallyNo: totalScore}
      dayObj.dayTotalByNo = (dayObj.dayTotalByNo && typeof dayObj.dayTotalByNo === 'object') ? dayObj.dayTotalByNo : {};

      // Canonical: includedByCardId is an object map {cardId: boolean}
      dayObj.includedByCardId = (dayObj.includedByCardId && typeof dayObj.includedByCardId === 'object') ? dayObj.includedByCardId : {};

      // Apply patch
      if(patch && typeof patch === 'function'){
        patch(dayObj);
      }else if(patch && typeof patch === 'object'){
        // Map legacy 'coc' -> canonical cocData
        if(Array.isArray(patch.coc)){
          dayObj.cocData = JSON.parse(JSON.stringify(patch.coc));
        }
        Object.keys(patch).forEach(key => {
          if(key === 'coc') return;
          dayObj[key] = patch[key];
        });
      }

      return sstWriteRoot_(root, 'controls_autosave');
    }

    
function sstReadAllMarshalWins(){
  // Store: TD_RALLIES.rallies[rid].controls.days[day].marshalWins
  try{
    const rid = sstGetActiveRid_();
    const out = { v: 1, days: {} };
    if(!rid) return out;
    const root = sstGetRoot_();
    const c = sstEnsureControlsNode_(root, rid);
    const days = (c && c.days && typeof c.days === 'object') ? c.days : {};
    Object.keys(days).forEach(dk => {
      const d = days[dk];
      if(d && typeof d === 'object' && d.marshalWins && typeof d.marshalWins === 'object'){
        out.days[String(dk)] = d.marshalWins;
      }
    });
    return out;
  }catch(e){
    return { v: 1, days: {} };
  }
}

    function sstWriteAllMarshalWins(obj){
      // New store: TD_RALLIES.rallies[rid].controls.days[day].marshalWins
      try{
        obj = (obj && typeof obj === 'object') ? obj : { v: 1, days: {} };
        const days = (obj.days && typeof obj.days === 'object') ? obj.days : {};
        Object.keys(days).forEach(dk => {
          const wins = days[dk];
          if(wins && typeof wins === 'object') sstWriteControlsDay_(dk, { marshalWins: wins });
        });
      }catch(e){}
      // v2.1.136 — legacy autosave keys removed; TD_RALLIES is source of truth
    }
    function sstSaveMarshalWinsForDay(dayNo, winsByNo){
      const all = sstReadAllMarshalWins();
      if(!all.days) all.days = {};
      all.days[String(dayNo)] = winsByNo || {};
      sstWriteAllMarshalWins(all);
    }
    function sstLoadMarshalWinsForDay(dayNo){
      const all = sstReadAllMarshalWins();
      return (all.days && all.days[String(dayNo)]) || {};
    }

    

    let sstCurrentDay = 1;
function sstGetActiveDayNo_(){
  try{
    const root = JSON.parse(localStorage.getItem('TD_RALLIES') || '{}') || {};
    const rid = (root && root.global && typeof root.global.activeRallyId === 'string') ? root.global.activeRallyId : '';
    const rally = (root && root.rallies && rid && root.rallies[rid]) ? root.rallies[rid] : null;
    const v = rally && rally.ui ? Number(rally.ui.activeDay) : NaN;
    if(v>=1 && v<=7) return v;
  }catch(_e){}
  try{
    const v2 = Number(localStorage.getItem('TD_ACTIVE_DAY'));
    if(v2>=1 && v2<=7) return v2;
  }catch(_e){}
  try{
    if(window.TD_ACTIVE_DAY){
      const v3 = Number(window.TD_ACTIVE_DAY);
      if(v3>=1 && v3<=7) return v3;
    }
  }catch(_e){}
  try{ if(window.sstCurrentDay) return parseInt(window.sstCurrentDay,10)||1; }catch(_e){}
  return 1;
}

let sstShowStartsStrip = false; // UI-only (no persistence)
function sstGetStartsMapForDay_(dayNo){
  try{
    const root = JSON.parse(localStorage.getItem('TD_RALLIES') || '{}') || {};
    const rid = (root && root.global && typeof root.global.activeRallyId === 'string') ? root.global.activeRallyId : '';
    const rally = (root && root.rallies && rid && root.rallies[rid]) ? root.rallies[rid] : null;
    const dayKey = String(dayNo || 1);
    const entries = (rally && rally.admin && rally.admin.controls && rally.admin.controls.days && rally.admin.controls.days[dayKey] && Array.isArray(rally.admin.controls.days[dayKey].entries))
      ? rally.admin.controls.days[dayKey].entries
      : [];
    const sm = {};
    for(const it of entries){
      if(!it) continue;
      const rn = Number(it.rallyNo ?? it.rallyNO ?? it.rally_no ?? it.no ?? it.rallyNumber ?? it.rally_number);
      if(!Number.isFinite(rn) || rn < 1) continue;
      const st = (it.startTime ?? it.start ?? it.start_time ?? it.startTimeStr ?? '');
      if(st != null && String(st).trim() !== '') sm[String(rn)] = String(st);
    }
    return sm;
  }catch(_e){
    return {};
  }
}
function sstBindStartsStripToggle_(){
  try{
    const btn = document.getElementById('btnStartsStrip');
    if(!btn) return;
    btn.setAttribute('aria-pressed', sstShowStartsStrip ? 'true' : 'false');
    btn.addEventListener('click', ()=>{
      sstShowStartsStrip = !sstShowStartsStrip;
      try{ btn.setAttribute('aria-pressed', sstShowStartsStrip ? 'true' : 'false'); }catch(_e){}
      try{ if(window.__sstControlsRender_) window.__sstControlsRender_(); }catch(_e){}
    });
    try{ window.addEventListener('resize', sstScheduleStartStripLeftFix_, {passive:true}); }catch(_e){}
  }catch(_e){}
}


    const sstDaySessionCache = Object.create(null);
    const sstBaseStc1Template = { id:'stc-1', type:'STC', name:'STC 1', included:true, cells: [] };

function sstCocFromModel(){
      try{
        if(!model || !model.coc || !Array.isArray(model.coc.cells)) return [];
        return model.coc.cells.map(c => ({ text: (c && c.text) ? String(c.text) : "", score: (c && c.score) ? String(c.score) : "" }));
      }catch(_e){ return []; }
    }
    function sstAtaByCardFromModel(){
      try{
        const out = {};
        if(!model || !Array.isArray(model.cards)) return out;
        model.cards.forEach(card => {
          if(!card || !card.id || !Array.isArray(card.cells)) return;
          out[String(card.id)] = card.cells.map(cell => (cell && cell.ata) ? String(cell.ata) : "");
        });
        return out;
      }catch(_e){ return {}; }
    }
    function sstApplyPersistedCocAta(dayNo){
      try{
        // CoC remains under controls.days[day]
        const d = sstReadControlsDay_(String(dayNo)) || {};
        // v2.2.315 — Restore include/exclude tick state (per card) from controlsData.days[day].includedByCardId
        try{
          const incMap = (d && d.includedByCardId && typeof d.includedByCardId === 'object') ? d.includedByCardId : null;
          if(incMap && model && Array.isArray(model.cards)){
            model.cards.forEach(card=>{
              if(!card || !card.id) return;
              if(incMap[String(card.id)] != null) card.included = !!incMap[String(card.id)];
            });
          }
        }catch(_e){}

        // v2.2.315 tidy — prune stale includedByCardId keys (cards removed)
        try{
          const incMap2 = (d && d.includedByCardId && typeof d.includedByCardId === 'object') ? d.includedByCardId : null;
          if(incMap2 && model && Array.isArray(model.cards)){
            const valid = {};
            model.cards.forEach(c=>{ if(c && c.id) valid[String(c.id)] = true; });
            let changed = false;
            const pruned = {};
            Object.keys(incMap2).forEach(k=>{ if(valid[k]) pruned[k] = !!incMap2[k]; else changed = true; });
            if(changed){
              try{ sstWriteControlsDay_(String(dayNo), { includedByCardId: pruned }); }catch(_e){}
            }
          }
        }catch(_e){}

        if(d && Array.isArray(d.coc) && model && model.coc && Array.isArray(model.coc.cells)){
          for(let r=0; r<model.coc.cells.length; r++){
            const src = d.coc[r];
            if(src && typeof src === 'object'){
              model.coc.cells[r].text  = (src.text  != null) ? String(src.text)  : "";
              model.coc.cells[r].score = (src.score != null) ? String(src.score) : "";
            }
          }
        }

        // ATA is persisted under scoresControls.days[day].controls[controlKey].ataByRallyNo
        const sc = sstReadScoresControlsDay_(String(dayNo)) || {};
        const controls = (sc && sc.controls && typeof sc.controls === 'object') ? sc.controls : {};
        if(model && Array.isArray(model.cards)){
          model.cards.forEach(card => {
            if(!card || !Array.isArray(card.cells)) return;
            const type = getCardType(card);
            if(!(type === 'STC' || type === 'Marshal' || type === 'Open Control' || type === 'Start STC')) return;

            const ckey = sstControlKeyFromCard_(card);
            const node = controls[ckey];
            const ataMap = (node && node.ataByRallyNo && typeof node.ataByRallyNo === 'object') ? node.ataByRallyNo : null;
            const startMap = (type === 'Start STC' && node && node.startByRallyNo && typeof node.startByRallyNo === 'object') ? node.startByRallyNo : null;
            if(!ataMap && !startMap) return;

            // ATA
            if(ataMap){
              for(let r=0; r<card.cells.length; r++){
                const v = (ataMap[String(r+1)] != null) ? String(ataMap[String(r+1)]) : "";
                if(v !== ""){
                  card.cells[r].ata = v;
                  try{ card.cells[r].score = computeScore(card.cells[r].ata, card.cells[r].eta, type); }catch(_){}
                }
              }
            }

            // Start STC start-times (Controls-owned)
            if(startMap){
              for(let r=0; r<card.cells.length; r++){
                const v = (startMap[String(r+1)] != null) ? String(startMap[String(r+1)]) : "";
                if(v !== ""){
                  card.cells[r].eta = v;
                  card.cells[r].etaCommitted = true;
                }
              }
            }
            });
        }
      }catch(_e){}
    }


    function sstPersistDay(dayNo){
      // TIDY-ONLY: dedupe guard — avoid duplicate full-root writes when blur+change both fire.
      let root=null, rid=null, rally=null, dk=null;
      try{
        root = JSON.parse(localStorage.getItem('TD_RALLIES') || '{}');
        rid = (typeof __sstPickActiveRid_ === 'function') ? __sstPickActiveRid_(root) : (root.global && root.global.activeRallyId);
        if(rid){
          rally = (root && root[rid]) ? root[rid] : ((root && root.rallies && root.rallies[rid]) ? root.rallies[rid] : null);
        }
        dk = String(dayNo);
      }catch(_e){}

      try{
        sstDaySessionCache[String(dayNo)] = JSON.parse(JSON.stringify(model.cards || []));
      }catch(e){}

      // CoC persistence stays in controls.days[day]
      try{
        const nextCoc = sstCocFromModel();
        let prevCoc = null;
        try{
          prevCoc = rally && rally.controls && rally.controls.days && rally.controls.days[dk] ? (rally.controls.days[dk].coc ?? null) : null;
        }catch(_e){}
        if(JSON.stringify(prevCoc) !== JSON.stringify(nextCoc)){
          sstWriteControlsDay_(dk, { coc: nextCoc });
        }
      }catch(_e){}

      // ATA persistence (all control cards) goes to scoresControls.days[day].controls[controlKey].ataByRallyNo
      try{
        const nextControls = sstAtaByControlFromModel_();
        let prevControls = null;
        try{
          prevControls = rally && rally.scoresControls && rally.scoresControls.days && rally.scoresControls.days[dk] ? (rally.scoresControls.days[dk].controls ?? null) : null;
        }catch(_e){}
        if(JSON.stringify(prevControls) !== JSON.stringify(nextControls)){
          const patch = { controls: nextControls };
          sstWriteScoresControlsDay_(dk, patch);
        }
      }catch(_e){}

      // v2.2.315 — Persist derived day totals (per RallyNo) into controlsData.days[day].dayTotalByNo
      try{
        if(typeof recomputeTotals === 'function'){
          const arr = recomputeTotals();
          const nextMap = {};
          const n = Array.isArray(arr) ? arr.length : 0;
          for(let r=0;r<n;r++){
            const noRaw = (typeof carAt === 'function') ? String(carAt(r)||'').trim() : '';
            const no = noRaw ? noRaw : String(r+1);
            const v = parseInt((arr && arr[r] != null) ? arr[r] : 0, 10);
            nextMap[no] = Number.isFinite(v) ? v : 0;
          }

          let prevMap = null;
          try{
            prevMap = (rally && rally.controlsData && rally.controlsData.days && rally.controlsData.days[dk] && rally.controlsData.days[dk].dayTotalByNo) ? rally.controlsData.days[dk].dayTotalByNo : null;
          }catch(_e){}

          if(JSON.stringify(prevMap) !== JSON.stringify(nextMap)){
            sstWriteControlsDay_(dk, { dayTotalByNo: nextMap });
          }
        }
      }catch(_e){}

      // v2.2.315 — Persist include/exclude tick per card into controlsData.days[day].includedByCardId
      try{
        const nextInc = {};
        if(model && Array.isArray(model.cards)){
          model.cards.forEach(card=>{
            if(!card || !card.id) return;
            nextInc[String(card.id)] = (card.included !== false);
          });
        }
        let prevInc = null;
        try{
          prevInc = (rally && rally.controlsData && rally.controlsData.days && rally.controlsData.days[dk] && rally.controlsData.days[dk].includedByCardId)
            ? rally.controlsData.days[dk].includedByCardId : null;
        }catch(_e){}
        if(JSON.stringify(prevInc) !== JSON.stringify(nextInc)){
          sstWriteControlsDay_(dk, { includedByCardId: nextInc });
        }
      }catch(_e){}

}


function sstBuildCardsFromControls(controlsArr){
      const arr = Array.isArray(controlsArr) ? controlsArr : [];
      // v2.1.210 — Membership-only rebuild: preserve existing card cell data where possible.
      const _existing = Array.isArray(model.cards) ? model.cards : [];
      const cfgMap = {
        "STC": { prefix:"stc", name:(n)=>"STC " + n },
        "Marshal": { prefix:"marshal", name:(n)=>"Marshal " + n },
        "Open Control": { prefix:"open", name:(n)=>"Open Control " + n },
        "Start STC": { prefix:"start", name:(n)=>"Start STC " + n }
      };

      const cards = [];
      arr.forEach((c)=>{
        if(!c || !c.type) return;
        const typeRaw = String(c.type).trim();
        // normalise type
        let type = typeRaw;
        if(/^open/i.test(typeRaw)) type = "Open Control";
        if(/^start/i.test(typeRaw) && /stc/i.test(typeRaw)) type = "Start STC";
        if(type !== "STC" && type !== "Marshal" && type !== "Open Control" && type !== "Start STC") return;

        const cfg = cfgMap[type];
        const n = (c.n != null) ? (parseInt(c.n,10)||0) : 0;
        // fallback numbering: count existing of same type
        const nn = n > 0 ? n : (cards.filter(x=>x && x.type===type).length + 1);

        const prev = cards[cards.length - 1];
        const id = cfg.prefix + "-" + nn;
        const name = cfg.name(nn);

        const card = {
          id,
          type,
          name,
          included: true,
          n: nn
        };

        if(c.label != null && String(c.label).trim()){
          card.label = String(c.label);
        }
        if(c.sgTimes && typeof c.sgTimes === "object"){
          try{ card.sgTimes = JSON.parse(JSON.stringify(c.sgTimes)); }catch(_e){}
        }

        // Preserve existing cells (Schedule drives membership only; values are Controls-owned).
        const match = _existing.find(x => x && x.type === type && (x.n === nn || x.name === name));
        if(match && Array.isArray(match.cells) && match.cells.length){
          card.included = (match.included !== false);
          card.cells = match.cells.map(c => Object.assign({}, c));
        } else {
          card.cells = Array.from({ length: model.rows }, (_, r) => ({
            ata: "",
            eta: "",
            score: "0"
          }));
        }

        cards.push(card);
      });

      return cards;
    }

    function sstSwitchDay(dayNo){
const next = Math.max(1, Math.min(7, parseInt(dayNo, 10) || 1));
if(next === sstCurrentDay) return;

// v2.2.321 — mirror fence: suppress TD_RALLIES writes during day switch / mirror apply
window.__TD_CTRL_DAY_SWITCHING = true;
window.__TD_WRITE_FENCE_UNTIL = Date.now() + 1600;
try{ clearTimeout(window.__TD_CTRL_DAY_SWITCH_TMR); }catch(_e){}
window.__TD_CTRL_DAY_SWITCH_TMR = setTimeout(()=>{ try{ window.__TD_CTRL_DAY_SWITCHING = false; }catch(_e){} }, 1600);

// Persist current day values (CoC + ATA) into TD_RALLIES.rallies[rid].controls.days[day]
if(!window.__TD_DAY_MIRROR_APPLYING){ try{ sstPersistDay(sstCurrentDay); }catch(_e){} }

sstCurrentDay = next;

// Rebuild membership from Schedule controls for the selected day, then re-apply persisted CoC/ATA and refresh ETAs.
try{
  const root = sstGetRoot_();
  const rid = sstGetActiveRid_();
  const scheduleDays = root && root.rallies && root.rallies[rid] && root.rallies[rid].schedule && root.rallies[rid].schedule.days
    ? root.rallies[rid].schedule.days : null;

  if(window.__sstControlsSyncCardsFromSchedule_ && scheduleDays){
    window.__sstControlsSyncCardsFromSchedule_(scheduleDays, String(next));
  }

  // Apply persisted CoC/ATA for this day after membership rebuild
  try{ sstApplyPersistedCocAta(next); }catch(_e){}

  // Render first (cards may have been added/removed), then paint dependent ETAs.
  try{ render(); }catch(_e){}
  try{ if(window.__sstRefreshStcEtas_) window.__sstRefreshStcEtas_(); }catch(_e){}
  try{ if(window.__sstRefreshMarshalEtas_) window.__sstRefreshMarshalEtas_(); }catch(_e){}
}catch(_e){}
}
  
    // Listen for day-pill change events (single source of truth = TD_ACTIVE_DAY / day pill)
    // v2.1.273 tidy: Controls must react to the pill module's canonical event.
    document.addEventListener('daypill:changed', (ev) => {
      try{
        const dayNo = ev && ev.detail ? Number(ev.detail.dayNo) : NaN;
        if(dayNo>=1 && dayNo<=7) sstSwitchDay(dayNo);
      }catch(_e){}
    });

function sstInitDayMembership(){
  // v2.1.265 — Day selection tidy:
  // - TD_ACTIVE_DAY is the shared driver.
  // - On boot, if *today* matches a rally day date (Admin days), set TD_ACTIVE_DAY to that day.
  // - Otherwise, read the current active day (TD_RALLIES.ui.activeDay → TD_ACTIVE_DAY → 1).
  // - Never re-run reconcile in response to TD_ACTIVE_DAY storage events (they are mirror-only).

  function _ymdFromDate_(d){
    try{
      const y = d.getFullYear();
      const m = String(d.getMonth()+1).padStart(2,'0');
      const da = String(d.getDate()).padStart(2,'0');
      return y + '-' + m + '-' + da;
    }catch(_e){ return ''; }
  }

  function _ymdFromDateStr_(dateStr){
    if(!dateStr || typeof dateStr !== 'string') return '';
    const s = dateStr.trim();

    // Canonical: ISO yyyy-mm-dd (or full ISO datetime)
    let m = s.match(/^(\d{4})-(\d{2})-(\d{2})/);
    if(m){
      return m[1] + '-' + m[2] + '-' + m[3];
    }

    // Accept dd-mm-yyyy or dd/mm/yyyy (legacy/user input)
    m = s.match(/^(\d{1,2})[-\/](\d{1,2})[-\/](\d{2,4})$/);
    if(m){
      const dd = String(parseInt(m[1],10)).padStart(2,'0');
      const mm = String(parseInt(m[2],10)).padStart(2,'0');
      let yy = String(parseInt(m[3],10));
      if(yy.length === 2) yy = '20' + yy;
      return yy + '-' + mm + '-' + dd;
    }

    return '';
  }

  function _readActiveDayNo_(){
    // Single driver: prefer TD_ACTIVE_DAY first, then fall back to TD_RALLIES.ui.activeDay, else 1.
    let dayNo = null;

    // 1) Shared driver between tabs/pages
    try{
      const tel = Number(localStorage.getItem('TD_ACTIVE_DAY'));
      if(Number.isFinite(tel) && tel >= 1) dayNo = tel;
    }catch(_e){}

    // 2) Legacy / fallback
    if(!(dayNo >= 1)){
      try{
        const root = JSON.parse(localStorage.getItem('TD_RALLIES')||'{}');
        const rid = (root && root.global && typeof root.global.activeRallyId === 'string') ? root.global.activeRallyId : '';
        const uiDay = (rid && root && root.rallies && root.rallies[rid] && root.rallies[rid].ui) ? root.rallies[rid].ui.activeDay : null;
        const nUi = Number(uiDay);
        if(Number.isFinite(nUi) && nUi >= 1) dayNo = nUi;
      }catch(_e){}
    }

    dayNo = Math.max(1, Math.min(7, Number(dayNo)||1));
    return dayNo;
  }

  function _writeActiveDayNo_(dayNo, reason){
    dayNo = Math.max(1, Math.min(7, Number(dayNo)||1));
    try{ window.__sstBootDayWrite_ = true; }catch(_e){}
    try{ localStorage.setItem('TD_ACTIVE_DAY', String(dayNo)); }catch(_e){}
    try{
      const raw = localStorage.getItem('TD_RALLIES');
      const root = raw ? JSON.parse(raw) : {rallies:{}, global:{}};
      const rid = (root && root.global && typeof root.global.activeRallyId === 'string') ? root.global.activeRallyId : '';
      if(rid){
        root.rallies = root.rallies || {};
        root.rallies[rid] = root.rallies[rid] || {};
        root.rallies[rid].ui = root.rallies[rid].ui || {};
        // v2.2.315: Controls day switch is read-only w.r.t TD_RALLIES (no ui.activeDay persistence here).
      }
    }catch(_e){}
    try{ window.__sstBootDayWrite_ = false; }catch(_e){}
    try{ window.__sstBootDayReason_ = String(reason||''); }catch(_e){}
  }

  function _clampToAvailableDays_(dayNo, days){
    dayNo = Math.max(1, Math.min(7, Number(dayNo)||1));
    const nums = Array.isArray(days) ? days.map(d=>Number(d.dayNo)).filter(n=>Number.isFinite(n) && n>=1) : [];
    if(!nums.length) return dayNo;
    if(nums.includes(dayNo)) return dayNo;
    return nums.sort((a,b)=>a-b)[0] || 1;
  }

  // Boot reconcile: if today matches a rally day date, set TD_ACTIVE_DAY to that day.
  function _getAvailableDaysFromAdmin_(){
    try{
      const raw = localStorage.getItem('TD_RALLIES');
      if(!raw) return [];
      const root = JSON.parse(raw) || {};
      const rid = (root && root.global && typeof root.global.activeRallyId === 'string') ? root.global.activeRallyId : '';
      const rally = (rid && root && root.rallies) ? root.rallies[rid] : null;
      const daysObj = rally && rally.admin ? rally.admin.days : null;
      if(!daysObj || typeof daysObj !== 'object') return [];
      const out = [];
      for(const k of Object.keys(daysObj)){
        const d = daysObj[k] || {};
        const n = Number(k);
        if(Number.isFinite(n) && n >= 1){
          out.push({ dayNo: n, date: d.date, start: d.start, incMin: d.incMin });
        }
      }
      out.sort((a,b)=>a.dayNo-b.dayNo);
      return out;
    }catch(_e){ return []; }
  }

  let available = _getAvailableDaysFromAdmin_();
  const todayYmd = _ymdFromDate_(new Date());
  let matchDay = 0;

  try{
    if(Array.isArray(available) && available.length && todayYmd){
      for(const rec of available){
        const ymd = _ymdFromDateStr_(rec && rec.date);
        if(ymd && ymd === todayYmd){ matchDay = Number(rec.dayNo)||0; break; }
      }
    }
  }catch(_e){ matchDay = 0; }

  // Our rule: only on boot, if today is a rally day, override stored selection (FIRST-RUN ONLY).
  // If TD_ACTIVE_DAY already exists, do not overwrite it on page open.
  let chosen = 1;
  let _existingActiveDay = null;
  try{ _existingActiveDay = localStorage.getItem('TD_ACTIVE_DAY'); }catch(_e){ _existingActiveDay = null; }
  if(matchDay >= 1 && (_existingActiveDay === null || _existingActiveDay === '')){
    try{ localStorage.setItem('TD_ACTIVE_DAY', String(matchDay)); }catch(_e){}
    chosen = matchDay;
  }else{
    chosen = _readActiveDayNo_();
  }

  chosen = _clampToAvailableDays_(chosen, available);
  sstCurrentDay = chosen;

  // Align the day pill dataset contract (dayNo + legacy dayIndex) if pill exists.
  try{
    const btn = document.getElementById('dayPillBtn');
    if(btn && btn.dataset){
      btn.dataset.dayNo = String(chosen);
      btn.dataset.dayIndex = String(chosen-1);
    }
  }catch(_e){}
}
  
    sstInitDayMembership();
    try{ sstBindStartsStripToggle_(); }catch(_e){}

    // v2.1.146 — Sync control cards membership from Schedule (TD_RALLIES) for the active rally.
    // Build model.cards from schedule.days[dayKey].controls (show/hide via rebuild) then render.
    window.__sstControlsSyncCardsFromSchedule_ = function(scheduleDays, preferDayKey){
      try{
        if(!scheduleDays || typeof scheduleDays !== 'object') return false;

        // Choose day: prefer explicit key if valid, else first numeric day key.
        const keys = Object.keys(scheduleDays).filter(k => scheduleDays[k] && typeof scheduleDays[k] === 'object');
        if(!keys.length) return false;

        let dayKey = (preferDayKey != null) ? String(preferDayKey) : '';
        if(!dayKey || !scheduleDays[dayKey]){
          dayKey = keys.sort((a,b)=> (parseInt(a,10)||0) - (parseInt(b,10)||0))[0];
        }

        const dayObj = scheduleDays[dayKey] || {};
        const controlsArr = Array.isArray(dayObj.controls) ? dayObj.controls : [];
        model.cards = sstBuildCardsFromControls(controlsArr);

try{ sstApplyPersistedCocAta(sstCurrentDay); }catch(_e){}

        try{ render(); }catch(_e){}
        return true;
      }catch(_e){
        return false;
      }
    };

  // v2.1.30 — Expose minimal live getters for Upload wiring (no Admin wiring yet)
  try{
    window.__sstLive = window.__sstLive || {};
    window.__sstLive.getCards = () => (model.cards || []);
    window.__sstLive.getDrivers = () => (model.drivers || []);
    window.__sstLive.getRows = () => (model.rows || 0);
  }catch(e){}

  // v2.1.136 — apply persisted CoC/ATA on boot (deferred until TD_RALLIES glue is attached)
  try{
    setTimeout(() => {
      try{ sstApplyPersistedCocAta(sstCurrentDay); }catch(_e){}
        try{ render(); }catch(_e){}
    }, 0);
  }catch(_e){}

  render();
})();
  function applyAudit(){
    const auditToggle = document.getElementById('auditToggle');
    const auditValue = document.getElementById('auditValue');
    const enabled = auditToggle && auditToggle.checked;
    const threshold = auditValue ? (parseInt(auditValue.value, 10) || 0) : 0;
    document.querySelectorAll('.scoreText').forEach(el=>{
      const val = parseInt(el.textContent,10);
      const cell = el.closest('.cell');
      if(!cell) return;
      const magnitude = Math.abs(val);
      if(enabled && !isNaN(val) && magnitude >= threshold){
        // Apply at cell level (fills the whole cell)
        cell.classList.add('audit-fail');
        // Ensure inner text has no background
        el.classList.remove('audit-fail');
      } else {
        cell.classList.remove('audit-fail');
        el.classList.remove('audit-fail');
      }
    });
  }
  document.addEventListener('change', (e)=>{
    if(e.target && (e.target.id === 'auditToggle' || e.target.id === 'auditValue')) applyAudit();
  });
  document.addEventListener('input', (e)=>{
    if(e.target && e.target.id === 'auditValue') applyAudit();
  });

// v2.0.99 — Tools fly-out wiring
(function(){
  const toolsBtn = document.getElementById('mainToolsBtn');
  const wrap = document.getElementById('toolsPanelWrap');
  const panel = document.getElementById('toolsPanel');
  const closeBtn = document.getElementById('toolsClose');
  let lastFocus = null;

  function openTools(){
    lastFocus = document.activeElement;
    wrap.setAttribute('aria-hidden','false');
    panel.setAttribute('aria-modal','true');
    closeBtn.focus();
  }
  function closeTools(){
    wrap.setAttribute('aria-hidden','true');
    panel.removeAttribute('aria-modal');
    if(lastFocus && typeof lastFocus.focus === 'function') lastFocus.focus();
  }

  if (toolsBtn) toolsBtn.addEventListener('click', openTools);
  if (closeBtn) closeBtn.addEventListener('click', closeTools);
  document.addEventListener('keydown', (e)=>{
    if(e.key === 'Escape' && wrap.getAttribute('aria-hidden') === 'false'){ closeTools(); }
  });
})();

// v2.0.119 — Horizontal proxy <-> grid sync
(function(){
  const proxy = document.querySelector('.hproxy');
  const inner = proxy && proxy.querySelector('.hproxy-inner');
  const gridScroll = document.querySelector('.grid-scroll');
  if (!proxy || !inner || !gridScroll) return;

  let syncing = false;
  const debounce = (fn, ms=50) => {
    let t; return (...args)=>{ clearTimeout(t); t=setTimeout(()=>fn(...args), ms); };
  };

  function sizeProxy(){
    // Match the proxy's inner strip to the grid's scrollable width
    try {
      const targetWidth = gridScroll.scrollWidth;
      if (targetWidth && inner.style.width !== targetWidth + 'px') {
        inner.style.width = targetWidth + 'px';
      }
    } catch(e){  }
  }

  function syncFromProxy(){
    if (syncing) return;
    syncing = true;
    gridScroll.scrollLeft = proxy.scrollLeft;
    syncing = false;
  }
  function syncFromGrid(){
    if (syncing) return;
    syncing = true;
    proxy.scrollLeft = gridScroll.scrollLeft;
    syncing = false;
  }

  // Listeners
  proxy.addEventListener('scroll', syncFromProxy, { passive: true });
  gridScroll.addEventListener('scroll', syncFromGrid,   { passive: true });
  window.addEventListener('resize', debounce(sizeProxy, 80));

  // Observe DOM changes in the grid to keep width in sync after render()
  const panel = document.getElementById('panel');
  if (panel && 'MutationObserver' in window) {
    const obs = new MutationObserver(debounce(sizeProxy, 50));
    obs.observe(panel, { childList: true, subtree: true });
  }

  // v2.0.131 — Visible proxy thumb (always-on dark strip)
  const thumb = proxy.querySelector('.hproxy-thumb');
  function sizeThumb(){
    if (!thumb) return;
    const content = gridScroll.scrollWidth;
    const viewport = gridScroll.clientWidth;
    const track = proxy.clientWidth;
    if (!content || !viewport || !track) return;
    const ratio = Math.min(1, viewport / content);
    const minThumb = 40; // px minimum for usability
    const width = Math.max(minThumb, Math.floor(track * ratio));
    thumb.style.width = width + 'px';
  }
  function positionThumb(){
    if (!thumb) return;
    const content = gridScroll.scrollWidth;
    const viewport = gridScroll.clientWidth;
    const track = proxy.clientWidth;
    const thumbW = thumb.offsetWidth || 0;
    const maxScroll = Math.max(1, content - viewport);
    const travel = Math.max(0, track - thumbW);
    const left = Math.round((gridScroll.scrollLeft / maxScroll) * travel);
    thumb.style.left = left + 'px';
  }
  const debouncedSizeThumb = debounce(sizeThumb, 50);
  // Update thumb on size and scroll
  window.addEventListener('resize', debouncedSizeThumb);
  gridScroll.addEventListener('scroll', positionThumb, { passive: true });
  proxy.addEventListener('scroll', positionThumb, { passive: true });

  // Dragging
  let dragging = false;
  let dragStartX = 0;
  let dragStartLeft = 0;
  function dragStart(e){
    dragging = true;
    proxy.classList.add('dragging');
    thumb.classList.add('dragging');
    dragStartX = e.clientX || (e.touches && e.touches[0].clientX) || 0;
    dragStartLeft = parseInt(window.getComputedStyle(thumb).left, 10) || 0;
    e.preventDefault();
  }
  function dragMove(e){
    if (!dragging) return;
    const x = e.clientX || (e.touches && e.touches[0].clientX) || 0;
    const dx = x - dragStartX;
    const track = proxy.clientWidth;
    const thumbW = thumb.offsetWidth || 0;
    const travel = Math.max(0, track - thumbW);
    let newLeft = Math.min(travel, Math.max(0, dragStartLeft + dx));
    thumb.style.left = newLeft + 'px';
    // Map thumb position to grid scroll
    const content = gridScroll.scrollWidth;
    const viewport = gridScroll.clientWidth;
    const maxScroll = Math.max(1, content - viewport);
    if (travel > 0) {
      gridScroll.scrollLeft = Math.round((newLeft / travel) * maxScroll);
    }

  }
  function dragEnd(){
    if (!dragging) return;
    dragging = false;
    proxy.classList.remove('dragging');
    thumb.classList.remove('dragging');
  }
  if (thumb){
    thumb.addEventListener('mousedown', dragStart);
    window.addEventListener('mousemove', dragMove, { passive: false });
    window.addEventListener('mouseup', dragEnd);
    // Touch support
    thumb.addEventListener('touchstart', dragStart, { passive: false });
    window.addEventListener('touchmove', dragMove, { passive: false });
    window.addEventListener('touchend', dragEnd);
  }

  // Initial sizing/positioning
  requestAnimationFrame(()=>{
    sizeProxy();
    debouncedSizeThumb();
    positionThumb();
    proxy.scrollLeft = gridScroll.scrollLeft;
  });

})();

// v2.0.127 — Ensure the left-most card is tagged as .left-col for layering
(function(){
  const panel = document.getElementById('panel');
  if (!panel) return;
  function retag(){
    // remove existing tags
    panel.querySelectorAll('.card.left-col').forEach(el => el.classList.remove('left-col'));
    // tag first visible card
    const first = panel.querySelector('.card');
    if (first) first.classList.add('left-col');
  }
  // Initial tag after first render
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', retag);
  } else {
    retag();
  }
  // Observe changes to keep tag accurate after render()
  if ('MutationObserver' in window) {
    const obs = new MutationObserver(() => { retag(); });
    obs.observe(panel, { childList: true, subtree: false });
  }
  // Also re-run on window resize (layout shifts)
  window.addEventListener('resize', retag);
})();
</script>

<div aria-hidden="true" id="printOptionsWrap">
<div aria-labelledby="po-title" aria-modal="true" id="printOptions" role="dialog">
<h2 id="po-title">Print Options</h2>
<div class="row">
<label for="po-sort">Sort by</label>
<div>
<select id="po-sort">
<option selected="" value="position">Position (1 at top)</option>
<option value="car-asc">Car No ↑</option>
<option value="total-asc">Total Score ↑</option>
<option value="total-desc">Total Score ↓</option>
<option value="print_days_results">Days results</option>
</select>
</div>
</div>
<div class="actions">
<button id="po-cancel" type="button">Cancel</button>
<button id="po-print" type="button">Print</button>
</div>
</div>
</div>
<div id="printSnapshot"></div>

<script id="print-js-v171">
(()=>{
  const $$ = (sel,root=document)=>Array.from(root.querySelectorAll(sel));
  const $  = (sel,root=document)=>root.querySelector(sel);

  function ensurePrintButtonId(){
    const btn = $$('button').find(b=>b.textContent.trim().toLowerCase()==='print');
    if(btn && !btn.id) btn.id='btn-print';
  }
  function openModal(){ wrap.setAttribute('aria-hidden','false'); $('#po-print').focus(); }
  function closeModal(){ wrap.setAttribute('aria-hidden','true'); }

  function rowsCount(){
    const body = $('.card.console-card .card-body'); if(!body) return 0;
    return new Set($$('.cell[data-row]', body).map(el=>el.dataset.row)).size;
  }
  function driverAt(r){
    const body = $('.card.console-card .card-body'); if(!body) return '';
    const cells = $$('.cell', body); const el = cells[r*5+0]?.querySelector('div'); return el?el.textContent.trim():'';
  }
  function navAt(r){
    const body = $('.card.console-card .card-body'); if(!body) return '';
    const cells = $$('.cell', body); const el = cells[r*5+1]?.querySelector('div'); return el?el.textContent.trim():'';
  }
  function spdAt(r){
    const body = $('.card.console-card .card-body'); if(!body) return '';
    const cells = $$('.cell', body); const el = cells[r*5+2]?.querySelector('div'); return el?el.textContent.trim():'';
  }
function carAt(r){
    const els = $$('.card.console-card .card-body .rally-no'); const el = els[r]; return el?el.textContent.trim():String(r+1);
  }

  function cardType(title){
    const t=title.toLowerCase();
    if(t.includes('start stc')) return 'SSTC';
    if(t.includes('open control')) return 'OC';
    if(t.includes('marshal')) return 'Mar';
    if(t.includes('stc')) return 'STC';
    return 'STC';
  }
  const numFrom = t => ((/([0-9]+)/.exec(t)||[])[1]||'');

  function cards(){
    const out=[];
    $$('#panel .card').forEach(c=>{
      if(c.classList.contains('console-card')) return;
      if(c.classList.contains('coc-card')) return;
      const t = $('.card-head .title span:last-child', c)?.textContent.trim() || c.dataset.cardId || 'Control';
      const firstScore = $('.card-body .kind-score > div', c);
      const included = firstScore ? !firstScore.classList.contains('excluded') : true;
      out.push({el:c, title:t, type:cardType(t), num:numFrom(t), included});
    });
    return out;
  }
  function cocMeta(){
    const el = $('.card.coc-card'); if(!el) return {present:false};
    return {present:true, included:!el.classList.contains('excluded'), el};
  }
  function scoreFor(cardEl,row){
    const el = $('.card-body .cell.kind-score[data-row="'+row+'"] > div', cardEl) ||
               $('.card-body .cell.kind-score[data-row="'+row+'\"] > div', cardEl);
    if(!el) return 0; const n=parseInt((el.textContent||'').trim(),10); const v=Number.isFinite(n)?n:0;
    return el.classList.contains('excluded')?0:v;
  }
  function cocScoreFor(el,row){
    const inputs = $$('.card-body .coc-num', el); const inp = inputs[row];
    const n = parseInt((inp?.value||'').trim(),10); return Number.isFinite(n)?n:0;
  }
  const byCar=(a,b)=>((parseInt(a.car,10)||0)-(parseInt(b.car,10)||0));

  function snapshot(opts){
    const root = $('#printSnapshot'); root.innerHTML='';
    const n = rowsCount(); if(!n){ alert('Nothing to print yet.'); return; }

    const cs = cards(); const coc = cocMeta(); const includeCoC = !!(coc.present && coc.included);
    const controlNames = []; if(includeCoC) controlNames.push('CoC'); cs.forEach(c=>controlNames.push(c.title));

    // Build data
    const data=[];
    for(let r=0;r<n;r++){
      const row={driver:driverAt(r), navigator:navAt(r), speed:spdAt(r), car:carAt(r), scores:{}, total:0};
      cs.forEach(c=>{ const v=scoreFor(c.el,r); row.scores[c.title]=v; row.total+=Math.abs(v); });
      if(includeCoC){ const v=cocScoreFor(coc.el,r); row.scores['CoC']=v; row.total+=Math.abs(v); }
      data.push(row);
    }
    // Sort & position
    if(opts.sort==='position' || opts.sort==='total-asc') data.sort((a,b)=>{
      const az = (a.total===0);
      const bz = (b.total===0);
      if(az && !bz) return 1;   // zeros to bottom
      if(!az && bz) return -1;
      return (a.total-b.total) || byCar(a,b);
    });
    else if(opts.sort==='total-desc') data.sort((a,b)=>(b.total-a.total)||byCar(a,b));
    else if(opts.sort==='car-asc') data.sort(byCar);
    const rank = data.slice().sort((a,b)=>(a.total-b.total)||byCar(a,b));
    const posMap = new Map(rank.map((r,i)=>[r,i+1])); data.forEach(r=>r.position=posMap.get(r));

    // Pagination by physical width (column-fit, no partial columns)
    // Use conservative usable width to avoid printer margin surprises.
    const usableMm = 250; // safe printable width for A4 landscape across common printers
    const fixedMm = 34+34+8+8+14+10; // Driver + Navigator + SG + RallyNo + Total + Pos
    const colMm = 14; // per control score column (fits ±600)
    const pages = [];
    let cur = [];
    let used = fixedMm;
    for(const name of controlNames){
      if(cur.length && (used + colMm) > usableMm){
        pages.push(cur);
        cur = [];
        used = fixedMm;
      }
      cur.push(name);
      used += colMm;
    }
    if(cur.length) pages.push(cur);

    function headerLabel(name){
      if(name==='CoC') return 'COC';
      const m = cs.find(c=>c.title===name);
      if(!m) return String(name||'').trim();
      const t = String(m.type||'').trim();
      const abbr =
        (t==='STC') ? 'STC' :
        (t==='Mar') ? 'MAR' :
        (t==='OC') ? 'OC' :
        (t==='SSTC') ? 'SST' :
        (t==='Marshal') ? 'MAR' :
        (t==='Open Control') ? 'OC' :
        (t==='Start STC') ? 'SST' :
        t.toUpperCase();
      const num = String(m.num||'').trim();
      return num ? (abbr + num) : abbr;
    }

    pages.forEach(ctrls=>{
      const sect=document.createElement('section'); sect.className='print-page';
      // Page header: one string "Rally Title  Day X"
      const rt = ($('#rallyTitlePill')?.textContent||'').trim();
      const dy = ($('#dayPillLabel')?.textContent||'').trim();
      const hdrText = [rt, dy].filter(Boolean).join('  ');
      if(hdrText){
        const hdr=document.createElement('div'); hdr.className='print-pagehdr'; hdr.textContent=hdrText;
        sect.appendChild(hdr);
      }
      const table=document.createElement('table'); table.className='print-table';
      const colg=document.createElement('colgroup');
      const addCol=mm=>{ const col=document.createElement('col'); col.style.width=mm+'mm'; colg.appendChild(col); };
      addCol(34); addCol(34); addCol(8); addCol(8); ctrls.forEach(()=>addCol(14)); addCol(14); addCol(10);
      table.appendChild(colg);

      // THEAD
      const thead=document.createElement('thead'); const trh=document.createElement('tr');
      const mkth=(t,cls)=>{ const th=document.createElement('th'); if(cls) th.className=cls; th.appendChild(document.createTextNode(t)); return th; };
      trh.appendChild(mkth('Driver','th-left')); trh.appendChild(mkth('Navigator','th-left'));
      trh.appendChild(mkth('Spd','center')); trh.appendChild(mkth('Car','center'));
      ctrls.forEach(nm=>{ const th=document.createElement('th'); th.className='center'; th.textContent=headerLabel(nm); trh.appendChild(th); });
      trh.appendChild(mkth('Total','center th-tot')); trh.appendChild(mkth('Pos','center th-pos'));
      thead.appendChild(trh); table.appendChild(thead);

      // TBODY
      const tbody=document.createElement('tbody');
      data.forEach(r=>{
        const tr=document.createElement('tr'); const td=(t,cls)=>{ const e=document.createElement('td'); e.textContent=t; if(cls) e.className=cls; return e; };
        tr.appendChild(td(r.driver,'nowrap')); tr.appendChild(td(r.navigator,'nowrap'));
        tr.appendChild(td(r.speed,'center')); tr.appendChild(td(r.car,'center'));
        ctrls.forEach(nm=> tr.appendChild(td(String(r.scores[nm]??0),'center mono')) );
        tr.appendChild(td(String(r.total),'center mono td-tot')); tr.appendChild(td(String(r.position),'center td-pos'));
        tbody.appendChild(tr);
      });
      table.appendChild(tbody); sect.appendChild(table); root.appendChild(sect);
    });
  }
  function snapshotDaysResults(){
    const root = $('#printSnapshot'); root.innerHTML='';
    const n = rowsCount(); if(!n){ alert('Nothing to print yet.'); return; }

    // Force portrait for this print only
    const st=document.createElement('style');
    st.textContent='@media print{ @page{ size:A4 landscape; margin:10mm; } }';
    root.appendChild(st);

    // Days (from TD_RALLIES → rallies[rid].admin.days)
    let dayNos = [];
    try{
      const rid = (typeof window.getActiveRid==='function') ? window.getActiveRid() : (window.TD_ACTIVE_RID||'RID-DEV');
      const raw = localStorage.getItem('TD_RALLIES');
      const obj = raw ? JSON.parse(raw) : null;
      const daysObj = obj && obj.rallies && obj.rallies[rid] && obj.rallies[rid].admin && obj.rallies[rid].admin.days ? obj.rallies[rid].admin.days : null;
      if(daysObj && typeof daysObj === 'object'){
        dayNos = Object.keys(daysObj).map(k=>parseInt(k,10)).filter(n=>Number.isFinite(n) && n>0).sort((a,b)=>a-b);
      }
    }catch(_e){ dayNos=[]; }
    if(!dayNos.length) dayNos = [1];
// v2.2.315 — Days results prefers stored per-day totals (controlsData.days[day].dayTotalByNo)
    const perDayTotals = []; // [dayIdx][row] => total
    const activeDayNo = (typeof dayNo !== 'undefined') ? Number(dayNo) : (parseInt(localStorage.getItem('TD_ACTIVE_DAY')||'1',10)||1);

    // Read TD_RALLIES once for stored totals
    let _root=null, _rid=null, _rally=null;
    try{
      _rid = (typeof window.getActiveRid==='function') ? window.getActiveRid() : (window.TD_ACTIVE_RID||'RID-DEV');
      const raw = localStorage.getItem('TD_RALLIES');
      _root = raw ? JSON.parse(raw) : null;
      _rally = (_root && _root.rallies && _root.rallies[_rid]) ? _root.rallies[_rid] : null;
    }catch(_e){ _root=null; _rid=null; _rally=null; }

    for(const dn of dayNos){
      let totals = null;
      try{
        const dk = String(dn);
        const map = (_rally && _rally.controlsData && _rally.controlsData.days && _rally.controlsData.days[dk] && _rally.controlsData.days[dk].dayTotalByNo) ? _rally.controlsData.days[dk].dayTotalByNo : null;
        if(map && typeof map === 'object'){
          totals = new Array(n).fill(0);
          for(let r=0;r<n;r++){
            const noRaw = (typeof carAt === 'function') ? String(carAt(r)||'').trim() : '';
            const no = noRaw ? noRaw : String(r+1);
            totals[r] = parseInt(map[no]||0,10) || 0;
          }
        }
      }catch(_e){ totals = null; }

      if(!Array.isArray(totals)) totals = new Array(n).fill(0);
      perDayTotals.push(totals.slice(0, n));
    }
// Build data
    const data=[];
    for(let r=0;r<n;r++){
      const row={driver:driverAt(r), navigator:navAt(r), sg:spdAt(r), car:carAt(r), day:[], total:0};
      for(let i=0;i<perDayTotals.length;i++){
        const v = parseInt(perDayTotals[i][r]||0,10) || 0;
        row.day.push(v);
        row.total += v;
      }
      data.push(row);
    }
    // Sort & position (lowest total = Pos 1)
    data.sort((a,b)=>{
      const at = Number(a.total)||0;
      const bt = Number(b.total)||0;
      const az = (at===0);
      const bz = (bt===0);
      if(az && !bz) return 1;
      if(!az && bz) return -1;
      return (at-bt) || byCar(a,b);
    });
    data.forEach((r,i)=>{ r.position = i+1; });

    // Pagination by physical width (portrait)
    const usableMm = 277; // safe printable width for A4 landscape // safe printable width for A4 portrait
    const fixedMm = 45+45+10+10+14+10; // Driver + Navigator + SG + RallyNo + Total + Pos
    const colMm = 14; // per day column
    const pages=[];
    let cur=[]; let used=fixedMm;
    for(let i=0;i<dayNos.length;i++){
      if(cur.length && (used + colMm) > usableMm){ pages.push(cur); cur=[]; used=fixedMm; }
      cur.push(i); used += colMm;
    }
    if(cur.length) pages.push(cur);

    pages.forEach(dayIdxs=>{
      const sect=document.createElement('section'); sect.className='print-page';
      const rt = ($('#rallyTitlePill')?.textContent||'').trim();
      const hdrText = [rt, 'Days results'].filter(Boolean).join('  ');
      if(hdrText){
        const hdr=document.createElement('div'); hdr.className='print-pagehdr'; hdr.textContent=hdrText;
        sect.appendChild(hdr);
      }
      const table=document.createElement('table'); table.className='print-table';
      const colg=document.createElement('colgroup');
      const addCol=mm=>{ const col=document.createElement('col'); col.style.width=mm+'mm'; colg.appendChild(col); };
      addCol(45); addCol(45); addCol(10); addCol(10);
      dayIdxs.forEach(()=>addCol(14));
      addCol(14); addCol(10);
      table.appendChild(colg);

      const thead=document.createElement('thead'); const trh=document.createElement('tr');
      const mkth=(t,cls)=>{ const th=document.createElement('th'); if(cls) th.className=cls; th.appendChild(document.createTextNode(t)); return th; };
      trh.appendChild(mkth('Driver','th-left')); trh.appendChild(mkth('Navigator','th-left'));
      trh.appendChild(mkth('SG','center')); trh.appendChild(mkth('Car','center'));
      dayIdxs.forEach(i=>{ const th=document.createElement('th'); th.className='center'; th.textContent='Day ' + String(dayNos[i]); trh.appendChild(th); });
      trh.appendChild(mkth('Total','center th-tot')); trh.appendChild(mkth('Pos','center th-pos'));
      thead.appendChild(trh); table.appendChild(thead);

      const tbody=document.createElement('tbody');
      data.forEach(r=>{
        const tr=document.createElement('tr'); const td=(t,cls)=>{ const e=document.createElement('td'); e.textContent=t; if(cls) e.className=cls; return e; };
        tr.appendChild(td(r.driver,'nowrap')); tr.appendChild(td(r.navigator,'nowrap'));
        tr.appendChild(td(r.sg,'center')); tr.appendChild(td(r.car,'center'));
        dayIdxs.forEach(i=> tr.appendChild(td(String(r.day[i]??0),'center mono')) );
        tr.appendChild(td(String(r.total),'center mono td-tot')); tr.appendChild(td(String(r.position),'center td-pos'));
        tbody.appendChild(tr);
      });
      table.appendChild(tbody); sect.appendChild(table); root.appendChild(sect);
    });
  }


  // Init wiring
  ensurePrintButtonId();
  const wrap = document.getElementById('printOptionsWrap');
  const trigger = document.getElementById('btn-print') || document.getElementById('btn-print'); // defensive
  const btnCancel = document.getElementById('po-cancel');
  const btnPrint  = document.getElementById('po-print');
  if(trigger) trigger.addEventListener('click', openModal);
  if(btnCancel) btnCancel.addEventListener('click', closeModal);
  if(btnPrint) btnPrint.addEventListener('click', ()=>{
    const sel = document.getElementById('po-sort').value;
    closeModal();
    if(sel==='print_days_results') snapshotDaysResults();
    else snapshot({sort: sel});
    setTimeout(()=>window.print(), 20);
    setTimeout(()=>{ const r=document.getElementById('printSnapshot'); if(r) r.innerHTML=''; }, 1500);
  });
})();</script>
<script>

;

(function(){
  // Keep first of each, remove any extra duplicates if present.
  const keepFirst = (sel) => {
    const nodes = Array.from(document.querySelectorAll(sel));
    nodes.slice(1).forEach(n => n.remove());
  };
  // Controls data button (id)
  keepFirst('#btnControlsData');
  // Status pill: keep the one with the known id
  const pills = Array.from(document.querySelectorAll('.status-pill'));
  const primary = document.getElementById('controlsDataStatus');
  pills.forEach(p=>{
    if(p !== primary && p.textContent.trim().toLowerCase()==='plan changed') p.remove();
  });
})();

(function(){
  const btn = document.getElementById('dayPillBtn');
  const menu = document.getElementById('dayPillMenu');
  const label = document.getElementById('dayPillLabel');
  if(!btn || !menu || !label) return;

  const MONTHS = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];

  // v2.1.119 — shared active day (persisted in TD_RALLIES.rallies[title].ui.activeDay)
  const __DAY_BC_NAME = 'TD_RALLIES_CHANGED';
  let __dayBc = null;
  const _pad2 = (n) => String(n).padStart(2,'0');
  const _todayIsoLocal = () => {
    const d = new Date();
    return d.getFullYear() + '-' + _pad2(d.getMonth()+1) + '-' + _pad2(d.getDate());
  };
  const _normalizeToIso_ = (ds) => {
    ds = String(ds||'').trim();
    if(!ds) return '';
    let mm = ds.match(/^(\d{4})-(\d{1,2})-(\d{1,2})$/);
    if(mm) return mm[1] + '-' + _pad2(mm[2]) + '-' + _pad2(mm[3]);
    mm = ds.match(/^(\d{1,2})[-\/](\d{1,2})[-\/](\d{2,4})$/);
    if(mm){
      const yyyy = String(mm[3]).length===2 ? ('20'+mm[3]) : mm[3];
      return yyyy + '-' + _pad2(mm[2]) + '-' + _pad2(mm[1]);
    }
    return '';
  };
  const _getTdCtx_ = () => {
    try{
      const root = JSON.parse(localStorage.getItem('TD_RALLIES') || '{}') || {};
      const rid = (root && root.global && typeof root.global.activeRallyId === 'string') ? root.global.activeRallyId : '';
      if(!rid) return null;
      const rally = root && root.rallies ? root.rallies[rid] : null;
      if(!rally) return null;
      return { root, rid, rally };
    }catch(_e){ return null; }
  };
  const _getStoredActiveDay_ = () => {
    // Prefer the lightweight mirror key (TD_ACTIVE_DAY) as the single cross-tab driver,
    // then fall back to TD_RALLIES.rallies[rid].ui.activeDay if present.
    try{
      const v2 = Number(localStorage.getItem('TD_ACTIVE_DAY'));
      if(v2>=1 && v2<=7) return v2;
    }catch(_e){}
    try{
      const ctx = _getTdCtx_();
      if(ctx && ctx.rally){
        const ui = ctx.rally.ui || {};
        const v = Number(ui.activeDay);
        if(v>=1 && v<=7) return v;
      }
    }catch(_e){}
    return null;
  };
  const _persistActiveDay_ = (dayNo, reason) => {
    dayNo = Number(dayNo)||1;
    // Always write the lightweight mirror key (used as a "telephone line" between tabs).
    try{ localStorage.setItem('TD_ACTIVE_DAY', String(dayNo)); }catch(_e){}
    // Best-effort broadcast so other open pages can react immediately.
    try{
      if('BroadcastChannel' in window){
        if(!__dayBc) __dayBc = new BroadcastChannel(__DAY_BC_NAME);
        __dayBc.postMessage({ type:'TD_RALLIES_CHANGED', reason: String(reason||'activeDay'), dayNo, ts: Date.now() });
      }
    }catch(_e){}
    return true;
  };

  function fmtDdMon(dateStr){
    if(!dateStr || typeof dateStr !== 'string') return '--';

    // dd-mm-yyyy (or dd/mm/yyyy)
    let m = dateStr.match(/^(\d{1,2})[-\/](\d{1,2})[-\/](\d{2,4})$/);
    if(m){
      const dd = String(parseInt(m[1],10)).padStart(2,'0');
      const mm = parseInt(m[2],10);
      const mon = MONTHS[Math.max(1,Math.min(12,mm))-1] || '--';
      return dd + ' ' + mon;
    }

    // yyyy-mm-dd (or yyyy/mm/dd) — common from <input type="date">
    m = dateStr.match(/^(\d{4})[-\/](\d{1,2})[-\/](\d{1,2})$/);
    if(m){
      const dd = String(parseInt(m[3],10)).padStart(2,'0');
      const mm = parseInt(m[2],10);
      const mon = MONTHS[Math.max(1,Math.min(12,mm))-1] || '--';
      return dd + ' ' + mon;
    }

    return '--';
  }
  function getDays(){
    // Single source of truth: TD_RALLIES.rallies[RID].admin.days
    // Returns an array of {dayNo, date} sorted by dayNo. No synthetic/default days.
    try{
      const ctx = _getTdCtx_();
      if(!ctx) return [];
      const daysObj = ctx.rally && ctx.rally.admin ? ctx.rally.admin.days : null;
      if(!daysObj || typeof daysObj !== 'object') return [];
      const out = [];
      for(const k of Object.keys(daysObj)){
        const n = Number(k);
        if(!Number.isFinite(n) || n < 1) continue;
        const rec = daysObj[k] || {};
        const ds = (typeof rec.date === 'string') ? rec.date.trim() : '';
        if(ds) out.push({ dayNo: n, date: ds });
      }
      out.sort((a,b)=>a.dayNo-b.dayNo);
      return out;
    }catch(_e){
      return [];
    }
  }

  function setSelected(dayNo, dateStr){
    dayNo = Math.max(1, Math.min(7, Number(dayNo)||1));
    label.textContent = 'Day ' + dayNo + ' - ' + fmtDdMon(dateStr);
    btn.dataset.dayIndex = String(dayNo-1); // keep legacy contract for downstream day logic
    btn.setAttribute('aria-expanded','false');
    menu.hidden = true;
  }

  function buildMenu(){
    const days = getDays();
    menu.innerHTML = '';

    // Current selection: shared driver (TD_ACTIVE_DAY) if present; otherwise first available admin day.
    const storedDayNo = _getStoredActiveDay_();
    const hasStored = (storedDayNo && storedDayNo>=1 && storedDayNo<=7);

    // choose current day if it exists in available list, else first item
    let current = null;
    if(days && days.length){
      if(hasStored) current = days.find(d => Number(d.dayNo) === Number(storedDayNo)) || null;
      if(!current) current = days[0];
    }else{
      current = { dayNo: (hasStored ? storedDayNo : 1), date: null };
    }

    (days||[]).forEach((d) => {
      const dayNo = Number(d && d.dayNo) || 1;
      const dateStr = (d && d.date) ? d.date : null;

      const item = document.createElement('button');
      item.type = 'button';
      item.className = 'daydd-item' + (dayNo === Number(current.dayNo) ? ' selected' : '');
      item.textContent = 'Day ' + dayNo + ' - ' + fmtDdMon(dateStr);
      item.addEventListener('click', (e) => {
        e.preventDefault();
        setSelected(dayNo, dateStr);
        try{ _persistActiveDay_(dayNo, 'user-day'); }catch(_e){}
        try{
          // allow existing listeners to react to day change
          btn.dispatchEvent(new CustomEvent('daypill:changed', { bubbles:true, detail:{ dayIndex: dayNo-1, dayNo, date: dateStr } }));
        }catch(_e){}
      });

      menu.appendChild(item);
    });

    setSelected(Number(current.dayNo)||1, current.date || null);
  }


function _applyExternalDayNo_(dayNo){
  // v2.2.321 — mirror fence: mark this as an external mirror-driven day change (no TD_RALLIES writes)
  try{ window.__TD_DAY_MIRROR_APPLYING = true; }catch(_e){}
  try{ window.__TD_WRITE_FENCE_UNTIL = Date.now() + 1600; }catch(_e){}
  try{ clearTimeout(window.__TD_DAY_MIRROR_TMR); }catch(_e){}
  window.__TD_DAY_MIRROR_TMR = setTimeout(()=>{ try{ window.__TD_DAY_MIRROR_APPLYING = false; }catch(_e){} }, 800);

  dayNo = Math.max(1, Math.min(7, Number(dayNo)||1));
  const days = getDays();
  const rec = (days||[]).find(d => Number(d.dayNo) === Number(dayNo)) || { dayNo, date: null };
  setSelected(dayNo, rec.date || null);
  try{
    btn.dispatchEvent(new CustomEvent('daypill:changed', { bubbles:true, detail:{ dayIndex: dayNo-1, dayNo, date: rec.date || null } }));
  }catch(_e){}
}
  function openMenu(){
    buildMenu();
    menu.hidden = false;
    btn.setAttribute('aria-expanded','true');
  }

  function closeMenu(){
    menu.hidden = true;
    btn.setAttribute('aria-expanded','false');
  }

  btn.addEventListener('click', (e) => {
    e.preventDefault();
    if(menu.hidden) openMenu();
    else closeMenu();
  });

  document.addEventListener('click', (e) => {
    if(menu.hidden) return;
    const wrap = document.getElementById('dayPillWrap');
    if(wrap && !wrap.contains(e.target)) closeMenu();
  });

  document.addEventListener('keydown', (e) => {
    if(e.key === 'Escape' && !menu.hidden) closeMenu();
  });

// Rebuild on updates (broadcast + storage fallback)
// - If TD_RALLIES exists, rebuild menu from Admin days + ui.activeDay.
// - If TD_RALLIES is not yet present, allow day mirroring via TD_ACTIVE_DAY.
try{
  if('BroadcastChannel' in window){
    const bc = new BroadcastChannel('TD_RALLIES_CHANGED');
    bc.onmessage = (ev)=>{
      try{
        const msg = ev && ev.data ? ev.data : null;
        if(msg && msg.type && String(msg.type) !== 'TD_RALLIES_CHANGED') return;
        if(msg && typeof msg.dayNo !== 'undefined'){
          try{ localStorage.setItem('TD_ACTIVE_DAY', String(Number(msg.dayNo)||1)); }catch(_e){}
          _applyExternalDayNo_(Number(msg.dayNo)||1);
          try{ refreshWorkspaceUi_(); }catch(_e){}
        }else{
          buildMenu();
          try{ refreshWorkspaceUi_(); }catch(_e){}
        }
      }catch(_e){}
    };
  }
}catch(_e){}
window.addEventListener('storage', (e)=>{
  try{
    if(!e) return;
    if(e.key === 'TD_RALLIES') { buildMenu(); try{ refreshWorkspaceUi_(); }catch(_e){} return; }
    if(e.key === 'TD_ACTIVE_DAY'){
      const v = Number(e.newValue);
      if(v>=1 && v<=7) _applyExternalDayNo_(v);
    }
  }catch(_e){}
});

  buildMenu();
  try{ refreshWorkspaceUi_(); }catch(_e){}
})();;
</script>

<div id="ccRoot">
<div aria-hidden="true" class="cc-modal-overlay" id="entriesOverlay">
<section aria-labelledby="entriesTitle" aria-modal="true" id="entriesPanel" role="dialog">
<header class="cc-modal-header">
<h2 id="entriesTitle">Controls</h2>
<span class="cc-badge warn" id="connectionStatus" style="margin-left:10px;">Not connected</span>
<button class="cc-btn ghost small" id="closeBtn" type="button">Close</button>
</header>
<div class="cc-sections">

<div aria-hidden="true" class="cc-modal-overlay" id="loadConfirmOverlay">
  <section aria-modal="true" role="dialog" id="loadConfirmPanel" aria-labelledby="loadConfirmTitle">
    <h2 id="loadConfirmTitle">Load Rally File</h2>
    <p>Loading will overwrite current work. Consider saving first.</p>
    <div class="actions">
      <button id="btnLoadConfirmCancel" type="button">Cancel</button>
      <button id="btnLoadConfirmGo" class="primary" type="button">Load...</button>
    </div>
  </section>
</div>
<div id="engineBand" style="padding:0 10px;">
<section class="cc-section cc-compact" style="margin-top:6px;">
<div class="cc-row" style="align-items:center;justify-content:space-between;gap:8px;flex-wrap:wrap;margin:4px 0 2px">
<div style="display:flex;align-items:center;gap:8px;flex-wrap:wrap;">
<h3 id="dataBandTitle" style="margin:0;">Controls data</h3>
</div>
<div class="cc-section-actions" style="align-items:center;">
<button class="cc-btn ghost micro off" id="viewResponsesBtn" type="button">View Response forms</button>
<button class="cc-btn small off" id="openControlsBtn" type="button">Open controls data</button>
<button class="cc-btn small off" id="downloadControlsBtn" type="button">Download controls data</button>
</div>
</div></section>
<section class="cc-section cc-compact" style="margin-top:6px;">
<div class="cc-row" style="align-items:center;gap:8px;flex-wrap:wrap;">
<span class="cc-chip small" id="cdRallyTitlePill" style="font-weight:600;font-size:14px;color:#111827;flex:0 1 260px;min-width:200px;max-width:320px;text-align:left;justify-content:flex-start;border:1px solid #d1d5db;"></span>
<span class="cc-chip small" id="cdDayPill" style="font-weight:600;font-size:14px;color:#111827;min-width:170px;border:1px solid #d1d5db;"></span>
<span class="cc-spacer"></span>
<button class="cc-btn small secondary off" id="cdUploadBtn" type="button">Upload control data</button>
</div>
</section>
</div>
<div id="controlsCard">
<section class="cc-section cc-compact" style="margin-top:6px;">
<div class="cc-row" style="align-items:center;justify-content:space-between;gap:8px;flex-wrap:wrap;">
<h3 id="entrantLinkTitle" style="margin:0;">Entrant STC link</h3>
<div class="cc-toast-slot"><div aria-live="polite" class="cc-toast" id="cc-toast" role="status"></div></div>
<div class="cc-section-actions">
<button class="cc-btn small ghost" id="cdEntrantCopy">Copy link</button>
<button class="cc-btn small" id="cdEntrantEmail">Email link</button>
<button class="cc-btn small whatsapp" id="cdEntrantWA">WhatsApp</button>
</div>
</div>
</section>
<section class="cc-section cc-compact" style="margin-top:6px;">
<div class="cc-row" style="align-items:center;justify-content:space-between;gap:8px;flex-wrap:wrap;">
<div style="display:flex;align-items:center;gap:8px;flex-wrap:wrap;">
<h3 style="margin:0;">Marshal link</h3>
</div>
<div class="cc-section-actions">
<button class="cc-btn small ghost" id="cdMarshalCopy">Copy link</button>
<button class="cc-btn small" id="cdMarshalEmail">Email link</button>
<button class="cc-btn small whatsapp" id="cdMarshalWA">WhatsApp</button>
</div>
</div>
</section>
</div>
</div>
</section>
</div>
</div>

<script id="controlsCardModuleJs">
// Rally Controls – Admin / Controls panel front-end logic
(() => {
  

  // v2.1.19 hotfix: null-safe event binding helper (was missing in v2.1.19)
  const safeOn = (el, type, handler, opts) => { try { if (el) el.addEventListener(type, handler, opts); } catch(e) {} };

  ;

  // v2.1.19: host-context readers (page owns Rally Title + Day/Date)
  const getHostRallyTitle_ = () => {
    // v2.1.19: simple mirror — card title copies exactly what the page title pill shows.
    const el = document.getElementById('rallyTitlePill');
    return el ? String(el.textContent || '').trim() : '';
  };
  const isValidRallyName_ = (name) => {
    const s = String(name || '').trim();
    if (!s) return false;
    if (/^rally\s*title$/i.test(s)) return false;
    if (/^rally$/i.test(s)) return false;
    return true;
  };
  const getHostDayLabel_ = () => {
    const el = document.getElementById('dayPillLabel') || document.getElementById('dayPillBtn');
    return el ? String(el.textContent || '').trim() : '';
  };
  const getHostDayNum_ = () => {
    const label = getHostDayLabel_();
    const m = /\bday\s*(\d+)\b/i.exec(label);
    return m ? String(m[1]) : '';
  };
  const syncCardHeaderFromHost_ = () => {
    try {
      const overlay = document.getElementById('entriesOverlay');
      if (!(overlay && overlay.classList && overlay.classList.contains('open'))) return;
      const cardTitle = overlay.querySelector('#cdRallyTitlePill');
      const cardDay = overlay.querySelector('#cdDayPill');
      const title = getHostRallyTitle_();
      const dayLabel = getHostDayLabel_();
      if (cardTitle) cardTitle.textContent = title || '';
      if (cardDay) cardDay.textContent = dayLabel || '';
    } catch(e) {}
  };
  const bindHostContextObservers_ = () => {
    try {
      const overlay = document.getElementById('entriesOverlay');
      if (overlay && window.MutationObserver) {
        const obs = new MutationObserver(() => { syncCardHeaderFromHost_(); });
        obs.observe(overlay, { attributes: true, attributeFilter: ['class','aria-hidden','style'] });
      }
      const titleEl = document.getElementById('rallyTitlePill');
      if (titleEl && window.MutationObserver) {
        const obs2 = new MutationObserver(() => { syncCardHeaderFromHost_(); });
        obs2.observe(titleEl, { childList: true, characterData: true, subtree: true });
      }
      const dayEl = document.getElementById('dayPillLabel') || document.getElementById('dayPillBtn');
      if (dayEl && window.MutationObserver) {
        const obs3 = new MutationObserver(() => { syncCardHeaderFromHost_(); });
        obs3.observe(dayEl, { childList: true, characterData: true, subtree: true });
      }
    } catch(e) {}
  };
  // bind once
  bindHostContextObservers_();

  const ControlsCardCore = (() => {
  // v1.51: internal module map (no behaviour change).
  // This is a readability refactor only: we group responsibilities as modules (UI/STATE/NET/PAYLOAD/SHARE)
  // without changing call sites yet. Future size-trim passes can safely remove dead code module-by-module.

  // v1.27: Controls card module boundary (no behaviour change).
  // Public API is exposed as window.ControlsCard for transplanting into the real app page.
  
const ControlsCard = (() => {
    const api = {};
    api.open = () => {
      try { if (entriesBtn) entriesBtn.click(); } catch(e) {}
      try { setTimeout(() => { syncCardHeaderFromHost_(); }, 0); } catch(e) {}
      // v2.1.74 — On open, immediately refresh Google-world status (so Data card triggers network calls).
      try { setTimeout(() => { if (typeof refreshStatusAfterPing === 'function') refreshStatusAfterPing(); }, 0); } catch(e) {}
    };
    api.close = () => {
      try {
        if (closeBtn) closeBtn.click();
        else if (overlay) { overlay.classList.remove('open'); overlay.setAttribute('aria-hidden','true'); }
      } catch(e) {}
    };
    api.refresh = () => { try { return refreshStatusAfterPing(); } catch(e) {} };
    api.update = () => { try { return updateButtonStates(); } catch(e) {} };
    api.ping = () => { try { return handleSaveAndTest(); } catch(e) {} };
    return api;
  })();
  window.ControlsCard = ControlsCard;

  let saved = {};
  let badTitleWarned = false;
  // Ephemeral Google-world status (never persisted)
  let live = {
    spreadsheetUrl: '',
    hasControlsDataByDay: {},
    hasStcDataByDay: {},
    hasMarshalDataByDay: {},
    entrantFormUrlByDay: {},
    marshalFormUrlByDay: {},
    responsesFolderUrlByDay: {}
  };
  const cmUrlInput = document.getElementById('ttWebAppUrl');
  const cmMobInput = document.getElementById('cmMobInput');

  // v2.1.210 — COMMON settings are sourced from TD_RALLIES; on-page edits are session-local.
  function syncCommonPills_(){
    try{
      if(cmUrlInput) cmUrlInput.value = (saved && saved.webAppUrl) ? String(saved.webAppUrl) : '';
      if(cmMobInput) cmMobInput.value = (saved && saved.organizerMobile) ? String(saved.organizerMobile) : '';
    }catch(_e){}
  }

  const entriesBtn = document.getElementById('openControlsCard') || document.getElementById('btnControlsData'); // opener (host may use btnControlsData)
  const overlay = document.getElementById('entriesOverlay');

  // Overlay-scoped lookup (ControlsCard DOM isolation)
  const inOverlay = (id) => overlay ? overlay.querySelector('#' + id) : null;

  const connectionStatusEl = inOverlay('connectionStatus');
  const saveTestBtn = document.getElementById('ttSaveTest') || inOverlay('ttSaveTest');
const clearUrlBtn = document.getElementById('ttClear') || inOverlay('ttClear');
const panel = inOverlay('entriesPanel');
  const closeBtn = inOverlay('closeBtn');

  const toast = inOverlay('cc-toast');
  let toastTimer = 0;
  const entrantCopyBtn = inOverlay('cdEntrantCopy');
  const openControlsBtn = inOverlay('openControlsBtn');
  const copyFormBtn = inOverlay('copyForm');
  const sendLinkBtn = inOverlay('sendLinkBtn');
  const waTestBtn = inOverlay('waTestBtn');
  const downloadControlsBtn = inOverlay('downloadControlsBtn');
  const viewResponsesBtn = inOverlay('viewResponsesBtn');
  const uploadControlsBtn = inOverlay('cdUploadBtn');
  const cdRallyTitlePill = inOverlay('cdRallyTitlePill');
  const cdDayPill = inOverlay('cdDayPill');
  const entrantEmailBtn = inOverlay('cdEntrantEmail');
  const entrantWABtn = inOverlay('cdEntrantWA');
  const marshalCopyBtn = inOverlay('cdMarshalCopy');
  const marshalEmailBtn = inOverlay('cdMarshalEmail');
  const marshalWABtn = inOverlay('cdMarshalWA');

  const ctrlTestTitle = document.getElementById('ttRallyTitle');
  const ttRallyTitle = ctrlTestTitle;
  const ctrlTestDay = document.getElementById('ctrlTestDay') || { value: '1' };
  const ctrlTestDatePill = document.getElementById('ctrlTestDatePill') || document.getElementById('cdDayPill');

  function getSelectedDay_() {
    // Host page owns the Day selector (dayPillBtn/dayPillLabel). Card reads it.
    const btn = document.getElementById('dayPillBtn');
    let idx = 0;
    try { idx = parseInt((btn && btn.dataset && btn.dataset.dayIndex) ? btn.dataset.dayIndex : '0', 10); } catch(e) { idx = 0; }
    if (!Number.isFinite(idx) || idx < 0) idx = 0;
    return idx + 1; // 1..7
  }

  function copyTextLegacy(text) {
    try {
      const textarea = document.createElement('textarea');
      textarea.value = text;
      textarea.setAttribute('readonly', '');
      textarea.style.position = 'absolute';
      textarea.style.left = '-9999px';
      document.body.appendChild(textarea);
      const selection = document.getSelection();
      const selected = selection && selection.rangeCount > 0 ? selection.getRangeAt(0) : null;
      textarea.select();
      const ok = document.execCommand && document.execCommand('copy');
      document.body.removeChild(textarea);
      if (selected && selection) {
        selection.removeAllRanges();
        selection.addRange(selected);
      }
      return !!ok;
    } catch (e) {
      return false;
    }
  }

  function syncControlsHeaderFromHost() {
    // Host page is canonical for Rally Title + Day/Date.
    const titleVal = (() => {
      // Canonical: page control-panel title pill (user-entered; future JSON feed).
      const pill = document.getElementById('rallyTitlePill');
      const v0 = pill ? String(pill.textContent || '').trim() : '';
      if (v0 && v0.toLowerCase() !== 'rally title') return v0;

      // Last resort: test strip input.
      const a = document.getElementById('ttRallyTitle');
      return a ? String(a.value || '').trim() : '';
    })();

    const dayBtn = document.getElementById('dayPillBtn');
    const dayLbl = document.getElementById('dayPillLabel');
    let idx = 0;
    try { idx = parseInt((dayBtn && dayBtn.dataset && dayBtn.dataset.dayIndex) ? dayBtn.dataset.dayIndex : '0', 10); } catch(e) { idx = 0; }
    if (!Number.isFinite(idx) || idx < 0) idx = 0;
    const dayNo = idx + 1;

    const labelText = dayLbl ? String(dayLbl.textContent || '').trim() : ('Day ' + dayNo + ' - --');
    const parts = labelText.split('-');
    const dateShort = (parts && parts.length > 1) ? String(parts.slice(1).join('-')).trim() : '--';

    if (cdRallyTitlePill) cdRallyTitlePill.textContent = titleVal || 'Rally';
    if (cdDayPill) cdDayPill.textContent = labelText || ('Day ' + dayNo + ' - --');
    if (ctrlTestDatePill) ctrlTestDatePill.textContent = dateShort || '--';
  }

  function selectDayControlsTable(dayVal) {
    const host = document.getElementById('controlsTablesHost');
    if (!host) return;
    const blocks = host.querySelectorAll('.controls-day-table');
    blocks.forEach(b => {
      const d = b.getAttribute('data-day') || '';
      if (String(d) === String(dayVal)) b.classList.add('is-active');
      else b.classList.remove('is-active');
    });
  }

  function getActiveControlsScope_() {
    const host = document.getElementById('controlsTablesHost');
    if (!host) return document;
    const dayVal = ctrlTestDay ? (ctrlTestDay.value || '1') : '1';
    const active = host.querySelector('.controls-day-table.is-active[data-day="' + String(dayVal) + '"]') ||
                   host.querySelector('.controls-day-table.is-active') ||
                   host.querySelector('.controls-day-table[data-day="' + String(dayVal) + '"]') ||
                   host.querySelector('.controls-day-table');
    return active || document;
  }

  // v1.44: Page-level plan-sync indicator (lives on the page, not inside the card)
  const PLAN_SIG_KEY = 'rc_planSig';
  function getPlanSigMap_() {
    try { return JSON.parse(localStorage.getItem(PLAN_SIG_KEY) || '{}') || {}; } catch(e) { return {}; }
  }
  function setPlanSigMap_(m) {
    try { localStorage.setItem(PLAN_SIG_KEY, JSON.stringify(m || {})); } catch(e) {}
  }

  function computeActiveRowCount_() {
    try {
      // Prefer the live model row count (future baseline; avoids DOM selector fragility)
      if (typeof model === 'object' && model && Number.isFinite(model.rows)) {
        return Math.max(0, parseInt(model.rows, 10) || 0);
      }
      const scope = getActiveControlsScope_();
      if (!scope) return 0;
      // Primary: count visible console rows
      const tb = scope.querySelector('.console-card tbody');
      if (tb) return tb.querySelectorAll('tr').length || 0;
      const n = scope.querySelectorAll('.console-card .rally-no').length;
      if (n) return n;
      return 0;
    } catch(e) { return 0; }
  }

  function computePlanSig() {
    try {
      // Build signature from LIVE DOM card order (trigger-independent).
      // Ignore Rally No values (fixed 1..N reference).
      const seq = [];
      const cards = Array.from(document.querySelectorAll('.card[data-card-id]'))
        .filter(el => el && el.classList && !el.classList.contains('excluded'))
        .filter(el => {
          // visible-ish (covers display:none / detached)
          if (!document.body.contains(el)) return false;
          if (el.offsetParent === null && getComputedStyle(el).position !== 'fixed') return false;
          return true;
        });

      cards.forEach(card => {
        const id = String(card.getAttribute('data-card-id') || '').toLowerCase();
        let code = '';
        let n = '';
        const m = id.match(/(\d+)$/);
        if (m) n = m[1];

        if (id.startsWith('stc-')) code = 'STC' + (n || '');
        else if (id.startsWith('marshal-')) code = 'M' + (n || '');
        else if (id.startsWith('open-') || id.startsWith('opencontrol-') || id.startsWith('open-control-')) code = 'OC' + (n || '');
        else if (id.startsWith('startstc-') || id.startsWith('sstc-') || id.startsWith('start-stc-')) code = 'SSTC' + (n || '');
        else if (id.startsWith('coc-') || id === 'coc-card') code = 'COC';
        else return;

        seq.push(code);
      });

      // Row count: prefer the console card rally-no column (one per competitor row).
      let rows = 0;
      const consoleCard = document.querySelector('.card.console-card:not(.excluded)');
      if (consoleCard) {
        const n = consoleCard.querySelectorAll('.rally-no').length;
        if (n) rows = n;
      }
      if (!rows && typeof model === 'object' && model && Array.isArray(model.drivers)) rows = model.drivers.length;
      if (!rows) rows = 0;

      const sig = (seq.join('|') || '') + '#rows=' + rows;
      return sig;
    } catch(e) {
      return '#rows=0';
    }
  }

  // v2.1.99 — Plan-sync badge: recheck on REAL row/card DOM changes (no reliance on tool buttons)
  

  

  function updatePlanSyncBadge_() {
    const badge = document.getElementById('planSyncBadge') || document.getElementById('controlsDataStatus');
    if (!badge) return;
    const day = String(getSelectedDay_() || '1');
    const map = getPlanSigMap_();
    const stored = String(map[day] || '');
    const liveSig = computePlanSig();

    badge.classList.remove('ok','warn','bad','pulse');
    badge.classList.remove('twoline');

    // v2.1.90 forward-only: do not migrate/accept legacy (non row-aware) signatures.
    // If no valid row-aware baseline exists, treat as "not uploaded yet".
    if (!stored || stored.indexOf('#rows=') === -1) {
      badge.innerHTML = 'Plan not<br>uploaded';
      badge.classList.add('warn','twoline');
      return;
    }

    if (stored === liveSig) {
      badge.textContent = 'Plan OK';
      badge.classList.add('ok');
      return;
    }
    badge.textContent = 'Plan changed';
    badge.classList.add('warn','pulse');
  }

  function markPlanUploaded_(day, sig) {
    const d = String(day || getSelectedDay_() || '1');
    const map = getPlanSigMap_();
    // v2.1.90 forward-only: upload baseline is always the current row-aware signature
    let s = (typeof computePlanSig === 'function') ? computePlanSig() : '';
    s = String(s || '');
    if (s && s.indexOf('#rows=') === -1) {
      const rows = (typeof computeActiveRowCount_ === 'function') ? computeActiveRowCount_() : 0;
      s = s + '#rows=' + String(rows);
    }
    map[d] = s;
    setPlanSigMap_(map);
    updatePlanSyncBadge_();
  }

  // v2.1.90: Plan-sync (wink) must flip on any structural change after a successful upload.
  // Forward-only baseline: rc_planSig is the single source of truth.
  let __planSigObsRows = null;
  let __planSigObsCards = null;
  let __planSigRowsTarget = null;
  let __planSigCardsTarget = null;
  let __planSigDebounceT = null;
  function recheckPlanSig() {
    // Debounced badge refresh (used by MutationObservers + init)
    try { if (__planSigDebounceT) clearTimeout(__planSigDebounceT); } catch(e) {}
    __planSigDebounceT = setTimeout(() => {
      try { updatePlanSyncBadge_(); } catch(e) {}
    }, 60);
  }

  function initPlanSigWatchers() {
    try {
      // (WINK) No doc-level listeners. Watch only row/card structural changes (per-day scope + cards panel).
      const scope = getActiveControlsScope_();
      const hostRows = document.getElementById('controlsTablesHost');
      const targetRows = (scope && scope !== document) ? scope : hostRows;
      const targetCards = document.getElementById('panel');

      if (!window.MutationObserver) { recheckPlanSig(); return; }

      const install_ = (which) => {
        if (which === 'rows') {
          if (!targetRows) return;
          if (__planSigRowsTarget === targetRows && __planSigObsRows) return;
          try { if (__planSigObsRows) __planSigObsRows.disconnect(); } catch(e) {}
          __planSigRowsTarget = targetRows;
          __planSigObsRows = new MutationObserver(() => { try { recheckPlanSig(); } catch(e) {} });
          __planSigObsRows.observe(targetRows, {
            subtree: true,
            childList: true,
            attributes: true,
            attributeFilter: ['data-control','data-control-type','data-day','class','value','checked']
          });
        } else {
          if (!targetCards) return;
          if (__planSigCardsTarget === targetCards && __planSigObsCards) return;
          try { if (__planSigObsCards) __planSigObsCards.disconnect(); } catch(e) {}
          __planSigCardsTarget = targetCards;
          __planSigObsCards = new MutationObserver(() => { try { recheckPlanSig(); } catch(e) {} });
          __planSigObsCards.observe(targetCards, { subtree: true, childList: true, attributes: true, attributeFilter: ['class'] });
        }
      };

      install_('rows');
      install_('cards');

      recheckPlanSig();
    } catch(e) {}
  }

if (ctrlTestTitle) {
    const persistTitle = () => {
      try {
        const t = (ctrlTestTitle.value || '').toString().trim();
        try { const pill = document.getElementById('rallyTitlePill'); if (pill) pill.textContent = t; } catch(e) {}
        if (!saved) saved = {};
        saved.rallyTitle = t;
        saved.rallyName = t;
} catch (e) {  }
    };
    safeOn(ctrlTestTitle,'change', persistTitle);
    // One-way sync: test strip -> page pill only on Enter or blur (prevents re-entrancy "P-sticks").
    safeOn(ctrlTestTitle,'keydown', (e) => {
      if (!e) return;
      const k = e.key || e.code || '';
      if (k === 'Enter') {
        try { e.preventDefault(); } catch(_) {}
        persistTitle();
        syncControlsHeaderFromHost();
      }
    });
    safeOn(ctrlTestTitle,'blur', () => { persistTitle(); syncControlsHeaderFromHost(); });
}
  // Host Day selector wiring (dayPillBtn/dayPillMenu). Card listens and refreshes when host day changes.
  (function bindHostDaySelector_(){
    const dayBtn = document.getElementById('dayPillBtn');
    const dayMenu = document.getElementById('dayPillMenu');
    const dayLbl = document.getElementById('dayPillLabel');

    const applyDay_ = () => {
      syncControlsHeaderFromHost();
      const d = getSelectedDay_();
      selectDayControlsTable(String(d));
      updateButtonStates();
      try { initPlanSigWatchers(); } catch(e) {}
    try { recheckPlanSig(); } catch(e) {}
      try {
        // If connected, re-check Google-side status so lights match selected day.
        if (saved.isConnected && typeof refreshStatusAfterPing === 'function') { Promise.resolve(refreshStatusAfterPing()).then(() => updateButtonStates()).catch(() => {}); }
      } catch(e) {}
    };

    // When a menu item is clicked, host updates label/dataset synchronously; we defer 0ms to be safe.
    safeOn(dayMenu,'click', () => { setTimeout(applyDay_, 0); }, true);

    // Also observe label/dataset changes in case host updates day programmatically.
    try {
      if (dayBtn && window.MutationObserver) {
        const mo = new MutationObserver(() => { setTimeout(applyDay_, 0); });
        mo.observe(dayBtn, { attributes: true, attributeFilter: ['data-day-index'] });
        if (dayLbl) mo.observe(dayLbl, { childList: true, characterData: true, subtree: true });
      }
    } catch(e) {}
  })();

  
  // (v2.1.108) removed initDay1SurnameEdits_ (surname edit support removed)
  // (v2.1.108) removed restoreDay1SurnamesFromSaved_ (surname edit support removed)
  function pickPersisted_(obj) {
    const o = (obj && typeof obj === 'object') ? obj : {};
    const out = {};
    if (o.webAppUrl) out.webAppUrl = String(o.webAppUrl);
    if (o.isConnected !== undefined) out.isConnected = !!o.isConnected;
    if (o.rallyTitle) out.rallyTitle = String(o.rallyTitle);
    if (o.rallyName) out.rallyName = String(o.rallyName);
    if (o.organizerMobile) out.organizerMobile = String(o.organizerMobile);
    if (o.selectedDay !== undefined) out.selectedDay = Number(o.selectedDay) || 1;
    // Demo harness persistence (entrant surnames + rally numbers)
    if (Array.isArray(o.day1Surnames)) out.day1Surnames = o.day1Surnames.map(v => (v==null?'':String(v)));
    if (Array.isArray(o.day1RallyNos)) out.day1RallyNos = o.day1RallyNos.map(v => (v==null?'':String(v)));
    if (Array.isArray(o.entrants)) out.entrants = o.entrants.map(e => ({
      rallyNo: (e && e.rallyNo !== undefined) ? e.rallyNo : '',
      name: (e && e.name !== undefined) ? String(e.name) : ''
    }));
    return out;
  }

// v2.1.210 — legacy COMMON_KEY persistence removed.
// Controls reads Google-world settings from TD_RALLIES (Admin-owned) and keeps any on-page edits session-local.
function __cc_canOverwrite_(el){
  try{ return !(el && document && document.activeElement === el); }catch(_e){ return true; }
try{ window.__TD_CTRL_DAY_SWITCHING = false; }catch(_e){}

}

function primeSavedFromTdCommon_(force){
  try{
    const raw = localStorage.getItem('TD_RALLIES');
    if(!raw) return;
    const td = JSON.parse(raw||'{}') || {};
    const common = (td && td.global && td.global.common) ? td.global.common : {};
    const url = (common && common.webAppUrl) ? String(common.webAppUrl).trim() : '';
    const mob = (common && (common.orgMobile || common.mobile || common.organiserMobile || common.organizerMobile))
      ? String(common.orgMobile || common.mobile || common.organiserMobile || common.organizerMobile).trim()
      : '';

    // Prime from Admin storage. If force=true, accept Admin changes unless user is actively editing the field.
    if (saved && url){
      const can = force ? __cc_canOverwrite_(cmUrlInput) : (!String(saved.webAppUrl || '').trim());
      if (can) saved.webAppUrl = url;
    }
    if (saved && mob){
      const canM = force ? __cc_canOverwrite_(cmMobInput) : (!String(saved.organizerMobile || '').trim());
      if (canM) saved.organizerMobile = mob;
    }
  }catch(_e){}
}

// Read Admin-owned Google settings from legacy standalone key (preferred by current Admin builds)
function primeSavedFromRallyCommonSettings_(force){
  try{
    const raw = localStorage.getItem('rally_common_settings_v1');
    if(!raw) return;
    const o = JSON.parse(raw||'{}') || {};
    const url = (o && o.webAppUrl) ? String(o.webAppUrl).trim() : '';
    const mob = (o && (o.mobile || o.organizerMobile || o.organiserMobile || o.orgMobile || o.organizerMobile))
      ? String(o.mobile || o.organizerMobile || o.organiserMobile || o.orgMobile || o.organizerMobile).trim()
      : '';
    const conn = (o && (o.connected !== undefined)) ? !!o.connected : ((o && (o.isConnected !== undefined)) ? !!o.isConnected : undefined);

    // Prime from legacy common settings. If force=true, accept Admin changes unless user is actively editing the field.
    if (saved && url){
      const can = force ? __cc_canOverwrite_(cmUrlInput) : (!String(saved.webAppUrl || '').trim());
      if (can) saved.webAppUrl = url;
    }
    if (saved && mob){
      const canM = force ? __cc_canOverwrite_(cmMobInput) : (!String(saved.organizerMobile || '').trim());
      if (canM) saved.organizerMobile = mob;
    }
    if (saved && (saved.isConnected === undefined) && (conn !== undefined)) saved.isConnected = conn;
  }catch(_e){}
}

function getBaseUrl_() {
  const fromSaved = (saved && (saved.webAppUrl || '').toString().trim()) || '';
  return normalizeWebAppUrl_(fromSaved);
}

function normalizeWebAppUrl_(u) {
  const raw = (u || '').toString().trim();
  if (!raw) return '';
  // Only accept absolute http(s) URLs; never allow relative 'exec' fallbacks.
  if (!/^https?:\/\//i.test(raw)) return '';
  // Strip any query/hash from base; keep only the path.
  let base = raw.split('#')[0];
  base = base.split('?')[0];
  // Normalise /dev deployments to /exec for production calls.
  base = base.replace(/\/(dev)\/?$/i, '/exec');
  // Ensure it ends with /exec
  if (!/\/exec$/i.test(base)) base = base.replace(/\/+$/,'') + '/exec';
  return base;
}
primeSavedFromTdCommon_(false);
primeSavedFromRallyCommonSettings_(false);

// v2.1.262 — Live refresh Admin-owned Web App URL while Controls is open
(function(){
  try{
    window.addEventListener('storage', function(ev){
      try{
        if(!ev) return;
        if(ev.key !== 'TD_RALLIES' && ev.key !== 'rally_common_settings_v1') return;

        const beforeUrl = String(saved.webAppUrl||'');
        const beforeMob = String(saved.organizerMobile||'');
        const beforeConn = (saved && saved.isConnected !== undefined) ? !!saved.isConnected : undefined;

        primeSavedFromTdCommon_(true);
        primeSavedFromRallyCommonSettings_(true);

        // Re-sync pills + connection state if Admin changed them
        try{ syncCommonPills_(); }catch(_e){}
        try{
          const nowUrl = String(saved.webAppUrl||'');
          const nowMob = String(saved.organizerMobile||'');
          const nowConn = (saved && saved.isConnected !== undefined) ? !!saved.isConnected : undefined;

          if((nowUrl !== beforeUrl) || (nowMob !== beforeMob) || (nowConn !== beforeConn)){
            // If URL changed from Admin, treat as "saved" until user runs Save & test again.
            if(nowUrl !== beforeUrl && saved) saved.isConnected = false;
            try{ setConnectionStatus(saved && saved.isConnected ? 'connected' : 'saved'); }catch(_e){}
          }
        }catch(_e){}
      }catch(_e){}
    });
    try{ window.addEventListener('resize', sstScheduleStartStripLeftFix_, {passive:true}); }catch(_e){}
  }catch(_e){}
})();


const _legacyHasControls = !!saved.hasControlsData;
  const _legacyEntrantUrl = saved.entrantFormUrl || '';
  const _legacyMarshalUrl = saved.marshalFormUrl || '';
  const _legacyResponsesUrl = saved.responsesFolderUrl || '';
  // On first load, do not trust cached data-exists flags; backend will confirm.
saved.hasControlsData = false;
  
  // Day-scoped flags/URLs for Controls card are kept in `live` only (status-only render).
  // Seed Day 1 from legacy single-value keys (back-compat) so Day 1 lights up without an upload.
  const _isEmptyMap = (m) => !m || (typeof m === 'object' && Object.keys(m).length === 0);
  if (_isEmptyMap(live.hasControlsDataByDay) && (_legacyHasControls || _legacyEntrantUrl || _legacyMarshalUrl)) {
    live.hasControlsDataByDay = { "1": true };
    // Back-compat: infer type-specific presence from legacy URLs when possible
    live.hasStcDataByDay = { "1": !!_legacyEntrantUrl || !!_legacyHasControls };
    live.hasMarshalDataByDay = { "1": !!_legacyMarshalUrl || !!_legacyHasControls };
  }
  if (_isEmptyMap(live.entrantFormUrlByDay) && _legacyEntrantUrl) {
    live.entrantFormUrlByDay = { "1": _legacyEntrantUrl };
  }
  if (_isEmptyMap(live.marshalFormUrlByDay) && _legacyMarshalUrl) {
    live.marshalFormUrlByDay = { "1": _legacyMarshalUrl };
  }
  if (_isEmptyMap(live.responsesFolderUrlByDay) && _legacyResponsesUrl) {
    live.responsesFolderUrlByDay = { "1": _legacyResponsesUrl };
  }

let connectionStatusTimer = null;
  function updateButtonStates() {
    const hostTitle = (getHostRallyTitle_() || (ctrlTestTitle ? (ctrlTestTitle.value || '').trim() : ''));
        const connected = !!saved.isConnected && isValidRallyName_(hostTitle);

    // From status bells / script
const activeDay = getSelectedDay_();
    const hasStcDay = !!(live && live.hasStcDataByDay && live.hasStcDataByDay[String(activeDay)]);
    const hasMarshalDay = !!(live && live.hasMarshalDataByDay && live.hasMarshalDataByDay[String(activeDay)]);
    const hasControlsDataDay = !!(live && live.hasControlsDataByDay && live.hasControlsDataByDay[String(activeDay)]) || hasStcDay || hasMarshalDay;
    const hasControlsData = hasControlsDataDay;

    // Day-scoped form URLs (status-only)
    const entrantUrl = (live && live.entrantFormUrlByDay && live.entrantFormUrlByDay[activeDay]) || '';
    const marshalUrl = (live && live.marshalFormUrlByDay && live.marshalFormUrlByDay[activeDay]) || '';
    const responsesUrl = (live && live.responsesFolderUrlByDay && live.responsesFolderUrlByDay[activeDay]) || '';

        const responsesRootUrl = (saved && saved.responsesRootFolderUrl) || '';

        // Controls card share buttons: day-ready (URLs are fetched lazily on click)
    const entrantReady = connected && hasStcDay;
    const marshalReady = connected && hasMarshalDay;
function setButtonState(btn, on) {
      if (!btn) return;
      if (on) {
        btn.classList.remove('off');
        btn.disabled = false;
      } else {
        btn.classList.add('off');
        btn.disabled = true;
      }
    }

    // Upload button: only depends on connection
    setButtonState(uploadControlsBtn, connected);

    // View Responses (Controls card) – only when we have a folder URL for this day
    setButtonState(viewResponsesBtn, connected && !!(responsesRootUrl || responsesUrl));

    // Open / Download data buttons

      // In Controls view, they are "Open/Download controls"
      setButtonState(openControlsBtn, connected && hasControlsData);
      setButtonState(downloadControlsBtn, connected && hasControlsData);

    // Entrant link share buttons (Controls card)
    const entrantButtons = [entrantCopyBtn, entrantEmailBtn, entrantWABtn];
    entrantButtons.forEach(btn => setButtonState(btn, entrantReady));

    // Marshal link share buttons (Controls card)
    const marshalButtons = [marshalCopyBtn, marshalEmailBtn, marshalWABtn];
    marshalButtons.forEach(btn => setButtonState(btn, marshalReady));
}

function toastClear() {
    if (!toast) return;
    try { if (toastTimer) { clearTimeout(toastTimer); toastTimer = 0; } } catch(e) {}
    toast.innerHTML = '';
    toast.classList.remove('show');
  }

function toastSet(message, sticky, wave) {
    if (!toast) return;
    const msg = (message || '').toString();

    // Always cancel any prior auto-hide timer so one click always wins
    try { if (toastTimer) { clearTimeout(toastTimer); toastTimer = 0; } } catch(e) {}

    if (!msg) {
      toast.innerHTML = '';
      toast.classList.remove('show');
      return;
    }

    const waveHtml = wave ? '<span class="wave-dots" aria-hidden="true"><i></i><i></i><i></i><i></i><i></i></span>' : '';
    toast.innerHTML = msg + (waveHtml ? (' ' + waveHtml) : '');
    toast.classList.add('show');

    if (!sticky) {
      toastTimer = setTimeout(() => {
        toast.classList.remove('show');
        toastTimer = 0;
      }, 2200);
    }
  }

// Click/tap toast to dismiss immediately
try { if (toast) toast.addEventListener('pointerdown', toastClear, { capture: true }); } catch(e) {}

  
  function pop(message) {
    toastSet(message, false, false);
  }

  
  function setConnectionStatus(state, message) {
    if (!connectionStatusEl) return;

    let label = 'Not connected';
    let cls = 'warn';

    if (state === 'connected') {
      label = 'Connected';
      cls = 'ok';
    } else if (state === 'saved') {
      label = 'Saved, not tested';
      cls = 'warn';
    } else {
      label = 'Not connected';
      cls = 'warn';
    }

    if (message) {
      label = message;
    }

    connectionStatusEl.textContent = label;
    connectionStatusEl.classList.remove('ok', 'warn', 'bad');
    connectionStatusEl.classList.add(cls);

    if (connectionStatusTimer) {
      clearTimeout(connectionStatusTimer);
    }
    if (state === 'saved') {
      connectionStatusTimer = setTimeout(() => {
        setConnectionStatus(saved.isConnected ? 'connected' : 'saved');
      }, 2000);
    }
    updateButtonStates();
  }

  function readFormState() {
    const data = {};
    data.webAppUrl = (cmUrlInput && (cmUrlInput.value || '').toString().trim()) || '';
    if (ctrlTestTitle) {
      data.rallyTitle = (ctrlTestTitle.value || '').trim();
    }
    if (data.rallyTitle) data.rallyName = data.rallyTitle;
    data.organizerMobile = (cmMobInput && (cmMobInput.value || '').toString().trim()) || '';
    // Persist selected day (UI convenience only)
    if (ctrlTestDay) data.day = (ctrlTestDay.value || '').trim();
    return data;
  }

function restoreFromSaved() {
    if (!saved) saved = {};

    // Pull common settings (Admin is single source)
    primeSavedFromTdCommon_();
    primeSavedFromRallyCommonSettings_();
    // Ensure topbar pills reflect saved common settings (URL + mobile)
    syncCommonPills_();
    if (ctrlTestTitle && saved.rallyTitle) {
      ctrlTestTitle.value = saved.rallyTitle;
      syncControlsHeaderFromHost();
    }
    if (saved.isConnected) {
      setConnectionStatus('connected');
      // On load, ask backend for status of current rally name so lights match Google world.
      try {
        if (typeof refreshStatusAfterPing === 'function') {
          refreshStatusAfterPing();
        }
      } catch (e) {
        }
    } else if (getBaseUrl_()) {
      setConnectionStatus('saved');
    } else {
      setConnectionStatus('disconnected');
    }
    updateButtonStates();
    // Restore selected day (UI only)
    if (ctrlTestDay && saved && saved.selectedDay) { ctrlTestDay.value = String(saved.selectedDay); }
  }

  function handleSaveAndTest() {
    // Controls-only pages may not have the legacy Admin inputs; fall back to the header pills.
    const urlInput = cmUrlInput;
    const mobInput = cmMobInput;
    if (!urlInput) return Promise.resolve();

    const url = (urlInput.value || '').trim();
    if (!url) {
      pop('Paste your Web App URL first');
      setConnectionStatus('disconnected');
      return Promise.resolve();
    }

    // Persist shared settings (so Controls/Admin pages can stay independent)
    const mob = (mobInput && mobInput.value ? String(mobInput.value).trim() : '');
    const nurl = normalizeWebAppUrl_(url);
    if (!nurl) {
      showToast('Invalid Google world URL');
      setConnectionStatus('disconnected');
      return Promise.resolve();
    }
    saved.webAppUrl = nurl; saved.organizerMobile = mob; syncCommonPills_();

    saved = readFormState();
    saved.isConnected = false;
setConnectionStatus('saved', 'Testing…');

    return fetch(url, { method: 'GET', redirect: 'follow' })
      .then((res) => {
        if (!res.ok) throw new Error('HTTP ' + res.status);
        // Some deployments return plain text; treat non-JSON as success if HTTP 200.
        return res.json().catch(() => null);
      })
      .then((json) => {
        if (json && json.ok === false) {
          saved.isConnected = false;
setConnectionStatus('disconnected', json.error || 'Script responded with ok: false');
          pop('Script reachable but returned an error payload');
          return;
        }

        saved.isConnected = true;
setConnectionStatus('connected', (json && json.message) || 'Connected');
        pop('Google script is reachable');

        // After a successful ping, ring Admin + Controls status bells
        return Promise.resolve(refreshStatusAfterPing());
      })
      .catch((err) => {
        saved.isConnected = false;
setConnectionStatus('disconnected', 'Ping failed');
        pop('Ping failed – check Web App URL & deployment');
      });
  }
  function refreshStatusAfterPing() {
    const baseUrl = getBaseUrl_();
    if (!baseUrl) return Promise.resolve();

    // Derive rally name from Admin test title or Controls rally pill
        const rallyName = (getHostRallyTitle_() || (ctrlTestTitle ? (ctrlTestTitle.value || '').trim() : '') || '').trim();

    // Guard: placeholder / empty rally name => no ping (prevents \"Rally Title\" default causing confusion)
    if (!isValidRallyName_(rallyName)) {
      try { toastSet('', false, false); } catch(e) {}
      try {
        live.hasControlsDataByDay = {};
        live.hasStcDataByDay = {};
        live.hasMarshalDataByDay = {};
        live.entrantFormUrlByDay = {};
        live.marshalFormUrlByDay = {};
        live.responsesFolderUrlByDay = {};
      } catch(e) {}
      updateButtonStates();
      if (!badTitleWarned) { badTitleWarned = true; toast('Enter a rally title'); }
      return Promise.resolve();
    }
    badTitleWarned = false;

    if (!saved) {
      saved = readFormState();
    }

    saved.hasControlsData = false;
    live.hasControlsDataByDay = {};
    live.hasStcDataByDay = {};
    live.hasMarshalDataByDay = {};
    live.entrantFormUrlByDay = {};
    live.marshalFormUrlByDay = {};
    live.responsesFolderUrlByDay = {};

    const selDay = (getHostDayNum_() || (ctrlTestDay ? String(ctrlTestDay.value || '1') : '1'));

    const controlsQs = 'mode=controlsStatus&rallyName=' + encodeURIComponent(rallyName) + '&day=' + encodeURIComponent(selDay);
    const controlsUrl = baseUrl.includes('?') ? (baseUrl + '&' + controlsQs) : (baseUrl + '?' + controlsQs);

    // Busy toast while we ping Google-world status
    try { toastSet('Connecting', true, true); } catch(e) {}

    return fetch(controlsUrl, { method: 'GET', redirect: 'follow' })
      .then((controlsRes) => {
        if (!(controlsRes && controlsRes.ok)) return null;
        return controlsRes.json().catch(() => null);
      })
      .then((cj) => {
        if (cj && cj.ok) {
          
          // v2.1.81 — promote to Connected on successful controlsStatus ping (Admin-truth via COMMON)
          try { saved.isConnected = true; } catch(e) {}
          try {
} catch(e) {}
          try { setConnectionStatus('connected', 'Connected'); } catch(e) {}
if (cj.spreadsheetUrl && !saved.spreadsheetUrl) {
            saved.spreadsheetUrl = cj.spreadsheetUrl;
          }
          // Controls status can be global and/or day-scoped (preferred).
          // Strict-gate rule: OFF unless backend explicitly proves ON.
          saved.hasControlsData = !!cj.hasControlsData;

          let nextByDay = {};
          if (cj.hasControlsDataByDay && typeof cj.hasControlsDataByDay === 'object') {
            for (const [k, v] of Object.entries(cj.hasControlsDataByDay)) {
              nextByDay[k] = !!v;
            }
          } else if (typeof selDay === 'string') {
            nextByDay[selDay] = !!cj.hasControlsData;
          }
          live.hasControlsDataByDay = nextByDay;

          // Type-specific presence (STC vs Marshal).
          // Preferred: explicit maps from backend; fallback: infer from presence of returned form URLs.
          const stcMap = {};
          const marshalMap = {};

          if (cj.hasStcDataByDay && typeof cj.hasStcDataByDay === 'object') {
            for (const [k, v] of Object.entries(cj.hasStcDataByDay)) stcMap[k] = !!v;
          }
          if (cj.hasMarshalDataByDay && typeof cj.hasMarshalDataByDay === 'object') {
            for (const [k, v] of Object.entries(cj.hasMarshalDataByDay)) marshalMap[k] = !!v;
          }

          // If explicit maps absent, infer from URLs provided for the selected day
          if (Object.keys(stcMap).length === 0 && typeof selDay === 'string') {
            const stcUrl = (cj.entrantFormUrl || '') || ((cj.entrantFormUrlByDay && cj.entrantFormUrlByDay[selDay]) || '');
            stcMap[selDay] = !!stcUrl && !!(nextByDay[selDay]);
          }
          if (Object.keys(marshalMap).length === 0 && typeof selDay === 'string') {
            const mUrl = (cj.marshalFormUrl || '') || ((cj.marshalFormUrlByDay && cj.marshalFormUrlByDay[selDay]) || '');
            marshalMap[selDay] = !!mUrl && !!(nextByDay[selDay]);
          }

          live.hasStcDataByDay = stcMap;
          live.hasMarshalDataByDay = marshalMap;

          // Ensure overall by-day flag reflects either stream (prevents "both off" when backend sends split)
          try {
            const merged = {};
            const keys = new Set(Object.keys(nextByDay || {}).concat(Object.keys(stcMap || {})).concat(Object.keys(marshalMap || {})));
            keys.forEach(k => {
              merged[k] = !!(stcMap && stcMap[k]) || !!(marshalMap && marshalMap[k]) || !!(nextByDay && nextByDay[k]);
            });
            live.hasControlsDataByDay = merged;
          } catch(e) {}

          // Day-scoped single-value URLs (preferred over legacy singletons)
          if (cj.entrantFormUrl && typeof selDay === 'string') {
            live.entrantFormUrlByDay[selDay] = String(cj.entrantFormUrl);
            saved.entrantFormUrl = String(cj.entrantFormUrl);
          }
          if (cj.marshalFormUrl && typeof selDay === 'string') {
            live.marshalFormUrlByDay[selDay] = String(cj.marshalFormUrl);
            saved.marshalFormUrl = String(cj.marshalFormUrl);
          }
          if (cj.responsesFolderUrl && typeof selDay === 'string') {
            live.responsesFolderUrlByDay[selDay] = String(cj.responsesFolderUrl);
            saved.responsesFolderUrl = String(cj.responsesFolderUrl);
          }

          // Full day maps if provided
          if (cj.entrantFormUrlByDay && typeof cj.entrantFormUrlByDay === 'object') {
            live.entrantFormUrlByDay = { ...(live.entrantFormUrlByDay || {}), ...cj.entrantFormUrlByDay };
          }
          if (cj.marshalFormUrlByDay && typeof cj.marshalFormUrlByDay === 'object') {
            live.marshalFormUrlByDay = { ...(live.marshalFormUrlByDay || {}), ...cj.marshalFormUrlByDay };
          }
          if (cj.responsesFolderUrlByDay && typeof cj.responsesFolderUrlByDay === 'object') {
            live.responsesFolderUrlByDay = { ...(live.responsesFolderUrlByDay || {}), ...cj.responsesFolderUrlByDay };
          }

          if (cj.responsesFolderUrl) {
            saved.responsesFolderUrl = cj.responsesFolderUrl;
          }
          if (cj.responsesRootFolderUrl) {
            saved.responsesRootFolderUrl = String(cj.responsesRootFolderUrl);
          }
          if (cj.responsesFolderId && !saved.responsesFolderUrl) {
            saved.responsesFolderUrl = 'https://drive.google.com/drive/folders/' + String(cj.responsesFolderId);
          }
        }
updateButtonStates();
      })
      .catch((err) => {
        // keep silent; errors already reflected by button states
      })
      .finally(() => { try { toastSet('', false, false); } catch(e) {} });
  }
  function ensureFormLinks() {
    // Prefer day-scoped URLs from live status; fall back to legacy saved.* for Day 1 back-compat.
    const dayKey = String(getSelectedDay_() || 1);
    const entrantFormUrl = (live && live.entrantFormUrlByDay && live.entrantFormUrlByDay[dayKey]) || (saved && saved.entrantFormUrl) || '';
    const marshalFormUrl = (live && live.marshalFormUrlByDay && live.marshalFormUrlByDay[dayKey]) || (saved && saved.marshalFormUrl) || '';

    if (!entrantFormUrl && !marshalFormUrl) {
      pop('Upload control data first');
      return null;
    }

    return { entrantFormUrl, marshalFormUrl };
  }

  function openMailWith(subject, body) {
    const href = 'mailto:?subject=' + encodeURIComponent(subject) +
      '&body=' + encodeURIComponent(body);
    window.location.href = href;
  }
  function openWhatsAppWith(message) {
    const common = (function(){
      try { return JSON.parse(localStorage.getItem('rally_common_settings_v1') || '{}') || {}; } catch(_){ return {}; }
    })();

    // Prefer the card/mobile input if present, but do not depend on it.
    let raw = '';
    if (cmMobInput && cmMobInput.value) raw = (cmMobInput.value || '').toString();
    if (!raw) raw = (((common.mobile ?? common.orgMobile ?? '') + '') || '').toString();

    // Keep the card input in sync for visibility, if it exists.
    if (cmMobInput && raw && !cmMobInput.value) cmMobInput.value = raw;

    const phone = raw.replace(/\D/g, '');
    if (!phone) {
      pop('Add organiser mobile number first');
      return;
    }

    // Use wa.me deep link; if popups are blocked, fall back to same-tab navigation.
    const href = 'https://wa.me/' + phone + '?text=' + encodeURIComponent(message);
    const w = window.open(href, '_blank');
    if (!w) {
      pop('Popup blocked — opening WhatsApp');
      window.location.href = href;
      return;
    }
    pop('WhatsApp opened');
  }

  
  function formatSheetTime(value) {
    if (value === null || value === undefined || value === '') return '';
    if (typeof value === 'string') {
      // If Apps Script has given us an ISO-like string, pull out the HH:MM:SS part
      const tIndex = value.indexOf('T');
      if (tIndex !== -1 && value.length >= tIndex + 9) {
        return value.slice(tIndex + 1, tIndex + 9);
      }
      return value;
    }
    return String(value);
  }

// Busy label: wavy five-dots (shared by Upload + Download)
function startWaveDots(btn, baseLabel) {
  if (!btn) return;
  const label = baseLabel || 'Working';

  // Lock width to avoid layout shift
  try {
    if (!btn.dataset.lockedWidth) {
      const w = Math.ceil(btn.getBoundingClientRect().width);
      btn.style.minWidth = w + 'px';
      btn.dataset.lockedWidth = String(w);
    }
  } catch(e) {}

  if (!btn.dataset.originalLabel) {
    btn.dataset.originalLabel = (btn.textContent || '').trim() || label;
  }

  btn.classList.add('has-wave');
  btn.innerHTML = '<span class="btn-label">' + label + '</span>' +
    '<span class="wave-dots" aria-hidden="true"><i></i><i></i><i></i><i></i><i></i></span>';
}

function stopWaveDots(btn) {
  if (!btn) return;
  const label = btn.dataset.originalLabel || btn.textContent || '';
  btn.classList.remove('has-wave');
  btn.textContent = label;

  // Keep minWidth locked while busy toggles; clear only when fully idle
  try {
    if (!btn.classList.contains('busy')) {
      btn.style.minWidth = '';
      delete btn.dataset.lockedWidth;
    }
  } catch(e) {}
}

function ensureDayMaps_(saved) {
    if (!saved || typeof saved !== 'object') return;
    live.hasControlsDataByDay = live.hasControlsDataByDay || {};
    live.hasStcDataByDay = live.hasStcDataByDay || {};
    live.hasMarshalDataByDay = live.hasMarshalDataByDay || {};
    live.entrantFormUrlByDay = live.entrantFormUrlByDay || {};
    live.marshalFormUrlByDay = live.marshalFormUrlByDay || {};
    live.responsesFolderUrlByDay = live.responsesFolderUrlByDay || {};
  }

  function uploadControlsData() {
    // Prefer shared/common stored URL (Admin-owned) over the local textbox.
    const baseUrl = (getBaseUrl_ && getBaseUrl_()) || ((cmUrlInput && (cmUrlInput.value || '').trim()) || '');
    if (!baseUrl) {
      pop('Paste your Web App URL first');
      return Promise.resolve();
    }

    if (uploadControlsBtn) {
      uploadControlsBtn.classList.add('busy');
      startWaveDots(uploadControlsBtn, 'Uploading');
    }

    const rallyName = (getHostRallyTitle_() || (ctrlTestTitle ? (ctrlTestTitle.value || '').trim() : '') || (cdRallyTitlePill ? (cdRallyTitlePill.textContent || '').trim() : '') || 'Rally');
    const dateLabel = (getHostDayLabel_() || (ctrlTestDatePill ? (ctrlTestDatePill.textContent || '').trim() : ''));

    const payload = {
      rallyName,
      rallyTitle: rallyName,
      rallyDateLabel: dateLabel
    };

    // Entrants list: prefer Admin-owned shared JSON (rally numbers + surnames) and fall back to legacy driver list for testing.
// Sent to Code.gs so STC tabs can include names (surname = STC-only conceptually).
    const entrants = [];
    try {
      // Build a surname map from TD_RALLIES (canonical, Admin-owned)
      const surnameByNo = {};
      try {
        const rawTd = localStorage.getItem('TD_RALLIES');
        if (rawTd) {
          const td = JSON.parse(rawTd);
          const rid = (td && td.global && (td.global.activeRallyId || td.global.lastRallyId)) ? (td.global.activeRallyId || td.global.lastRallyId) : null;
          const rows = (rid && td && td.rallies && td.rallies[rid] && td.rallies[rid].admin && td.rallies[rid].admin.controls && Array.isArray(td.rallies[rid].admin.controls.entries))
            ? td.rallies[rid].admin.controls.entries
            : [];
          if (rows && rows.length) {
            rows.forEach((r) => {
              const rn = Number(r && r.rallyNo);
              if (!Number.isFinite(rn) || rn < 1) return;
              const s = (r && typeof r.driverSurname === 'string') ? r.driverSurname.trim() : '';
              if (s) surnameByNo[String(rn)] = s;
            });
          }
        }
      } catch (e) {}

      // Prefer using the canonical roster order if available, else fall back to legacy driver list order.
      const ctx = (typeof _getTdCtx_ === 'function') ? _getTdCtx_() : null;
      const roster = (ctx && ctx.rally && ctx.rally.admin && ctx.rally.admin.controls && Array.isArray(ctx.rally.admin.controls.entries))
        ? ctx.rally.admin.controls.entries
        : null;

      if (roster && roster.length) {
        roster.slice().sort((a,b) => (Number(a && a.rallyNo) || 0) - (Number(b && b.rallyNo) || 0))
          .forEach((r) => {
            const rn = Number(r && r.rallyNo);
            if (!Number.isFinite(rn) || rn < 1) return;
            const key = String(rn);
            const s = surnameByNo[key] || ((r && typeof r.driverSurname === 'string') ? r.driverSurname.trim() : '');
            entrants.push({ rallyNo: key, name: (s || ''), driverSurname: (s || '') });
          });
      } else {
        const drivers = (window.__sstLive && typeof window.__sstLive.getDrivers === 'function')
          ? (window.__sstLive.getDrivers() || [])
          : (model && Array.isArray(model.drivers) ? model.drivers : []);
        const n = drivers.length || (model && Number.isFinite(model.rows) ? model.rows : 0);
        for (let i = 1; i <= n; i++) {
          const raw = drivers[i - 1] != null ? String(drivers[i - 1]).trim() : '';
          // treat placeholders like "#1" as blank
          const legacyName = (/^#\d+$/.test(raw) ? '' : raw);
          const key = String(i);
          const s = surnameByNo[key] || '';
          // Code.gs/STC expects surname as the required identifier; keep legacyName available only as a display fallback.
          entrants.push({ rallyNo: key, name: (s || legacyName || ''), driverSurname: (s || '') });
        }
      }
    } catch (e) {}
    payload.entrantsCount = entrants.length;
    payload.entrants = entrants;

        // v2.1.81 — Marshal ETA windows (first/last car) for Code.gs to embed on the shared Marshal form
    // Harvest DIRECTLY from DOM using proven selector:
    //   .stcm-card[data-card-id="marshal-N"] .cell.kind-eta .etaText
    // Include payload.marshalWindows + payload.marshalWindowsText even if empty.
    try {
      let marshalWindowsFinal = [];

      // 1) Primary: DOM harvest
      try {
        const marshalWindows = [];

        const cards = Array.from(document.querySelectorAll('.stcm-card[data-card-id^="marshal-"]'))
          .sort((a,b)=>{
            const an = parseInt((a.getAttribute('data-card-id')||'').split('-')[1]||'0',10) || 0;
            const bn = parseInt((b.getAttribute('data-card-id')||'').split('-')[1]||'0',10) || 0;
            return an - bn;
          });

        cards.forEach(cardEl => {
          if (!cardEl) return;
          if (cardEl.classList.contains('excluded')) return;

          const cardIdRaw = (cardEl.getAttribute('data-card-id') || '').trim(); // marshal-N
          const mm = cardIdRaw.match(/^marshal-(\d+)$/i);
          const id = mm ? ('m' + mm[1]) : cardIdRaw;

          const headTitleEl = cardEl.querySelector('.card-head .title');
          const label = headTitleEl ? String(headTitleEl.textContent||'').trim() : ('Marshal ' + (marshalWindows.length + 1));

          const etaEls = Array.from(cardEl.querySelectorAll('.cell.kind-eta .etaText'));
          const etas = etaEls.map(el => (el && el.textContent ? String(el.textContent).trim() : '')).filter(Boolean);

          // Accept HH:MM:SS as-is (no strict normalisation here)
          const firstEta = etas.length ? etas[0] : '';
          const lastEta  = etas.length ? etas[etas.length - 1] : '';
          if (!firstEta || !lastEta) return;

          marshalWindows.push({ id, label, firstEta, lastEta });
        });

        if (marshalWindows.length) {
          marshalWindowsFinal = marshalWindows;

          // Persist day-scoped marshal windows for dev/test reloads
          try {
            const dayKey = String(getSelectedDay_() || 1);
            const winsByNo = {};
            marshalWindows.forEach((w, i) => {
              const no = String(i + 1);
              winsByNo[no] = { startEta: w.firstEta, endEta: w.lastEta };
            });
            sstSaveMarshalWinsForDay(dayKey, winsByNo);
          } catch (e) {}
        }
      } catch (e) {}

      if (!marshalWindowsFinal.length) {
        try {
          const dayKey = String(getSelectedDay_() || 1);
          const winsByNo = sstLoadMarshalWinsForDay(dayKey);
          const keys = winsByNo ? Object.keys(winsByNo) : [];
          if (keys.length) {
            const marshalWindows2 = keys.sort((a,b)=>Number(a)-Number(b)).map(k => ({
              id: 'm' + k,
              label: 'Marshal ' + k,
              firstEta: String((winsByNo[k] && winsByNo[k].startEta) || '').trim(),
              lastEta: String((winsByNo[k] && winsByNo[k].endEta) || '').trim()
            })).filter(w => w.firstEta && w.lastEta);

            if (marshalWindows2.length) marshalWindowsFinal = marshalWindows2;
          }
        } catch (e) {}
      }

      // Always include fields in payload (even if empty)
      payload.marshalWindows = marshalWindowsFinal;
      payload.marshalWindowsText = marshalWindowsFinal
        .map(w => (w.label + ' — ' + w.firstEta + ' – ' + w.lastEta))
        .join('\n');

    } catch (e) {}

// keep local saved copy aligned for reloads
    try {
      if (!saved) saved = {};
      saved.entrants = entrants;
      saved.day1Surnames = entrants.map(e => (e && e.name) ? String(e.name) : '');
      saved.day1RallyNos = entrants.map(e => (e && e.rallyNo) ? String(e.rallyNo) : '');
      try {
} catch(e) {}
    } catch (e) {}

    // Build day-scoped controls list for Code.gs (parsed.days[].controls[])
    const dayNum = getSelectedDay_();
    const controls = [];
    const seenIds = new Set();

    // Normalise to v1.56 schema: id (stc1/stc2..., m1/m2...), type lowercase, enabled:true
    function normControl_(idRaw, typeRaw, labelRaw){
      let type = (typeRaw || '').toString().trim().toLowerCase();
      if (type === 'start stc') type = 'stc';
      if (type === 'open control') type = 'open';
      if (type !== 'stc' && type !== 'marshal' && type !== 'open') return null;

      let id = (idRaw || '').toString().trim();
      // Map common live ids
      let m;
      if ((m = id.match(/^stc-(\d+)$/i))) id = 'stc' + m[1];
      else if ((m = id.match(/^marshal-(\d+)$/i))) id = 'm' + m[1];
      else if ((m = id.match(/^open-(\d+)$/i))) id = 'oc' + m[1];
      else if ((m = id.match(/^oc-?(\d+)$/i))) id = 'oc' + m[1];
      // If already in v1.56 style, keep but normalise case
      id = id.toLowerCase();
      if (!id) return null;

      const label = (labelRaw || '').toString().trim() || id;
      return { id, type, label, enabled: true };
    }

    function pushControl_(obj){
      if (!obj || !obj.id) return;
      if (seenIds.has(obj.id)) return;
      seenIds.add(obj.id);
      controls.push(obj);
    }

    // Preferred: live card state (what the UI is actually showing)
    try{
      const liveCards = (window.__sstLive && typeof window.__sstLive.getCards === 'function') ? window.__sstLive.getCards() : null;
      if (Array.isArray(liveCards) && liveCards.length){
        liveCards.forEach(c => {
          if (!c) return;
          const obj = normControl_(c.id, c.type, (c.name || c.label || c.type));
          pushControl_(obj);
        });
      }
    }catch(e){}

    if (!controls.length) {
      const dayScope = document.querySelector('.controls-day-table[data-day="' + dayNum + '"]');

      if (dayScope) {
        const headers = dayScope.querySelectorAll('th[data-control][data-type]');
        headers.forEach(th => {
          const id = th.getAttribute('data-control') || '';
          const type = th.getAttribute('data-type') || '';
          const label = th.textContent ? th.textContent.trim() : id;
          const obj = normControl_(id, type, label);
          pushControl_(obj);
        });
      }
    }

payload.days = [{ day: dayNum, controls }];

    // Remember what we actually sent so we can light the correct buttons immediately on HTTP 200
    const sentHasStc = controls.some(c => (c && c.type === 'stc'));
    const sentHasMarshal = controls.some(c => (c && c.type === 'marshal'));
    const sentPlanSig = (typeof computePlanSig === 'function') ? computePlanSig() : (controls.map(c => (c && c.id) ? String(c.id) : '').filter(Boolean).join('|'));

    const qs = 'mode=uploadControls&day=' + encodeURIComponent(String(dayNum)) + '&data=' + encodeURIComponent(JSON.stringify(payload));
    const url = baseUrl.includes('?') ? (baseUrl + '&' + qs) : (baseUrl + '?' + qs);

    return fetch(url, { method: 'GET', redirect: 'follow' })
      .then((res) => {
        if (!res.ok) throw new Error('HTTP ' + res.status);
        return res.json().catch(() => null);
      })
      .then((json) => {
        if (json && json.ok) {
          // v2.2.321 — store-only: record last Upload Control Data use (short date + HH:MM:SS)
          try {
            const root = JSON.parse(localStorage.getItem('TD_RALLIES') || '{}') || {};
            const rid = (root?.global?.activeRallyId || root?.global?.lastRallyId || '');
            if (rid && root?.rallies?.[rid]) {
              const r = root.rallies[rid];
              r.controls = r.controls || {};
              r.controls.google = r.controls.google || {};
              const now = new Date();
              const dd = String(now.getDate()).padStart(2,'0');
              const mon = now.toLocaleString(undefined,{ month:'short' });
              const hh = String(now.getHours()).padStart(2,'0');
              const mm = String(now.getMinutes()).padStart(2,'0');
              const ss = String(now.getSeconds()).padStart(2,'0');
              r.controls.google.lastUploadAt = `${dd} ${mon} ${hh}:${mm}:${ss}`;
              localStorage.setItem('TD_RALLIES', JSON.stringify(root));
            }
          } catch(e) {}

          // Adopt any URLs returned by the script
          if (json.responsesFolderUrl) saved.responsesFolderUrl = json.responsesFolderUrl;
          if (json.responsesRootFolderUrl) saved.responsesRootFolderUrl = String(json.responsesRootFolderUrl);
          if (json.responsesFolderId && !saved.responsesFolderUrl) {
            saved.responsesFolderUrl = 'https://drive.google.com/drive/folders/' + String(json.responsesFolderId);
          }
          if (json.entrantFormUrl) saved.entrantFormUrl = json.entrantFormUrl;
          if (json.marshalFormUrl) saved.marshalFormUrl = json.marshalFormUrl;
          if (json.spreadsheetUrl) saved.spreadsheetUrl = json.spreadsheetUrl;

          // Update live (ephemeral) day-scoped status immediately (no need to close/reopen card)
          try {
            const dKey = String(dayNum);
            ensureDayMaps_(saved);
            live.hasStcDataByDay[dKey] = !!sentHasStc;
            live.hasMarshalDataByDay[dKey] = !!sentHasMarshal;
            live.hasControlsDataByDay[dKey] = !!sentHasStc || !!sentHasMarshal;

            if (json.entrantFormUrl) live.entrantFormUrlByDay[dKey] = String(json.entrantFormUrl);
            if (json.marshalFormUrl) live.marshalFormUrlByDay[dKey] = String(json.marshalFormUrl);
            if (json.responsesFolderUrl) live.responsesFolderUrlByDay[dKey] = String(json.responsesFolderUrl);
          } catch(e) {}
updateButtonStates();
          try { markPlanUploaded_(dayNum, sentPlanSig); } catch(e) {}
          // Also pull authoritative backend status so any derived URLs/flags align with Google world
          try { Promise.resolve(refreshStatusAfterPing()).then(() => { try { updateButtonStates(); } catch(e) {} }); } catch(e) {}
          pop('Controls data uploaded');
        } else if (json && json.error) {
          pop('Upload error: ' + json.error);
        } else {
          pop('Upload failed – script returned no JSON');
        }
      })
      .catch((err) => {
        pop('Upload failed – check script URL & deployment');
      })
      .finally(() => {
        if (uploadControlsBtn) {
          stopWaveDots(uploadControlsBtn);
          uploadControlsBtn.classList.remove('busy');
        }
        updateButtonStates();
      });
  }

  // Switch between Controls setup card and live Controls card; text-only changes, no layout tweaks

function initOverlay() {
    if (entriesBtn && overlay && panel) {
      const openControls = () => {
        overlay.classList.add('open');
        overlay.setAttribute('aria-hidden', 'false');

        // Always reflect current in-memory state first (before any network calls)
        try { updateButtonStates(); } catch (e) {}
        try { syncCardHeaderFromHost_(); } catch (e) {}

        const baseUrl = (cmUrlInput && (cmUrlInput.value || '').trim()) || (saved && (saved.webAppUrl || '').trim()) || '';
        if (!baseUrl) {
          try { setConnectionStatus('disconnected', 'Not connected'); } catch (e) {}
          return;
        }        // On each open, refresh status so lights reflect current rally/day
        try {
          if (typeof refreshStatusAfterPing === 'function') {
            toastSet('Loading…', true, false);
            requestAnimationFrame(() => toastSet('Loading', true, true));
            Promise.resolve(refreshStatusAfterPing())
              .catch((e) => { try { toastSet('Status failed', false, false); } catch(_) {} })
              .finally(() => { try { setTimeout(() => toastClear(), 200); } catch(_) {} });
          }
        } catch (e) {
          }
};
      
      safeOn(entriesBtn,'click', openControls);

    }

    if (closeBtn && overlay) {
      safeOn(closeBtn,'click', () => {
        overlay.classList.remove('open');
        overlay.setAttribute('aria-hidden', 'true');
      });
    }

    if (overlay && panel) {
      safeOn(overlay,'click', (e) => {
        if (!panel.contains(e.target)) {
          overlay.classList.remove('open');
          overlay.setAttribute('aria-hidden', 'true');
        }
      });
    }
  }

  
  // v2.1.36 — Apply downloaded sheet payloads into the card-model UI (ATA only)
  function applyDownloadedAtaPayloadToCards_(sheet){
    try{
      if(!sheet || !Array.isArray(sheet.header) || !Array.isArray(sheet.rows)) return;
      const header = sheet.header.map(h => (h==null?'':String(h)).trim());
      const idxEntrant = header.findIndex(h => h.toLowerCase() === 'entrant');
      const idxHash = header.findIndex(h => h === '#');

      const cardCols = [];
      header.forEach((h, i) => {
        if(!h) return;
        const lo = h.toLowerCase();
        if(lo === 'entrant' || h === '#') return;
        cardCols.push({ name:h, idx:i });
      });

      const safeStr = (v) => (v==null?'':String(v)).trim();

      const findDriverName = (row, rowIndex1) => {
        const fromPayload = (idxEntrant >= 0) ? safeStr(row[idxEntrant]) : '';
        if(fromPayload) return fromPayload;
        try{
          const di = (rowIndex1|0) - 1;
          const arr = (model && Array.isArray(model.drivers)) ? model.drivers : [];
          return safeStr(arr[di] || '');
        }catch(e){}
        return '';
      };

      const cssEsc_ = (s) => {
        if(window.CSS && typeof CSS.escape === 'function') return CSS.escape(String(s));
        return String(s).replace(/["\\]/g, '\\$&');
      };

      const setAtaInput = (driverName, cardName, ataVal) => {
        const dn = safeStr(driverName);
        const cn = safeStr(cardName);
        const av = safeStr(ataVal);
        if(!dn || !cn) return false;

        let el = document.querySelector('input[aria-label="ATA for Driver ' + cssEsc_(dn) + ' on ' + cssEsc_(cn) + '"]');

        if(!el){
          const candidates = document.querySelectorAll('input[aria-label^="ATA for Driver"][aria-label$="on ' + cssEsc_(cn) + '"]');
          for(const c of candidates){
            const al = (c.getAttribute('aria-label')||'').trim();
            if(al.toLowerCase() === ('ata for driver ' + dn.toLowerCase() + ' on ' + cn.toLowerCase())) { el = c; break; }
          }
        }

        if(!el) return false;

        el.value = av;
        try{ el.dispatchEvent(new Event('input', { bubbles:true })); }catch(e){}
        try{ el.dispatchEvent(new Event('change', { bubbles:true })); }catch(e){}
        return true;
      };

      // v2.1.36 — Marshal download fallback: fill ATA inputs by row position when payload has no Entrant column
      const setAtaInputByIndex = (cardName, rowIndex1, ataVal) => {
        const cn = safeStr(cardName);
        const av = safeStr(ataVal);
        const r = (rowIndex1|0) - 1;
        if(!cn || r < 0) return false;
        const candidates = Array.from(document.querySelectorAll('input[aria-label^="ATA for Driver"][aria-label$="on ' + cssEsc_(cn) + '"]'));
        if(!candidates[r]) return false;
        const el = candidates[r];
        el.value = av;
        try{ el.dispatchEvent(new Event('input', { bubbles:true })); }catch(e){}
        try{ el.dispatchEvent(new Event('change', { bubbles:true })); }catch(e){}
        return true;
      };

      const setModelAta = (rowIndex1, cardName, ataVal) => {
        try{
          const r = (rowIndex1|0) - 1;
          if(r < 0) return;
          const cn = safeStr(cardName);
          const cards = (model && Array.isArray(model.cards)) ? model.cards : [];
          const card = cards.find(c => safeStr(c && (c.name || c.title || '')) === cn);
          if(!card || !Array.isArray(card.cells) || !card.cells[r]) return;
          card.cells[r].ata = safeStr(ataVal);
        }catch(e){}
      };

      for(let ri=0; ri<sheet.rows.length; ri++){
        const row = sheet.rows[ri] || [];
        const isMarshalTwoCol = (idxEntrant < 0) && (idxHash === 0) && (header.length === 2) && (cardCols.length === 1);
        if(isMarshalTwoCol){
          const cardName = cardCols[0].name;
          const ataVal = row[cardCols[0].idx];
          const rowIndex1 = ri + 1; // fill by current UI row order (rallyNo order)
          setModelAta(rowIndex1, cardName, ataVal);
          setAtaInputByIndex(cardName, rowIndex1, ataVal);
          continue;
        }

        const rowIndex1 = idxHash >= 0 ? (parseInt(safeStr(row[idxHash]), 10) || (ri+1)) : (ri+1);
        const driverName = findDriverName(row, rowIndex1);

        for(const cc of cardCols){
          const ataVal = row[cc.idx];
          setModelAta(rowIndex1, cc.name, ataVal);
          // Prefer rallyNo (rowIndex1) mapping; fall back to name if needed
          if(!setAtaInputByIndex(cc.name, rowIndex1, ataVal)){
            setAtaInput(driverName, cc.name, ataVal);
          }
        }
      }

      try{ if(typeof recomputeAllScores === 'function') recomputeAllScores(); }catch(e){}
      try{ if(typeof updateTotals === 'function') updateTotals(); }catch(e){}
      try{ if(typeof applyScoreStyles === 'function') applyScoreStyles(); }catch(e){}
    }catch(e){
      console.error('applyDownloadedAtaPayloadToCards_ failed:', e);
    }
  }

function initButtons() {
    // Minimal: wire Save & Test + Clear URL buttons (Controls-local)
    if (saveTestBtn) {
      safeOn(saveTestBtn,'click', () => {
        handleSaveAndTest();
      });
    }
    if (clearUrlBtn) {
      safeOn(clearUrlBtn,'click', () => {
        handleClearUrl();
      });
    }
  }

// Share helpers (deduped)
    function getDayValueFromPill_() {
      const dayLabel = cdDayPill ? (cdDayPill.textContent || '').trim() : '';
      let dayValue = '1';
      if (dayLabel) {
        const m = dayLabel.match(/Day\s+(\d+)/i);
        if (m) dayValue = m[1];
      }
      return dayValue;
    }

    function getRallyTitleForShare_() {
      // Prefer the card title pill; then host title pill; then test-strip input.
      const a = (cdRallyTitlePill && (cdRallyTitlePill.textContent || '').trim()) || '';
      const b = (rallyTitlePill && (rallyTitlePill.textContent || '').trim()) || '';
      const c = (ctrlTestTitle && (ctrlTestTitle.value || '').trim()) || '';
      return a || b || c || 'Rally';
    }

    function shareEmail_(kind, url) {
      const dayValue = getDayValueFromPill_();
      const title = getRallyTitleForShare_();
      if (kind === 'entrant') {
        const subject = title + ' – STC record Day ' + dayValue;
        const body = title + ' – STC record Day ' + dayValue + ':\n\n' + url;
        openMailWith(subject, body);
        pop('Email opened');
        return;
      }
      const subject = title + ' – Marshal link Day ' + dayValue;
      const body = title + ' – Marshal link (Day ' + dayValue + '):\n\n' + url;
      openMailWith(subject, body);
      pop('Email opened');
    }

    function shareWhatsApp_(kind, url) {
      const dayValue = getDayValueFromPill_();
      const title = getRallyTitleForShare_();
      if (kind === 'entrant') {
        const msg = title + ' – STC record Day ' + dayValue + ': ' + url;
        openWhatsAppWith(msg);
        pop('WhatsApp opened');
        return;
      }
      const msg = title + ' – Marshal link (Day ' + dayValue + '): ' + url;
      openWhatsAppWith(msg);
      pop('WhatsApp opened');
    }

    // Export for inline handlers / future wiring
    window.shareEmail_ = shareEmail_;
    window.shareWhatsApp = shareWhatsApp_;
    window.shareWhatsApp_ = shareWhatsApp_;

function withBusy_(btn, fn) {
      if (!btn) return;
      safeOn(btn,'click', () => {
        btn.classList.add('busy');
        btn.disabled = true;
        try { fn(); }
        finally {
          btn.classList.remove('busy');
          btn.disabled = false;
        }
      });
    }
    function copyLink_(label, url) {
      const ok = copyTextLegacy(url);
      if (ok) {
        pop(label + ' link copied');
      } else {
        window.prompt('Copy this link', url);
        pop(label + ' link ready to copy');
      }
    }

    
    function bindShare_(btn, kind, action) {
      if (!btn) return;
      withBusy_(btn, () => {
        const links = ensureFormLinks();
        if (!links) return;
        const url = (kind === 'entrant') ? links.entrantFormUrl : links.marshalFormUrl;
        if (!url) return;
        if (action === 'copy') return copyLink_(kind === 'entrant' ? 'Entrant' : 'Marshal', url);
        if (action === 'email') { shareEmail_(kind, url); pop('Email link opened'); return; }
        if (action === 'wa') return shareWhatsApp_(kind, url);
      });
    }
    bindShare_(entrantCopyBtn,'entrant','copy');
    bindShare_(entrantEmailBtn,'entrant','email');
    bindShare_(entrantWABtn,'entrant','wa');
    bindShare_(marshalCopyBtn,'marshal','copy');
    bindShare_(marshalEmailBtn,'marshal','email');
    bindShare_(marshalWABtn,'marshal','wa');

if (uploadControlsBtn) {
      safeOn(uploadControlsBtn,'click', () => {
        uploadControlsData();
      });
    }
if (downloadControlsBtn) {
      safeOn(downloadControlsBtn,'click', () => {
        const baseUrl = (getBaseUrl_ && getBaseUrl_()) || ((cmUrlInput && (cmUrlInput.value || '').trim()) || '');
        if (!baseUrl) {
          pop('Paste your Web App URL first');
          return;
        }

        // Busy animation (Admin-style wave dots)
        try { downloadControlsBtn.classList.add('busy'); downloadControlsBtn.disabled = true; startWaveDots(downloadControlsBtn, 'Downloading'); } catch(e) {}

        let dayParam = '1';
        if (ctrlTestDay) {
          const v = (ctrlTestDay.value || '').trim();
          if (v) dayParam = v;
        }

        const rallyName = (ctrlTestTitle ? (ctrlTestTitle.value || '').trim() : '') ||
          (cdRallyTitlePill ? (cdRallyTitlePill.textContent || '').trim() : '') ||
          'Rally';

        const qs = 'mode=downloadControls&rallyName=' + encodeURIComponent(rallyName) + '&day=' + encodeURIComponent(dayParam);
        const url = baseUrl.includes('?') ? (baseUrl + '&' + qs) : (baseUrl + '?' + qs);

        fetch(url, { method: 'GET', redirect: 'follow' })
          .then((res) => {
            if (!res.ok) throw new Error('HTTP ' + res.status);
            return res.json().catch(() => null);
          })
          .then((json) => {
            if (!json || json.ok === false) {
              pop((json && json.error) ? ('Download error: ' + json.error) : 'Download failed');
              return;
            }

            // v2.1.38 — debug (default OFF)
            try { __sstLog_('downloadControls ok', { rallyName, day: dayParam, hasStc: !!(json&&json.stc), hasMarshal: !!(json&&json.marshal) }); } catch(e) {}
            try { if (json && json.stc) __sstWarnSheetShape_('STC payload', json.stc); } catch(e) {}
            try { if (json && json.marshal) __sstWarnSheetShape_('Marshal payload', json.marshal); } catch(e) {}

            // Apply download into cards (v2.1.30)
            try { if (json.stc) applyDownloadedAtaPayloadToCards_(json.stc); } catch(e) {}
            try { if (json.marshal) applyDownloadedAtaPayloadToCards_(json.marshal); } catch(e) {}

            
            // v2.2.321 — store-only: record last Download Control Data use (short date + HH:MM:SS)
            try {
              const root = JSON.parse(localStorage.getItem('TD_RALLIES') || '{}') || {};
              const rid = (root?.global?.activeRallyId || root?.global?.lastRallyId || '');
              if (rid && root?.rallies?.[rid]) {
                const r = root.rallies[rid];
                r.controls = r.controls || {};
                r.controls.google = r.controls.google || {};
                const now = new Date();
                const dd = String(now.getDate()).padStart(2,'0');
                const mon = now.toLocaleString(undefined,{ month:'short' });
                const hh = String(now.getHours()).padStart(2,'0');
                const mm = String(now.getMinutes()).padStart(2,'0');
                const ss = String(now.getSeconds()).padStart(2,'0');
                r.controls.google.lastDownloadAt = `${dd} ${mon} ${hh}:${mm}:${ss}`;
                localStorage.setItem('TD_RALLIES', JSON.stringify(root));
              }
            } catch(e) {}
pop('Controls data downloaded');
          })
          .catch((err) => {
            pop('Download failed – check script URL & deployment');
          })
          .finally(() => {
            try { downloadControlsBtn.classList.remove('busy'); downloadControlsBtn.disabled = false; stopWaveDots(downloadControlsBtn); } catch(e) {}
          });
});
    }

    if (copyFormBtn) {
      safeOn(copyFormBtn,'click', () => {
        const url = (saved && saved.entrantFormUrl) || '';
        if (!url) {
          pop('Upload entry data first');
          return;
        }
        const ok = copyTextLegacy(url);
        if (ok) {
          pop('Entry form link copied');
        } else {
          window.prompt('Copy this link', url);
          pop('Entry form link ready to copy');
        }
      });
    }

    if (sendLinkBtn) {
      safeOn(sendLinkBtn,'click', () => {
        const url = (saved && saved.entrantFormUrl) || '';
        if (!url) {
          pop('Upload entry data first');
          return;
        }
        const title = 'Rally';
const subject = title + ' – entry form';
        const body = 'Please complete your rally entry here:\n\n' + url;
        openMailWith(subject, body);
        pop('Email link opened');
      });
    }

    if (waTestBtn) {
      safeOn(waTestBtn,'click', () => {
        const url = (saved && saved.entrantFormUrl) || '';
        if (!url) {
          pop('Upload entry data first');
          return;
        }
        const title = 'Rally';
const msg = title + ' – entry form: ' + url;
        openWhatsAppWith(msg);
        pop('WhatsApp link opened');
      });
    }

    if (openControlsBtn) {
      safeOn(openControlsBtn,'click', () => {
        const url = saved && saved.spreadsheetUrl;
        if (!url) {
          pop('No spreadsheet URL yet – upload controls first');
          return;
        }
        window.open(url, '_blank');
      });
    }
    if (viewResponsesBtn) {
      safeOn(viewResponsesBtn,'click', () => {
        const url = (saved && saved.responsesRootFolderUrl) || '';
        if (!url) {
          pop('No responses folder yet – upload controls first');
          return;
        }
        try {
          window.open(url, '_blank', 'noopener');
        } catch (e) {
          window.open(url, '_blank');
        }
      });
    }
function init() {
    restoreFromSaved();
    initOverlay();
    initButtons();

    // Plan-sync badge wiring (page-level)
try { initPlanSigWatchers(); } catch(e) {}
    try { recheckPlanSig(); } catch(e) {}
}

    return { init };
  })();

  const ControlsDemoHarness = (() => {
if (document.readyState === 'loading') {
    safeOn(document,'DOMContentLoaded', function(){
    ControlsCardCore.init();
    try { initPlanSigWatchers(); } catch(e) {}
  });
} else {
    ControlsCardCore.init();
  }
  })();
})();
</script>

<script>

(function(){
  if(window.__TDR_SHARED_GLUE_V01__) return;
  window.__TDR_SHARED_GLUE_V01__ = true;

  const BC_NAME = 'TD_RALLIES_CHANGED';
  const RESET_BC_NAME = 'TD_RALLY_RESET';
  let bc = null;
  let resetBc = null;
  let __resetSeen = false;

  function safeParse(s){ try{ return JSON.parse(s); }catch(_){ return null; } }
  function getRoot(){
    const r = safeParse(localStorage.getItem('TD_RALLIES')||'{}');
    return (r && typeof r==='object') ? r : {};
  }
  function setRoot(root){
    if(__tdWriteIsFenced_()) return;
    if(localStorage.getItem('TD_RALLIES')===null) return;
    const next = JSON.stringify(root||{});
    // TIDY-ONLY: skip identical write (prevents double-writes from change+blur).
    const prev = localStorage.getItem('TD_RALLIES');
    if(prev === next) return;
    localStorage.setItem('TD_RALLIES', next);
  }

  function getActiveRid(root){
    root = root || getRoot();
    const rid = (root && root.global && root.global.activeRallyId) ? String(root.global.activeRallyId) : '';
    return rid || '';
  }
  function setActiveRid(rid, reason){
    if(localStorage.getItem('TD_RALLIES')===null) return;
    const root = getRoot();
    root.global = (root.global && typeof root.global==='object') ? root.global : {};
    root.global.activeRallyId = String(rid||'').trim();
    setRoot(root);
    broadcast(reason || 'activeRid', { activeRallyId: root.global.activeRallyId });
  }

  function broadcast(reason, payload){
    try{
      if(!('BroadcastChannel' in window)) return;
      if(!bc) bc = new BroadcastChannel(BC_NAME);
      bc.postMessage(Object.assign({ type:'TD_RALLIES_CHANGED', reason:String(reason||''), ts: Date.now() }, payload||{}));
    }catch(_){}
  }

  
  function hardReset(msg){
    if(__resetSeen) return;
    __resetSeen = true;
    // Best-effort: clear per-page UI/model state
    try { localStorage.removeItem('TD_ACTIVE_DAY'); } catch(_e) {}
    try {
      const panel = document.getElementById('panel');
      if(panel) panel.innerHTML = '';
    } catch(_e) {}
    try { if(window.__CTRL_nameByRallyNo) window.__CTRL_nameByRallyNo = {}; } catch(_e) {}
    try { if(window.__CTRL_navByRallyNo) window.__CTRL_navByRallyNo = {}; } catch(_e) {}
    try { if(window.CTRL_TRACE) console.log('[CTRL_RESET] TD_RALLY_RESET hard reset', {reason: (msg && msg.reason)}); } catch(_e) {}
    setTimeout(()=>{ try{ window.location.reload(); }catch(_e){} }, 50);
  }

  function armResetListener(){
    try{
      if(!('BroadcastChannel' in window)) return;
      if(!resetBc) resetBc = new BroadcastChannel(RESET_BC_NAME);
      resetBc.addEventListener('message', (ev)=>{
        const msg = ev && ev.data;
        if(!msg) return;
        hardReset(msg);
      });
    }catch(_){}
  }

  // Arm TD_RALLY_RESET immediately on boot (Controls does not always call tdrInstallListeners_)
  armResetListener();

function installListeners(handler){
    handler = (typeof handler === 'function') ? handler : function(){};
    try{
      if('BroadcastChannel' in window){
        if(!bc) bc = new BroadcastChannel(BC_NAME);
        bc.addEventListener('message', (ev)=>{
          const msg = ev && ev.data;
          if(!msg || msg.type !== 'TD_RALLIES_CHANGED') return;
          handler(msg);
        });
      }
    }catch(_){}
    // TD_RALLY_RESET — hard reset (new rally created in Admin)
    armResetListener();

    try{
      window.addEventListener('storage', (e)=>{
        if(!e) return;
        if(e.key !== 'TD_RALLIES') return;
        handler({ type:'TD_RALLIES_CHANGED', reason:'storage', ts: Date.now() });
      });
    }catch(_){}
  }

  // Expose (names intentionally generic)
  window.tdrGetRoot_ = getRoot;
  window.tdrSetRoot_ = function(root, reason){ setRoot(root); broadcast(reason||'tdr_write'); };
  window.tdrGetActiveRid_ = function(){ return getActiveRid(); };
  window.tdrSetActiveRid_ = setActiveRid;
  window.tdrBroadcast_ = broadcast;
  window.tdrInstallListeners_ = installListeners;
})();
</script>

<script>
(function(){
 try{
  const root=JSON.parse(localStorage.getItem("TD_RALLIES")||"{}");
  const rid=(root && root.global && root.global.activeRallyId) ? root.global.activeRallyId : "";
  const rally=(rid && root && root.rallies && root.rallies[rid]) ? root.rallies[rid] : {};
  if(rally.meta){
    const pack=document.getElementById('rallyTitlePack'); const t=pack?pack.querySelector('.rally-title, .title, span, div'):null;
    const r=pack?pack.querySelector('.rxxx, .rally-rxxx'):null;
    if(t) t.textContent=(rally.meta.title||rid||"");
    if(r) r.textContent=(rally.meta.issue||"");
  }
  const common=root.global?.common||{};
  const urlInput=document.querySelector("input[name='webAppUrl'], #webAppUrl");
  const mobInput=document.querySelector("input[name='orgMobile'], #orgMobile");
  if(urlInput && common.webAppUrl) urlInput.value=common.webAppUrl;
  if(mobInput && common.mobile) mobInput.value=common.mobile;
  // v2.1.262 — Entries feed is day-aware (Admin generates controls.days[day].entries)
  (function(){
    try{
      const dayKey = String(((rally && rally.ui && rally.ui.activeDay) ? rally.ui.activeDay : (Number(localStorage.getItem('TD_ACTIVE_DAY'))||1)) || 1);
      const rawDay = (rally && rally.admin && rally.admin.controls && rally.admin.controls.days && rally.admin.controls.days[dayKey] && rally.admin.controls.days[dayKey].entries)
        ? rally.admin.controls.days[dayKey].entries
        : ((rally && rally.controls && rally.controls.days && rally.controls.days[dayKey] && rally.controls.days[dayKey].entries)
            ? rally.controls.days[dayKey].entries
            : (rally.admin?.controls?.entries ?? rally.controls?.entries));
      window.__entriesByRallyNo = (window.__sstNormalizeEntriesFromControls_ ? window.__sstNormalizeEntriesFromControls_(rawDay) : (rawDay || {}));
    }catch(_e){
      window.__entriesByRallyNo = (window.__sstNormalizeEntriesFromControls_ ? window.__sstNormalizeEntriesFromControls_((rally.admin?.controls?.entries ?? rally.controls?.entries)) : ((rally.admin?.controls?.entries ?? rally.controls?.entries) || {}));
    }
  })();
  try{
    if(window.__sstApplyEntriesFromTdRallies_) window.__sstApplyEntriesFromTdRallies_(window.__entriesByRallyNo);

    // Sync cards first (Schedule may have added/removed Marshal/STC controls)
    try{ if(window.__sstControlsSyncCardsFromSchedule_) window.__sstControlsSyncCardsFromSchedule_(rally && rally.schedule ? rally.schedule.days : null, ((rally && rally.ui && rally.ui.activeDay) ? rally.ui.activeDay : (Number(localStorage.getItem('TD_ACTIVE_DAY'))||null))); }catch(_e){}

    // Render first so DOM cards exist, then paint dependent ETAs.
    if(window.__sstControlsRender_) window.__sstControlsRender_();
    if(window.__sstRefreshStcEtas_) window.__sstRefreshStcEtas_();
    if(window.__sstRefreshMarshalEtas_) window.__sstRefreshMarshalEtas_();
}catch(e){}
  // Shared: keep Controls in sync with TD_RALLIES (Admin writes) — prefer activeRallyId
  function __sstPickActiveRid_(root){
    try{
      const rallies = (root && root.rallies) ? root.rallies : {};
      const rid = (root && root.global && root.global.activeRallyId) ? String(root.global.activeRallyId) : '';
      if(rid && rallies[rid]) return rid;
      return Object.keys(rallies||{})[0] || '';
    }catch(_e){ return ''; }
  }

  window.__sstControlsFeedSync = function(){
    try{
      const root2 = JSON.parse(localStorage.getItem("TD_RALLIES") || "{}");
      const rid2 = __sstPickActiveRid_(root2);
      if(!rid2) return;
      const rally2 = (root2 && root2.rallies && root2.rallies[rid2]) ? root2.rallies[rid2] : {};
      // v2.1.158 — UI driver names from Admin entries (fallback to surname)
      try{
        const adminEntriesRaw = (rally2 && rally2.admin) ? (rally2.admin.entries ?? rally2.admin.entryList ?? rally2.admin.entriesByRallyNo ?? rally2.admin.entries_data ?? rally2.admin.entriesData) : null;
        window.__CTRL_nameByRallyNo = (window.__sstBuildDriverNameMapFromAdminEntries_ ? window.__sstBuildDriverNameMapFromAdminEntries_(adminEntriesRaw) : {});
      }catch(_e){ window.__CTRL_nameByRallyNo = {}; }
      try{
        const adminEntriesRaw2 = (rally2 && rally2.admin) ? (rally2.admin.entries ?? rally2.admin.entryList ?? rally2.admin.entriesByRallyNo ?? rally2.admin.entries_data ?? rally2.admin.entriesData) : null;
        window.__CTRL_navByRallyNo = (window.__sstBuildNavigatorNameMapFromAdminEntries_ ? window.__sstBuildNavigatorNameMapFromAdminEntries_(adminEntriesRaw2) : {});
      }catch(_e){ window.__CTRL_navByRallyNo = {}; }
      const entries2raw = (rally2.admin?.controls?.entries ?? rally2.controls?.entries) || {};
      const entries2 = (window.__sstNormalizeEntriesFromControls_ ? window.__sstNormalizeEntriesFromControls_(entries2raw) : entries2raw);
      window.__entriesByRallyNo = entries2;
      if(window.__sstApplyEntriesFromTdRallies_) window.__sstApplyEntriesFromTdRallies_(entries2);
      try{ if(window.__sstControlsSyncCardsFromSchedule_) window.__sstControlsSyncCardsFromSchedule_(rally2 && rally2.schedule ? rally2.schedule.days : null, ((rally2 && rally2.ui && rally2.ui.activeDay) ? rally2.ui.activeDay : (Number(localStorage.getItem('TD_ACTIVE_DAY'))||null))); }catch(_e){}
      if(window.__sstRefreshStcEtas_) window.__sstRefreshStcEtas_();
    if(window.__sstRefreshMarshalEtas_) window.__sstRefreshMarshalEtas_();
      if(window.__sstControlsRender_) window.__sstControlsRender_();
      // Best-effort: update visible title/issue if present (canonical: rally.meta.title + rally.meta.issue)
      try{
        const t=(rally2.meta && rally2.meta.title) ? String(rally2.meta.title) : '';
        const r=(rally2.meta && rally2.meta.issue) ? String(rally2.meta.issue) : '';
        const tEl=document.querySelector('#rallyTitlePill, .rally-title, .rallyTitle, #rallyTitle, [data-role="rallyTitle"]');
        const rEl=document.querySelector('#rallyIssuePill, .rally-issue, .rallyIssue, .rally-rxxx, .rallyRxxx, #rallyRxxx, [data-role="rallyIssue"]');
        if(tEl && t) tEl.textContent=t;
        if(rEl){
          const rv = (r && String(r).trim()) ? String(r).trim() : 'r000';
          rEl.textContent = rv;
          try{
            const isPh = (!rv || rv === 'r000');
            rEl.classList.toggle('is-placeholder', isPh);
          }catch(_e){}
        }
      }catch(_e){}
    }catch(e){}
  };

  // v2.1.149 — Stabilised single entry point wrapper (no UI/behaviour change)
// All triggers call syncAndRender(); it delegates to the existing FeedSync pipeline.
(function(){
  const __CTRL_delegate = window.__sstControlsFeedSync;
  window.syncAndRender = function(reason){
    // Re-entrancy guard: prevents accidental nested calls from overlapping triggers.
    if(window.__CTRL_SYNC_BUSY) return;
    window.__CTRL_SYNC_BUSY = true;
    try{
      const fn = __CTRL_delegate || window.__sstControlsFeedSync;
      if(typeof fn === 'function') fn();
    }catch(e){
      try{ if(window.TD_DEBUG && window.TD_DEBUG.controlsWarn) console.warn('syncAndRender delegate failed', e); }catch(_e){}
    }
    window.__CTRL_SYNC_BUSY = false;
  };
})();

  // Initial hydrate
  try{ window.addEventListener('DOMContentLoaded', function(){ try{ window.syncAndRender('broadcast'); }catch(_e){} }); }catch(_e){}

  // React to TD_RALLIES updates from other tabs/pages
  // v2.1.155 — debounce listener-triggered syncAndRender() (no UI/behaviour change intended)
  let __ctrlListenT = 0;
  let __ctrlListenReason = '';
  const __ctrlDebouncedListen = (reason) => {
    try{ __ctrlListenReason = reason || ''; }catch(_e){}
    try{ clearTimeout(__ctrlListenT); }catch(_e){}
    __ctrlListenT = setTimeout(()=>{ try{ window.syncAndRender(__ctrlListenReason); }catch(_e){} }, 80);
  };
  try{
    window.addEventListener('storage', function(ev){
      try{ if(ev && ev.key === "TD_RALLIES") __ctrlDebouncedListen('storage'); }catch(_e){}
    });
    try{ window.addEventListener('resize', sstScheduleStartStripLeftFix_, {passive:true}); }catch(_e){}
  }catch(_e){}
  try{
    if('BroadcastChannel' in window){
      const bc = new BroadcastChannel("TD_RALLIES_CHANGED");
      bc.addEventListener("message", function(ev){
        try{
          const data = ev && ev.data;
          if(!data || data.type !== "TD_RALLIES_CHANGED") return;
          __ctrlDebouncedListen('broadcast');
        }catch(_e){}
      });
    }
  }catch(_e){}

// v2.1.147 — Activation catch-up: same-tab navigation doesn't trigger storage events
try{
  let __ctrlSyncT = 0;
  const __ctrlDebouncedSync = () => {
    try{ clearTimeout(__ctrlSyncT); }catch(_e){}
    __ctrlSyncT = setTimeout(()=>{ try{ window.syncAndRender('activation'); }catch(_e){} }, 80);
  };
  window.addEventListener('focus', __ctrlDebouncedSync);
  document.addEventListener('visibilitychange', () => { if(!document.hidden) __ctrlDebouncedSync(); });
}catch(_e){}

 } catch(e){ try{ if(window.TD_DEBUG && window.TD_DEBUG.controlsWarn) console.warn("TD_RALLIES read failed", e); }catch(_e){} }
})();

  

  
(function(){
  // We don’t create/upgrade DBs here — Admin owns workspace persistence.
  const CANON_DB = 'TD_WORKSPACE_DB_v1';
  const STORE_CANDIDATES = ['kvs'];
  const KEY_CANDIDATES = ['workspaceDirHandle'];

  async function dbExists_(name){
    try{
      if(!indexedDB.databases) return true; // no support: fall back to open()
      const dbs = await indexedDB.databases();
      return (dbs||[]).some(d => d && d.name === name);
    }catch(_){
      return true; // be permissive
    }
  }

  async function tryOpen_(dbName){
    // Avoid creating stray empty DBs when workspace isn't set.
    if(!(await dbExists_(dbName))) return null;
    return new Promise((resolve, reject)=>{
      try{
        const req = indexedDB.open(dbName);
        req.onsuccess = ()=>resolve(req.result);
        req.onerror = ()=>reject(req.error);
      }catch(e){ reject(e); }
    });
  }

  async function idbGetAny_(){
    const dbName = CANON_DB;
    {
      let db = null;
      try{ db = await tryOpen_(dbName); }catch(_){ db = null; }
      if(!db) return null;
      try{
        for(const storeName of STORE_CANDIDATES){
          if(!db.objectStoreNames.contains(storeName)) continue;
          for(const key of KEY_CANDIDATES){
            const val = await new Promise((resolve)=>{
              try{
                const tx = db.transaction(storeName, 'readonly');
                const st = tx.objectStore(storeName);
                const req = st.get(key);
                req.onsuccess = ()=>resolve(req.result);
                req.onerror = ()=>resolve(undefined);
              }catch(_){ resolve(undefined); }
            });
            if(val) return val;
          }
        }
      }finally{
        try{ db.close(); }catch(_){ }
      }
    }
    return null;
  }

  async function idbGetKey_(key){
    const dbName = CANON_DB;
    let db = null;
    try{ db = await tryOpen_(dbName); }catch(_){ db = null; }
    if(!db) return null;
    try{
      for(const storeName of STORE_CANDIDATES){
        if(!db.objectStoreNames.contains(storeName)) continue;
        const val = await new Promise((resolve)=>{
          try{
            const tx = db.transaction(storeName, 'readonly');
            const st = tx.objectStore(storeName);
            const req = st.get(String(key));
            req.onsuccess = ()=>resolve(req.result);
            req.onerror = ()=>resolve(undefined);
          }catch(_){ resolve(undefined); }
        });
        if(val != null) return val;
      }
    }finally{
      try{ db.close(); }catch(_){}
    }
    return null;
  }

  async function rehydrateWorkspaceFromIdb_(){
    try{
      let td = tdRead_();
      const ready = !!(td && td.global && td.global.workspaceReady);
      if(ready) return false;

      const h = await idbGetKey_('workspaceDirHandle');
      if(!h) return false;

      const label = await idbGetKey_('workspaceLabel');

      if(!td) return false;
      if(!td.global) td.global = {};
      td.global.workspaceReady = true;
      if(label) td.global.workspaceLabel = String(label);

      /* v2.2.321 — read-only on boot: do NOT persist TD_RALLIES just to mark workspaceReady */
      return true;
    }catch(_e){
      return false;
    }
  }

  function bootWorkspaceRehydrate_(){
    try{
      rehydrateWorkspaceFromIdb_().then(function(){
        try{ refreshWorkspaceUi_(); }catch(_){}
        /* v2.2.321 — read-only on boot: skip syncAndRender on workspace rehydrate */
      });
    }catch(_){}
  }

  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', bootWorkspaceRehydrate_, { once:true });
  }else{
    bootWorkspaceRehydrate_();
  }

  function tdRead_(){
    const raw = localStorage.getItem('TD_RALLIES');
    if(!raw) return null;
    try{ return JSON.parse(raw); }catch(_){ return null; }
  }

  function refreshWorkspaceUi_(){
    try{
      const td = tdRead_();
      const ready = !!(td && td.global && td.global.workspaceReady);
      const label = (td && td.global && td.global.workspaceLabel) ? String(td.global.workspaceLabel) : '';
      const saveBtn = document.getElementById('btnSavePage');
      const loadBtn = document.getElementById('btnLoadPage');
      const tip = ready ? '' : 'Workspace not set. Open Admin and set the workspace folder.';
      if(saveBtn){
        saveBtn.disabled = !ready;
        if(tip) saveBtn.title = tip; else saveBtn.removeAttribute('title');
      }
      if(loadBtn){
        loadBtn.disabled = !ready;
        if(tip) loadBtn.title = tip; else loadBtn.removeAttribute('title');
      }
      const labEl = document.getElementById('workspaceLabelPill');
      if(labEl){
        labEl.textContent = label || '';
        labEl.style.display = (label ? '' : 'none');
      }
    }catch(_e){}
  }

  try{ window.refreshWorkspaceUi_ = refreshWorkspaceUi_; }catch(_e){}

function __tdWriteIsFenced_(){
    try{
      const until = Number(window.__TD_WRITE_FENCE_UNTIL||0);
      if(until && Date.now() < until) return true;
      if(window.__TD_DAY_MIRROR_APPLYING) return true;
      if(window.__TD_CTRL_DAY_SWITCHING) return true;
    }catch(_e){}
    return false;
  }

function tdWrite_(td){
    if(__tdWriteIsFenced_()) return false;
    const raw0 = localStorage.getItem('TD_RALLIES');
    if(!raw0) return false;
    try{ localStorage.setItem('TD_RALLIES', JSON.stringify(td)); return true; }catch(_){ return false; }
  }

  // v2.1.248 — allow LOAD to create TD_RALLIES (SAVE still requires TD_RALLIES to exist)
  function tdWriteAllowCreate_(td){
    if(__tdWriteIsFenced_()) return false;
    try{ localStorage.setItem('TD_RALLIES', JSON.stringify(td)); return true; }catch(_){ return false; }
  }

  function getRid_(){
    try{
      const td = tdRead_();
      if(window.tdScheduleGetActiveRid_){
        const rid = window.tdScheduleGetActiveRid_();
        if(rid) return rid;
      }
      // primary fallback (current schema)
      if(td && td.global){
        const ridG = td.global.activeRallyId || td.global.activeRid || td.global.lastRallyId || null;
        if(ridG) return String(ridG);
      }
      // fallback for older snapshots
      if(td){
        const rid2 = td.currentRid || td.activeRid || td.currentRallyId || null;
        if(rid2) return String(rid2);
      }
    }catch(_){ }
    return '';
  }
  // Export for diagnostics / parity
  try{ if(!window.getRid_) window.getRid_ = getRid_; }catch(_){ }

  function getRallyTitle_(td, rid){
    try{
      const r = td && td.rallies && td.rallies[rid] ? td.rallies[rid] : null;
      const admin = r && r.admin ? r.admin : null;
      const meta = r && r.meta ? r.meta : null;
      return String((admin && (admin.title || admin.rallyTitle)) || (meta && meta.title) || r.title || 'Rally').trim() || 'Rally';
    }catch(_){ return 'Rally'; }
  }

  function sanitizeFolder_(s){
    return String(s||'Rally').trim().replace(/[^a-z0-9\-_ ]/gi,'').replace(/\s+/g,' ').trim().replace(/ /g,'_') || 'Rally';
  }

  function nextRref_(td, rid){
    const r = (td && td.rallies && td.rallies[rid]) ? td.rallies[rid] : null;
    if(!r){ throw new Error('Rally missing for SAVE'); }
    r.meta = r.meta || {};
    let n = parseInt(r.meta.rCounter,10);
    if(!Number.isFinite(n) || n<1) n = 1;
    const ref = 'r' + String(n).padStart(3,'0');
    r.meta.rCounter = n + 1;
    r.meta.lastSavedAt = new Date().toISOString();
    r.meta.lastSavedRef = ref;
    return ref;
  }

  async function writeFile_(dirHandle, filename, text){
    const fileHandle = await dirHandle.getFileHandle(filename, { create:true });
    const writable = await fileHandle.createWritable();
    await writable.write(text);
    await writable.close();
  }

  window.tdWorkspaceSaveSnapshot = async function(){
  if(window.__TD_WS_SAVE_INFLIGHT__){ return false; }
  window.__TD_WS_SAVE_INFLIGHT__ = true;
  try{
    const td = tdRead_();
    if(!td || !td.rallies){
      alert('Nothing to save: TD_RALLIES is empty.');
      return false;
    }
    if(!window.isSecureContext){
      alert('SAVE requires https or localhost.');
      return false;
    }
    if(!window.showDirectoryPicker && !window.showSaveFilePicker){
      alert('SAVE requires a modern browser (Chrome/Edge) File System Access API.');
      return false;
    }

    // Workspace handle is Admin-owned. Prefer Admin's live handle, else restore from IndexedDB.
    let workspace = null;
    try{
      if (window.__WORKSPACE && window.__WORKSPACE.ready && window.__WORKSPACE.handle){
        workspace = window.__WORKSPACE.handle;
      }
    }catch(_e){ workspace = null; }
    if(!workspace){
      try{ workspace = await idbGetAny_(); }catch(_e){ workspace = null; }
    }
    if(!workspace){
      alert('Workspace not set. Open Admin and set the workspace folder, then SAVE again.');
      return false;
    }

    // Preflight: ensure we have read/write permission to the workspace handle.
    // (Handles restored from IDB can be present but still be in "prompt/denied" state.)
    try{
      if(workspace && typeof workspace.queryPermission === 'function'){
        let perm = await workspace.queryPermission({ mode:'readwrite' });
        if(perm !== 'granted' && typeof workspace.requestPermission === 'function'){
          // Must be called from a user gesture; this function is invoked directly by the SAVE click handler.
          perm = await workspace.requestPermission({ mode:'readwrite' });
        }
        // Some contexts return "prompt" without showing a dialog; treat as not-authorized.
        if(perm !== 'granted'){
          alert('Set Rally Workspace: permission not granted for the workspace folder. Open Admin and re-select the workspace folder, then SAVE again.');
          try{
            const td2 = tdRead_() || td;
            if(td2){
              td2.global = td2.global || {};
              td2.global.workspaceReady = false;
              tdWriteAllowCreate_(td2);
              refreshWorkspaceUi_();
            }
          }catch(_e){}
          return false;
        }
      }
    }catch(_e){
      // If permission checks fail, fall back to asking user to re-set workspace.
      alert('Set Rally Workspace: unable to confirm workspace permission. Open Admin and re-select the workspace folder, then SAVE again.');
      try{
        const td2 = tdRead_() || td;
        if(td2){
          td2.global = td2.global || {};
          td2.global.workspaceReady = false;
          tdWriteAllowCreate_(td2);
          refreshWorkspaceUi_();
        }
      }catch(__e){}
      return false;
    }

    const rid = getRid_();
    td.rallies = td.rallies || {};
    if(!td.rallies[rid]){
      alert('Rally not found in TD_RALLIES. Open Admin and select a rally, then SAVE again.');
      return false;
    }

    const rallyNameRaw = getRallyTitle_(td, rid);
    const rallyName = String(rallyNameRaw || '').trim();
    if(!rallyName){
      alert('Rally title missing. Open Admin and commit the rally title, then SAVE again.');
      return false;
    }

    // Next r### (match Admin semantics)
    let curIssue = 'r000';
    try{
      curIssue = (td.rallies[rid].meta && td.rallies[rid].meta.issue) ? String(td.rallies[rid].meta.issue).trim() : 'r000';
    }catch(_e){ curIssue = 'r000'; }
    let n = parseInt(curIssue.replace(/[^0-9]/g,''), 10);
    if(!isFinite(n)) n = 0;
    const nextIssue = 'r' + String(n + 1).padStart(3, '0');

    // Build snapshot wrapper (match Admin)
    const fullData = {
      kind: 'TD_RALLIES_SNAPSHOT',
      version: String(document.title || 'Schedule').trim(),
      savedAt: new Date().toISOString(),
      activeRallyId: rid,
      td_rallies: td
    };

    // Folder based on rally title (prefer raw; fallback to sanitized if needed)
    let rallyDir = null;
    try{
      rallyDir = await workspace.getDirectoryHandle(rallyName, { create:true });
    }catch(_e){
      const folderName = sanitizeFolder_(rallyName);
      rallyDir = await workspace.getDirectoryHandle(folderName, { create:true });
    }

    const fileHandle = await rallyDir.getFileHandle(nextIssue + '.json', { create:true });
    const writable = await fileHandle.createWritable();
    await writable.write(JSON.stringify(fullData, null, 2));
    await writable.close();

    // Mirror issue into TD_RALLIES meta so all pages stay aligned.
    try{
      td.rallies[rid].meta = (td.rallies[rid].meta && typeof td.rallies[rid].meta === 'object') ? td.rallies[rid].meta : {};
      td.rallies[rid].meta.issue = nextIssue;
      td.rallies[rid].meta.lastSavedAt = fullData.savedAt;
      td.rallies[rid].meta.lastSavedBy = 'Schedule';
    }catch(_e){}

    tdWrite_(td);

    try{ window.dispatchEvent(new CustomEvent('TD_RALLIES_CHANGED', { detail:{ rid: rid, reason:'WORKSPACE_SAVE' } })); }catch(_e){}
    try{ if (window.TD_DEBUG && window.TD_DEBUG.workspaceSave) console.log('[WORKSPACE_SAVE]', { rid, rallyName, issue: nextIssue }); }catch(_e){}
    return true;
  }catch(e){
    try{
      const msg = (e && (e.name || e.message)) ? String(e.name || '') + ': ' + String(e.message || '') : String(e||'');
      const low = msg.toLowerCase();
      if((e && e.name === 'NotAllowedError') || low.includes('not allowed') || low.includes('getdirectoryhandle') || low.includes('user agent')){
        alert('Set Rally Workspace: permission is not granted in this session. Open Admin and re-select the workspace folder, then SAVE again.');
        try{
          const td2 = tdRead_();
          if(td2){
            td2.global = td2.global || {};
            td2.global.workspaceReady = false;
            tdWriteAllowCreate_(td2);
            refreshWorkspaceUi_();
          }
        }catch(_e){}
        return false;
      }
      alert('SAVE failed: ' + (e && e.message ? e.message : e));
      return false;
    }catch(_e){
      alert('SAVE failed: ' + (e && e.message ? e.message : e));
      return false;
    }
  }finally{
    window.__TD_WS_SAVE_INFLIGHT__ = false;
  }
};// v5.54 — Workspace LOAD protocol (shared entry point; uses Admin-owned workspace handle)
  window.tdWorkspaceLoadSnapshot = async function(){
  try{
    if(!window.isSecureContext){
      alert('LOAD requires https or localhost.');
      return false;
    }
    if(!window.showOpenFilePicker){
      alert('LOAD requires a modern browser (Chrome/Edge) File System Access API.');
      return false;
    }

    // Workspace handle is Admin-owned. Prefer Admin's live handle, else restore from IndexedDB.
    let workspace = null;
    try{
      if (window.__WORKSPACE && window.__WORKSPACE.ready && window.__WORKSPACE.handle){
        workspace = window.__WORKSPACE.handle;
      }
    }catch(_e){ workspace = null; }
    if(!workspace){
      try{ workspace = await idbGetAny_(); }catch(_e){ workspace = null; }
    }
    if(!workspace){
      alert('Workspace not set. Open Admin and set the workspace folder, then try LOAD again.');
      return false;
    }

    const handles = await window.showOpenFilePicker({
      multiple: false,
      types: [{ description: 'TD Rallies Snapshot', accept: { 'application/json': ['.json'] } }],
      // Try to start in workspace, but allow user to browse anywhere
      startIn: workspace
    });
    const fh = handles && handles[0] ? handles[0] : null;
    if(!fh) return false;

    const file = await fh.getFile();
    const jsonText = await file.text();

    let parsed = null;
    try{ parsed = JSON.parse(String(jsonText||'{}')); }catch(e){
      alert('Could not read JSON: ' + (e && e.message ? e.message : e));
      return false;
    }

    // Accept either wrapper snapshots (preferred) or raw TD_RALLIES objects (legacy)
    let td = null;
    if (parsed && parsed.kind === 'TD_RALLIES_SNAPSHOT' && parsed.td_rallies){
      td = parsed.td_rallies;
    }else{
      td = parsed;
    }

    if(!td || !td.rallies){
      alert('Not a valid TD_RALLIES snapshot (missing rallies).');
      return false;
    }

    tdWriteAllowCreate_(td);

    let rid = null;
    try{ rid = (parsed && parsed.activeRallyId) ? String(parsed.activeRallyId) : null; }catch(_e){ rid = null; }
    if(!rid){
      try{ rid = td.global && td.global.activeRallyId ? String(td.global.activeRallyId) : null; }catch(_e){ rid = null; }
    }
    if(!rid){
      try{ rid = Object.keys(td.rallies||{})[0] || null; }catch(_e){ rid = null; }
    }
    if(rid){
      try{
        td.global = (td.global && typeof td.global === 'object') ? td.global : {};
        td.global.activeRallyId = rid;
        tdWriteAllowCreate_(td);
      }catch(_e){}
    }

    try{ window.dispatchEvent(new CustomEvent('TD_RALLIES_CHANGED', { detail:{ rid: rid || null, reason:'WORKSPACE_LOAD' } })); }catch(_e){}
    try{ if(window.TD_DEBUG && window.TD_DEBUG.workspaceLoad) console.log('[WORKSPACE_LOAD]', { rid: rid || null, file: (file && file.name) ? file.name : '' }); }catch(_e){}

    // Clean re-hydrate: simplest + safest is reload
    try{ location.reload(); }catch(_e){}
    return true;
  }catch(e){
    alert('LOAD failed: ' + (e && e.message ? e.message : e));
    return false;
  }
};})();
  
</script>

  <script src="https://cdn.jsdelivr.net/npm/exceljs@4.4.0/dist/exceljs.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>


<script>
/* v2.2.284 — View toggle (Normal/Compact) */
(function(){
  function sync(){
    var btn = document.getElementById('pageZoomBtn');
    if(!btn) return;
    var isCompact = document.body.classList.contains('is-compact');
    btn.setAttribute('aria-pressed', isCompact ? 'true' : 'false');
    btn.textContent = isCompact ? 'Compact' : 'Normal';
    btn.title = isCompact ? 'Compact view (screen only)' : 'Normal view (screen only)';
  }
  function toggle(){
    document.body.classList.toggle('is-compact');
    sync();
    try{ if(window.sstScheduleStartStripLeftFix_) window.sstScheduleStartStripLeftFix_(); }catch(_e){}
  }
  document.addEventListener('DOMContentLoaded', function(){
    var btn = document.getElementById('pageZoomBtn');
    if(btn){
      btn.addEventListener('click', toggle);
      sync();
    }
  });
})();
</script>

</body>
</html>