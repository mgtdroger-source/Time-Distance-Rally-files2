<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<!--
Schedule Planner — hygiene note
v3.50: Comment/header hygiene only (removed historical inline version notes; no functional/layout changes)
Recent fixes: v3.45a syntax hotfix; v3.44a SG lane toggle CSS restore; v3.42a shell fix; v3.42 AT idempotent.
-->

<title>Schedule v7.13</title>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<style id="css-consolidated-v4-01">/* v3.50 CSS contract consolidation: duplicate top-level rules removed; order preserved */

    :root {
      --page-bg: #f3f4f6;
      --panel-bg: #ffffff;
      --panel-border: #cbd5e1;
      --table-bg: #ffffff;
      --table-border: #d4d4d8;
      --header-bg: #e5e7eb;
      --header-text: #111827;
      --cell-text: #111827;
      --gap-top: 12px;
      --gap-bottom: 0px;
      --w-idx: 70px;
      --w-dist: 90px;
      --w-time: 120px;
      --w-speed: 60px;
      --w-turn: 80px;
      --card-time-w: 124px;
      --card-speed-w: 78px;
      --sg-lane-w: 240px; /* SG dock lane width */
}

    * { box-sizing: border-box; }

    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: var(--page-bg);
      color: var(--cell-text);
    }

    body {
      /* 12px left/right from window edge, top margin via top-gap only */
      padding: 0 12px 24px;
    }

    .page-shell {
      max-width: none;
      margin: 0;
    }

    .top-gap { height: var(--gap-top); flex-shrink: 0; }
    .bottom-gap { height: var(--gap-bottom); flex-shrink: 0; }

    .sticky-slab {
      position: sticky;
      top: 0;
      z-index: 40;
      background: var(--page-bg);
    }


    .btn {
      padding: 4px 10px;
      border-radius: 6px;
      border: 1px solid #cbd5e1;
      background: #f9fafb;
      font-size: 12px;
      line-height: 1.2;
      cursor: pointer;
      color: #0f172a;
      user-select: none;
    }

    .btn.primary {
      border-color: #0f766e;
      background: #0d9488;
      color: #ecfeff;
    }


    /* Dummy header band inside sticky slab */
    .dummy-header-shell {
      background: var(--header-bg);
      margin-top: 12px;
      border-radius: 0;
      border: 1px solid var(--table-border);
      box-shadow: none;
    }

    .dummy-header-row {
      display: grid;
      grid-template-columns:
        var(--w-idx) var(--w-dist) var(--w-time)
        var(--w-speed) 1fr var(--w-turn);
      min-height: 52px; /* baseline header height */
      height: auto; /* allow growth for card rails */
      align-items: stretch; /* cells fill full band height */
      padding: 0; /* no inner padding so grid aligns with table */
      font-weight: 600;
      color: var(--header-text);
      column-gap: 0;
    }

    .dummy-header-cell {
      display: flex;
      align-items: center;
      justify-content: center;
      white-space: nowrap;
      border-right: 1px solid var(--table-border);
    }

    .dummy-header-cell.instr {
      display: flex;
      align-items: center;
      justify-content: flex-start;
      padding-left: 0;
    }

    .instr-cards-dock {
      display: flex;
      flex: 0 0 auto;
      gap: 4px;
      min-width: 0;
    }

    .instr-label-wrap {
      flex: 1 1 auto;
      text-align: center;
      min-width: 0;
    }

    .instr-label {
      display: inline-block;
      white-space: nowrap;
    }


    /* SG body strip under header rails (structure only) */


    .instr-cards-dock {
      display: flex;
      flex: 0 0 auto;
      gap: 6px;
      min-width: 0;
      align-self: stretch; /* fill header cell vertically so rails touch top/bottom */
      height: 100%;
    }


    .table-shell { width: 100%; margin:0; padding:0; }


    @media screen {
      .schedule-table thead {
        display: none;
      }
    }


    .schedule-table td.col-instr {
      padding-top: 0;
      padding-bottom: 0;
    }


    .col-dist { width: var(--w-dist);  text-align: right; }
    .col-time { width: var(--w-time);  text-align: center; }
    .col-speed { width: var(--w-speed); text-align: center; }
    .col-turn { width: var(--w-turn);  text-align: center; }
    .col-instr { width: auto;           text-align: left; }


    .instruction-prefix {
      font-weight: 600;
      white-space: nowrap;
      color: #0f172a;
    }


    .turn-select {
      width: 100%;
      border-radius: 4px;
      border: 1px solid #e5e7eb;
      padding: 2px 4px;
      font-size: 13px;
      background: #ffffff;
    }

    /* Row type hooks (no colours yet) */


/* === Begin Table Lab v0.45 CSS === */

  h1 {
    font-size: 18px;
    margin: 0 0 12px;
  }


  /* ─────────────────────────────────────────────
     TABLE LAB: table shell, grid, cells (START)
     ───────────────────────────────────────────── */


  table {
    width: 100%;
    border-collapse: collapse;
    table-layout: fixed;
  }

  th, td {
    border: 1px solid #d1d5db;
    padding: 4px 4px;
    font-size: 14px;
    line-height: 1.2;
    text-align: center;
    vertical-align: middle;
    background-color: #ffffff;
  }

  :root { --cell-h: 26px; --cell-at-h: 56px; --ncard-accent-orange: #ff9800; --lab-col-index: 70px; --lab-col-dist: 90px; --lab-col-time: 120px; --lab-col-speed: 60px; --lab-col-turn: 80px; }

  /* ─────────────────────────────────────────────
     TABLE LAB: COLUMN WIDTH SCAFFOLD (from 8.3.291)
     ───────────────────────────────────────────── */

  thead tr.header-row th {
    background: #e5e7eb;
    font-weight: 700;
  }

  /* Column widths for 6-column lab table */
  col.col-index, th.col-index, td.col-index {
    width: var(--lab-col-index) !important;
    min-width: var(--lab-col-index) !important;
    max-width: var(--lab-col-index) !important;
  }

  col.col-dist, th.col-dist, td.col-dist {
    width: var(--lab-col-dist) !important;
    min-width: var(--lab-col-dist) !important;
    max-width: var(--lab-col-dist) !important;
  }

  /* Start STC DIST is editable (black) */
  tr.start-stc td.col-dist input[type="text"] {
    color: #000;
    font-weight: normal;
  }

  col.col-time, th.col-time, td.col-time {
    width: var(--lab-col-time) !important;
    min-width: var(--lab-col-time) !important;
    max-width: var(--lab-col-time) !important;
  }

  col.col-speed, th.col-speed, td.col-speed {
    width: var(--lab-col-speed) !important;
    min-width: var(--lab-col-speed) !important;
    max-width: var(--lab-col-speed) !important;
  }

  th.col-instr, td.col-instr {
    width: auto;
  }

  col.col-turn, th.col-turn, td.col-turn {
    width: var(--lab-col-turn) !important;
    min-width: var(--lab-col-turn) !important;
    max-width: var(--lab-col-turn) !important;
    white-space: nowrap;
  }

  /* Index cell layout (from donor) */
  td.index-cell {
    padding: 4px 6px;
    background: #f3f4f6;
    position: relative;
    text-align: center;
  }
  
  /* Added Time: print-exclude checkbox (index cell) — overlay so digits don't move */
  tr.added-time td.index-cell .at-print-flag{
    position:absolute;
    left:6px;
    top:50%;
    transform: translateY(-50%);
    width:14px;
    height:14px;
    margin:0;
    accent-color:#2563eb; /* keep native look; can tint later */
  }

  tr.added-time td.index-cell .at-print-label{
    position:absolute;
    top:5px;
    left:50%;
    transform: translateX(-50%);
    font-size:10px;
    font-weight:600;
    color:#6b7280;
    line-height:1;
    user-select:none;
    pointer-events:none;
    white-space: nowrap;
  }
.index-wrap {
    display: inline-flex;
    align-items: center;
    gap: 8px;
  }
  .row-num {
    display: inline-block;
    font-weight: 600;
    min-width: 18px;
  }
  
  /* v7.03 — Added Time print-exclude checkbox (index cell only, AT rows only) */
  tr.added-time td.index-cell .at-print-flag{
    width: 14px;
    height: 14px;
    margin: 0;
    padding: 0;
    accent-color: #dc2626;
    cursor: pointer;
  }

.row-del {
    display: none;
  }
  .row-gear {
    width: 22px;
    height: 22px;
    line-height: 22px;
    border: none;
    border-radius: 4px;
    background: transparent;
    color: #555;
    cursor: pointer;
    font-size: 18px;
    font-weight: 700;
    padding: 0;
    opacity: 0.9;
    position: absolute;
    right: 6px;
    top: 50%;
    transform: translateY(-50%);
  }
  .row-gear:hover, .row-gear:focus {
    color: #111;
    opacity: 1;
    background: #f3f3f3;
  }

  /* DIST / TIME cells with optional checkbox (same pattern as donor) */
  .with-checkbox {
    position: relative;
    width: 100%;
    height: var(--cell-h);
  }
  .with-checkbox input[type="text"] {
    width: 100%;
    height: var(--cell-h);
    line-height: var(--cell-h);
    text-align: center;
    border: none;
    background: transparent;
    box-sizing: border-box;
    padding-right: 22px; /* room for checkbox */
  }
  .with-checkbox input[type="checkbox"] {
    position: absolute;
    top: 50%;
    right: 6px;
    transform: translateY(-50%);
    margin: 0;
  }


  tr.start-row td.col-dist .with-checkbox input[type="checkbox"], tr.start-row td.col-time .with-checkbox input[type="checkbox"] {
    visibility: hidden;
    pointer-events: none;
  }


  tr.start-row td.col-dist input[type="text"].start-dist-locked {
    pointer-events: none;
  }
  tr.start-row td.col-dist input[type="text"].start-dist-locked:focus {
    outline: none !important;
    box-shadow: none !important;
  }


  tr.stc-row td.col-time input[type="text"] {
    color: #dc2626 !important;
    font-weight: 400 !important;
  }


  tr.stc-row .instruction-prefix, tr.marshal-row .instruction-prefix, tr.start-stc .instruction-prefix, tr.open-control-row .instruction-prefix {
    padding-left: 8px;
  }


  tr.marshal-row td.col-dist .with-checkbox input[type="text"], tr.marshal-row td.col-time .with-checkbox input[type="text"], tr.marshal-row td.col-speed input[type="text"], tr.marshal-row td.col-speed .speed-input {
    color: #dc2626 !important;
    font-weight: 400 !important;
  }

/* TIME fields: auto-only display (blue) */
  td.col-time input[type="text"] {
    color: #0366d6;
  }

  /* DIST/TIME print flags: red when unchecked (won't print) */
  td.col-dist .with-checkbox input[type="text"].unprinted, td.col-time .with-checkbox input[type="text"].unprinted {
    color: red;
  }

  /* SG parity: time "won\'t print" style */
  .sg-time-text.unprinted {
    color: red;
    font-weight: 600;
  }


tr.stc-row .sg-time-text.unprinted {
    font-weight: 400;
  }

  /* Marshal SG lane: hide tick (keep space) + force red time/speed at weight 400 */
  tr.marshal-row .sg-time-checkbox { visibility: hidden; pointer-events: none;
  width: 14px;
  height: 14px;
  flex: 0 0 14px;
}
  tr.marshal-row .sg-time-text { color: #dc2626 !important; font-weight: 400 !important; }
  tr.marshal-row .sg-speed-input { color: #dc2626 !important; font-weight: 400 !important; }

  /* SG parity: hide tick but keep its space */
  .sg-time-checkbox.tick-hidden {
    visibility: hidden;
  }

  /* Print parity: "won't print" should not print */


/* DIST validation: border red when distance goes backwards */
  td.col-dist .with-checkbox input[type="text"].dist-invalid {
    border-color: red;
  }

  .speed-dup { color:red !important; }
  /* Marshal rows are never printed: show DIST/TIME/SPEED in red and hide their DIST/TIME tick boxes */
  tr.marshal-row td.col-dist input[type="text"], tr.marshal-row td.col-time input[type="text"], tr.marshal-row td.col-speed input[type="text"] {
    color: red;
    font-weight: 600;
  }
  tr.marshal-row td.col-dist .with-checkbox input[type="checkbox"], tr.marshal-row td.col-time .with-checkbox input[type="checkbox"] {
    display: none;
  }
  .row-template {display:none;}
  /* SPEED cells */
  td.col-speed input[type="text"] {
    width: 100%;
    height: var(--cell-h);
    line-height: var(--cell-h);
    text-align: center;
    border: none;
    background: transparent;
    box-sizing: border-box;
  }

  /* Instruction cell layout */
  .instruction-wrap {
    display: flex;
    align-items: center;
    gap: 10px;
    width: 100%;
    box-sizing: border-box;
    position: relative;
    padding-left: var(--sg-dock-w, 0px);
    padding-right: 0;
  }


  /* No-wrap instruction text (prep for SG lane) */
  .instruction-input-sl {
    white-space: pre;
    overflow-x: auto;
    overflow-y: hidden;
    resize: none;
  }
/* SG per-row mount frame (prep only; empty until SG arrives) */
  td.col-instr { position: relative; }
  .sg-home-frame {
    position: absolute;
    top: 0;
    left: 0;
    right: auto;
    bottom: 0;
    width: var(--sg-dock-w, 0px);
    display: flex;
    align-items: center;
    justify-content: flex-start;
    pointer-events: none; /* lanes inside become interactive */
  }
.instruction-prefix {
    font-weight: 700;
    white-space: nowrap;
    user-select: none;
  }
  .instruction-input-sl {
    width: 100%;
    min-height: var(--cell-h);
    padding: 3px 6px;
    border: none;
    outline: none;
    background: transparent;
    resize: none;
    overflow: hidden;
    font: inherit;
    line-height: 1.4;
  }
  /* Plain instruction row text not bold */
  .instruction-row .instruction-input-sl {
    font-weight: 400;
  }


  tr.instruction-row td.col-instr .instruction-wrap {
    height: var(--cell-h);
    align-items: center;
  }
  tr.instruction-row td.col-instr .instruction-input-sl {
    height: var(--cell-h);
    line-height: var(--cell-h);
    padding-top: 0;
    padding-bottom: 0;
  }

  .turn-select {
    width: 100%;
    border: none;
    background-color: transparent;
    text-align: center;
    height: var(--cell-h);
    line-height: var(--cell-h);
    display: none; /* hidden; TURN uses custom pill + menu */
  }

  .turn-pill {
    width: 100%;
    height: var(--cell-h);
    line-height: var(--cell-h);
    text-align: center;
    border: none;
    background: transparent;
    cursor: pointer;
    padding: 0;
    font-family: inherit;
    font-size: 13px;
    font-weight: 400;
  }

  /* Control row shading (lifted from donor) */
  .marshal-row td {
    background-color: #ffe5e5;
  }
  .stc-row td, .open-control-row td, .start-stc td {
    background-color: #e0e0e0;
  }

  /* Horizontally center control row type label in instruction column */
  .marshal-row .instruction-prefix, .stc-row .instruction-prefix, .start-stc .instruction-prefix, .open-control-row .instruction-prefix {
    display: block;
    text-align: center;
  }

  /* SG lane row-type parity with table (control rows) */
  tr.stc-row .sg-inline-lane,
  tr.start-stc .sg-inline-lane,
  tr.open-control-row .sg-inline-lane {
    background: #e0e0e0 !important;                 /* match page control-row grey */
    border: 1px solid rgba(0,0,0,0.10) !important;  /* keep thin base border */
    outline: 2px solid rgba(15,23,42,.28) !important; /* strong stroke without layout shift */
    outline-offset: -2px !important;               /* pull stroke inside lane */
    box-shadow: none !important;
  }

tr.marshal-row .sg-inline-lane {
    background-color: #ffe5e5;
    border-color: #ef4444;
  }
  tr.marshal-row .sg-time-checkbox { visibility: hidden; visibility: hidden;
}

  tr.marshal-row .sg-time-text, tr.marshal-row .sg-speed-input {
    color: #dc2626 !important;
    font-weight: 600;
  }

  /* Added Time full row highlight */
  .added-time td {
    background-color: #fffbe6;
  }

  .added-inline {
    display: flex;
    align-items: center;
    gap: 10px;
    width: 100%;
    box-sizing: border-box;
    padding: 3px 4px;
  }


.added-inline .added-select {
    height: var(--cell-h);
    line-height: var(--cell-h);
    background: transparent;
    border: 1px solid #000;
    border-radius: 6px;
    padding: 0 6px;
    box-sizing: border-box;
  }
  .added-inline .time-to-add {
    width: 95px;
    text-align: center;
    height: var(--cell-h);
    line-height: var(--cell-h);
    box-sizing: border-box;
    border: 1px solid #000;
    background: transparent;
  }
  .added-inline .instruction-input-sl {
    min-height: var(--cell-h);
    background: transparent;
  }


  tr:has(.added-inline) { height: auto !important; }


  tbody#schedule-body tr.added-time tbody#schedule-body tr.added-time td.col-instr .added-inline {
    flex: 1 1 auto;
    width: 100%;
  }

  /* Orange pending/pristine rings from donor */
  td.col-dist input.is-pristine, td.col-speed input.is-pristine {
    border: 1px solid transparent !important;
    border-radius: 6px !important;
    outline: none !important;
    box-shadow: inset 0 0 0 2px var(--ncard-accent-orange) !important;
  }
  td.col-dist input.is-pristine:focus, td.col-speed input.is-pristine:focus {
    box-shadow: none !important;
  }
  td.col-dist input.is-pristine[readonly] {
    box-shadow: none !important;
  }

  /* Rally title row (simple version) */
  .rally-title-row th {
    background: #f9fafb;
    text-align: left;
    font-weight: 700;
    padding: 6px 8px;
  }
  .rally-title-text {
    width: 320px;
    max-width: 100%;
    border: none;
    background: transparent;
    font: inherit;
    font-weight: 700;
    outline: none;
  }
  .rally-title-text::placeholder {
    color: #9ca3af;
    font-weight: 400;
  }

  .lab-title-bar {
    display: flex;
    align-items: center;
    justify-content: flex-start;
    gap: 12px;
  }


  .lab-addrow-menu.hidden {
    display: none;
  }


  .lab-rowmenu {
  position: absolute;
  top: 0;
  left: 0;
  z-index: 10000;
  margin-top: 6px;
  padding: 6px;
  background: #fff;
  border: 1px solid #ccc;
  border-radius: 6px;
  box-shadow: 0 6px 14px rgba(0, 0, 0, .18);
  display: block;
  min-width: 220px;
  font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif;
  font-size: 13px;
}
  .lab-rowmenu button[data-action="delete-row"] {
    color: #b91c1c;
  }

  .lab-turnmenu {
  min-width: 0;
  width: auto;
  padding: 6px;
  /* width will be adjusted from JS to follow the TURN column */
}
  .lab-rowmenu.hidden {
    display: none;
  }
  .lab-rowmenu h3 {
  margin: 4px 6px 6px;
  font-size: 12px;
  font-weight: 600;
  color: #6b7280;
}
  .lab-rowmenu button {
  display: block;
  width: 100%;
  text-align: left;
  padding: 8px 10px;
  background: #fff;
  color: #111;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-weight: 600;
}
  .lab-rowmenu button:hover {
  background: #f0f6ff;
}

  .lab-rowmenu hr {
    border: none;
    border-top: 1px solid #e5e7eb;
    margin: 4px 0;
  }

  .menu-title {
    display: none;
  }

  /* ─────────────────────────────────────────────
     TABLE LAB: table shell, grid, cells (END)
     ───────────────────────────────────────────── */

/* === End Table Lab v0.45 CSS === */

/* Control Panel Compartment styles v0.7 */
.cp-shell {
  background: #e9edf3;
  border-radius: 12px;
  padding: 8px 12px 12px 12px; /* top, right, bottom, left */
  border: 1px solid rgba(0,0,0,0.08);
  box-sizing: border-box;
}

.control-panel {
  position: sticky;
  top: 0;
  z-index: 20000;
  padding: 8px 10px;
  margin-bottom: 0;
  width: 100%;
  box-sizing: border-box;
  display: flex;
  align-items: center;
  gap: 12px;
  flex-wrap: wrap;
}

.btn {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  padding: 8px 16px;
  border: none;
  border-radius: 6px;
  cursor: pointer;
  font-weight: 700;
  color: #fff;
  box-shadow: 0 2px 4px rgba(0, 0, 0, .2);
  transition: background-color .2s ease, box-shadow .2s ease;
  font-size: 14px;
}

.btn-primary { background: #2f7edb; }
.btn-primary:hover { background: #2469b6; box-shadow: 0 3px 6px rgba(0, 0, 0, .3); }
  /* v6.65 — View toggle (Normal/Compact) as minor control */
  .btn.btn-view{
    background:#ffffff;
    color:#111827;
    border:1px solid #cbd5e1;
    padding: 8px 12px;
    min-width: 0;
    box-shadow: none;
  }
  .btn.btn-view[aria-pressed="true"]{
    background:#e5e7eb;
    border-color:#d1d5db;
  }
  .btn.btn-view:hover{ border-color:#94a3b8; }

.btn-green { background: #27a844; }
.btn-green:hover { background: #208c39; box-shadow: 0 3px 6px rgba(0, 0, 0, .3); }

.addrow-group {
  position: relative;
  display: inline-flex;
}

.addrow-menu {
  position: absolute;
  top: 100%;
  left: 0;
  margin-top: 6px;
  background: #fff;
  border: 1px solid #ccc;
  border-radius: 6px;
  box-shadow: 0 6px 14px rgba(0, 0, 0, .18);
  display: none;
  min-width: 220px;
  z-index: 10000;
  padding: 6px;
}

.addrow-menu button {
  display: block;
  width: 100%;
  text-align: left;
  padding: 8px 10px;
  background: #fff;
  color: #111;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-weight: 600;
}

.addrow-menu button:hover {
  background: #f0f6ff;
}

.control-panel > span {
  margin: 0 8px;
  color: #d1d5db;
  line-height: 1;
  position: relative;
  top: -1px;
}

.card-toggle {
  display: flex;
  align-items: center;
  gap: 5px;
  font-weight: 600;
}

.sg-max {
  margin-left: -2px;          /* pull closer to checkbox */
  font-size: 13px;            /* match label size */
  line-height: 1;
  font-weight: 600;
  color: #475569;
  opacity: 0.95;
}

.card-toggle input[type="checkbox"] {
  transform: translateY(1px);
}

/* UI v5.2 — SG1 shows no tick but keeps alignment */
.sg-tick-spacer{
  display:inline-block;
  width:14px;
  height:14px;
  transform: translateY(1px);
}
/* Unassigned SG lines: hide tick box only (keep the space) */
.sg-unassigned input.toggle-card{
  visibility:hidden;
  pointer-events:none;
}

    /* v6.69 — Unassigned SG lines are non-interactive (prevents click flash) */
    .card-toggle.sg-unassigned{
      pointer-events: none;
      cursor: default;
      opacity: 0.55;
    }

    /* v6.69 — Peek newly-assigned SG lanes briefly without changing toggle state */
    body.sg-peek-2 .sg-header-2,
    body.sg-peek-3 .sg-header-3,
    body.sg-peek-4 .sg-header-4{
      display: flex !important;
    }
    body.sg-peek-2 .sg-inline-lane[data-lane-id="2"],
    body.sg-peek-3 .sg-inline-lane[data-lane-id="3"],
    body.sg-peek-4 .sg-inline-lane[data-lane-id="4"]{
      display: flex !important;
    }

/* v5.2 — CP SG stack polish */
/* v5.2 — SG1 alignment tweak (per QA)
   SG1_LEFT_NUDGE: 1px
   SG1_GAP: 10px
   SG1_SPEED_NUDGE: -2px
*/
.card-toggle-stack .sg1-line{
  position:relative;
  left:1px;
  gap:10px;
}
.card-toggle-stack .sg1-line .sg-max{
  position:relative;
  left:-2px;
}

.card-toggle-stack{
  position:static;
  display:inline-flex;
  flex-direction:column;
  align-items:center;
  gap:2px;
  margin-left:0 !important;
  margin-right:18px; /* gap before Day selector */
  vertical-align:top;
  font-size:12px;
  line-height:1.1;
  color:#475569;
  align-self:flex-start;
  /* UI v5.2: drop SG block lower without growing the control panel */
  margin-top:12px;
  margin-bottom:-10px;
}

.cp-timeline-btn {
  margin-left: 10px;
}

.table-shell table { width:100%; }
.page-shell {padding-left:0;padding-right:0;}

.dummy-header-shell .dummy-header-cell {
  font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
  font-size: 14px;
  font-weight: 700;
}

.dummy-header-shell .dummy-header-row {
  border-bottom: 1px solid var(--table-border);
}
.dummy-header-shell .dummy-header-cell {
  border-right: 1px solid var(--table-border);
}
.dummy-header-shell .dummy-header-cell:first-child {
  border-left: 1px solid var(--table-border);
}

.dummy-header-shell .dummy-header-row {
  border-bottom-width: 2px;
}
.dummy-header-shell .dummy-header-cell {
  border-right-width: 2px;
}
.dummy-header-shell .dummy-header-cell:first-child {
  border-left-width: 2px;
}

.table-shell {
  margin-top: -58px;
}

  .center-chip.daydd {
    background: transparent !important;
    border: none !important;
    padding: 0 !important;
    height: auto !important;
  }
  #dayPillWrap { position: relative; display:inline-flex; align-items:center; z-index: 10000; overflow: visible; }

  .daydd-btn {
    display:inline-flex;
    align-items:center;
    justify-content:space-between;
    gap:6px;
    width: 140px;
    height:40px;
    padding:0 10px;
    box-sizing:border-box;
    border-radius:12px;
    background:#ffffff;
    border:1px solid #d1d5db;
    color:#111827;
    font-weight:600;
    font-size:14px;
    line-height:40px;
    white-space:nowrap;
    cursor:pointer;
    overflow:hidden;
  }
  #dayPillLabel {
    flex:1 1 auto;
    min-width:0;
    overflow:hidden;
    text-overflow:ellipsis;
    white-space:nowrap;
  }
  .daydd-btn:focus { outline: none; box-shadow: 0 0 0 3px rgba(59,130,246,.25); }
  .daydd-chev { font-size:12px; opacity:.8; margin-top:1px; }

  .daydd-menu {
    position:absolute;
    top: calc(100% + 8px);
    left: 0;
    width: 140px;
min-width: 140px;
    max-width: 140px;
    background:#ffffff;
    border:1px solid #d1d5db;
    border-radius:12px;
    padding:8px;
    box-shadow: 0 8px 24px rgba(2,6,23,.08);
    z-index: 10001;
  }
  .daydd-item {
    width:100%;
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:10px;
    height:34px;
    padding:0 12px;
    border-radius:10px;
    border:1px solid transparent;
    background:transparent;
    font-size:14px;
    font-weight:700;
    color:#111827;
    cursor:pointer;
    text-align:left;
  }
  .daydd-item:hover { background:#f3f4f6; }
  .daydd-item[aria-checked="true"] { background:#eef2ff; border-color:#c7d2fe; }


.card-toggle-stack{
  position:static;
  display:inline-flex;
  flex-direction:column;
  align-items:center;
  gap:2px;
  margin-left:0 !important;
  margin-right:18px; /* gap before Day selector */
  vertical-align:top;
  font-size:12px;
  line-height:1.1;
  color:#475569;
  align-self:flex-start;
  margin-top:2px;
}

#cp-panel.control-panel {
  display:grid;
  grid-template-columns: auto 1fr 140px; /* Zone C fixed slot */
  align-items:center;
  column-gap:16px;
}
#cp-panel .zoneA, #cp-panel .zoneB, #cp-panel .zoneC {
  min-width:0;
  display:flex;
  align-items:center;
  gap:12px;
}
#cp-panel .zoneB .cp-pill{
  height:40px;
  background:#ffffff;
  border:1px solid #d1d5db;
  border-radius:12px;
  display:flex;
  align-items:center;
  box-sizing:border-box;
  color:#111827;
  font-weight:600;
  font-size:14px;
  line-height:40px;
  box-shadow:none;
}

#cp-panel .zoneC {
  justify-content:flex-end;
}

#cp-panel .zoneB {
  justify-content:flex-start;
  align-items:center;
  gap:10px;
  padding-left:14px;
}
#cpTitlePill {
  flex: 0 1 250px; /* cap at 480; may shrink */
  width: 250px;
  max-width: 250px;
  min-width: 0;
  padding: 0 16px;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}
#cpRxxPill {
  flex: 0 0 62px; /* locked */
  width: 62px;
  max-width: 62px;
  min-width: 62px;
  justify-content: center;
}

/* =========================
   SG Quarantine Scaffold (v1.87)
   Purpose: isolate SG module from host / Table Lab globals.
   NOTE: SG elements must live under one of these roots.
   ========================= */
#sg-transfer-harness-root, .sg-quarantine-root {
  font: inherit;
  line-height: normal;
}
#sg-transfer-harness-root *, .sg-quarantine-root * {
  box-sizing: border-box;
}
#sg-transfer-harness-root input, #sg-transfer-harness-root select, #sg-transfer-harness-root textarea, .sg-quarantine-root input, .sg-quarantine-root select, .sg-quarantine-root textarea {
  font: inherit;
  line-height: inherit;
  margin: 0;
}
#sg-transfer-harness-root input[type="checkbox"], .sg-quarantine-root input[type="checkbox"] {
  margin: 0;
  padding: 0;
  /* keep native checkbox; avoids hostile CSS 'appearance:none' style issues */
  appearance: auto;
}


  #sg-root .sg-inline-lane { height: calc(var(--cell-h) - 1px); }

  /* v3.91: Added Time row must remain 56px (never collapse to normal row height) */
  .schedule-table tbody tr.added-time,
  tbody#schedule-body tr.added-time{
    height: 56px !important;
    min-height: 56px !important;
  }
  .schedule-table tbody tr.added-time > td,
  tbody#schedule-body tr.added-time > td{
    padding-top: 0 !important;
    padding-bottom: 0 !important;
    vertical-align: middle !important;
  }
  /* For AT rows, let SG lane fill the full row (do not clamp to --cell-h) */
  .schedule-table tbody tr.added-time .sg-inline-lane,
  tbody#schedule-body tr.added-time .sg-inline-lane{
    height: 100% !important;
  }

  tr.added-time #sg-root .sg-inline-lane { height: calc(var(--cell-at-h) - 1px); }

.added-inline .sg-home-frame[data-sg-home] {
  position: static !important;      /* participate in row height */
  top: auto !important;
  right: auto !important;
  bottom: auto !important;
  height: auto !important; margin-left: auto;               /* keep it docked to the right within .added-inline (flex) */
  align-self: flex-start;  margin-right: -4px;

  height: 100% !important;
  align-self: stretch !important;
  display: flex !important;
  align-items: stretch !important;

}

tr.added-time td.col-instr {
  padding-top: 3px !important;
  padding-bottom: 3px !important;
}

.added-inline {
  align-items: flex-start;
}
.added-inline .instruction-input-sl {
  flex: 1 1 auto;
  min-width: 0; /* critical: lets textarea shrink so SG lane doesn't get pushed */
}
.added-inline .sg-home-frame[data-sg-home] {
  flex: 0 0 var(--sg-lane-w);
  width: var(--sg-lane-w);
  min-width: var(--sg-lane-w);
  max-width: var(--sg-lane-w);
}

tr.start-stc .sg-inline-lane { background-color: #e0e0e0 !important; }


  .schedule-table tbody tr.added-time[data-row-type="added-time"] {
    height: 56px;
    min-height: 56px;
  }
  .schedule-table tbody tr.added-time[data-row-type="added-time"] > td {
    vertical-align: middle;
    padding-top: 0;
    padding-bottom: 0;
  }
  .schedule-table tbody tr.added-time[data-row-type="added-time"] td.col-instr {
    vertical-align: middle;
  }
  .schedule-table tbody tr.added-time[data-row-type="added-time"] .added-select, .schedule-table tbody tr.added-time[data-row-type="added-time"] .time-to-add, .schedule-table tbody tr.added-time[data-row-type="added-time"] .instruction-input-sl {
    display: inline-block;
    vertical-align: middle;
  }
  .schedule-table tbody tr.added-time[data-row-type="added-time"] .instruction-input-sl {
    height: 26px;
    line-height: 26px;
    padding-top: 0;
    padding-bottom: 0;
    white-space: nowrap;
  }


  td.col-instr .sg-home-frame[data-sg-home] { justify-content: flex-start; }
  tr.added-time td.col-instr .added-inline {
    position: relative;
    padding-left: var(--sg-dock-w, 0px) !important;
    padding-right: 0 !important;
  }
  tr.added-time td.col-instr .added-inline .sg-home-frame[data-sg-home] {
    position: absolute !important;
    top: 0 !important;
    left: 0 !important;
    right: auto !important;
    bottom: 0 !important;
    width: var(--sg-dock-w, 0px) !important;
    margin: 0 !important;
    align-self: stretch !important;
  }


  tbody#schedule-body tr.added-time {
    height: 56px;
    min-height: 56px;
  }

  .turn-header { cursor: pointer; user-select: none; }
  .turn-header .turn-print-toggle {
    position:absolute; width:1px; height:1px; opacity:0; pointer-events:none;
  }
  body.turn-print-off .turn-header-label, body.turn-print-off thead th.col-turn { color: #c00000 !important; font-weight: 600 !important; }
  body.turn-print-off td.col-turn .turn-pill { color: #c00000 !important; font-weight: 600 !important; }


#sg-transfer-harness-root .sg-time-text, #sg-transfer-harness-root .sg-speed-input, #sg-transfer-harness-root .sg-time-input, .sg-quarantine-root .sg-time-text, .sg-quarantine-root .sg-speed-input, .sg-quarantine-root .sg-time-input {
  font-family: inherit !important;
  font-size: 14px !important;
  font-weight: 400 !important;
  line-height: 1.35 !important;
  font-variant-numeric: tabular-nums !important;
  letter-spacing: 0 !important;
}

td.col-instr .sg-home-frame[data-sg-home] .sg-time-text, #sg-transfer-harness-root .sg-time-text, .sg-quarantine-root .sg-time-text {
  display: inline-flex !important;
  align-items: center !important;
  height: var(--cell-h, 26px) !important;
  line-height: var(--cell-h, 26px) !important;
}


  td.col-dist input.dist-error { outline: 2px solid #c00 !important; outline-offset: 0; }
/* =========================================================
       SECTION 2B – SG CARDS CORE CSS (re-usable)
       All .sg-* rules below can be lifted into the main project.
       ========================================================= */
.sg-header-strip {
      display: flex;
      gap: 6px;
      align-items: center;
      margin-bottom: 2px;
    }

        .sg-header-pill {
        display: flex;
        align-items: center;
        justify-content: flex-start;
        gap: 0;
        padding: 6px 0;
        height: 50px;
        border-radius: 6px;
        border: 1px solid #cbd5e1;
        background: #f9fafb;
        font-size: 14px;
        font-weight: 500;
        color: #4b5563;
        white-space: nowrap;
        width: var(--sg-lane-width);
        flex: none;
      }

    .sg-header-time {
      font-weight: 500;
      font-size: 14px;
    }

    .sg-header-speed {
      font-weight: 500;
      font-size: 14px;
      opacity: 0.9;
    }


    .sg-header-speed {
      text-align: right;
      justify-self: end;
    }

    /* Enforce 128/64 split inside SG pills */


    .sg-speed-input {
      flex: 0 0 48px;
      max-width: 48px;
      width: 48px;
    }

    .sg-header-time {
      display: flex;
      align-items: center;
      justify-content: center;
      flex: 0 0 var(--card-time-w);
      max-width: var(--card-time-w);
      text-align: center;
      font-weight: 600;
      color: #111827;
    }

    .sg-header-speed {
      display: flex;
      align-items: center;
      justify-content: center;
      flex: 0 0 var(--card-speed-w);
      max-width: var(--card-speed-w);
      text-align: center;
      font-weight: 600;
      color: #111827;
    }

    /* Strip that holds all SG lanes inside the INSTRUCTION column */
    .sg-lanes-strip {
      display: flex;
      align-items: center;
      gap: 6px;
      flex: none;

      justify-content: flex-start;
    }

    /* Inline SG lane inside INSTRUCTION column */

    .sg-inline-lane {
        display: flex;
        align-items: center;
        gap: 4px;
        border-radius: 6px;
        border: 1px solid #cbd5e1;
        background: #f9fafb;
        width: var(--sg-lane-width);
        flex: none;
        height: 38px;
        margin-block: 0px;
        padding: 2px 6px;
      }


    .sg-time-text {
      font-size: 13px;
      color: #1d4ed8; /* blue */
      font-family: inherit;
    }

    .sg-time-checkbox {
      width: 14px;
      height: 14px;
      accent-color: #2563eb;
      cursor: pointer;
    }

    .is-red {
      color: #dc2626 !important; /* red for won't print */
    }

    tr.stc-row .sg-time-text.is-red, tr[data-row-type="stc"] .sg-time-text.is-red {
      font-weight: 400 !important;
    }

    .sg-speed-input {
      width: 48px;
      text-align: center;
      font-size: 13px;
      padding: 2px 4px;
      border-radius: 4px;
      border: 1px solid #d1d5db;
      outline: none;
      font-family: inherit;
      color: #111827;
      margin-left: -4px;
    }
    .sg-speed-input:focus {
      /* Use outline (cleaner repaint than box-shadow) */
      outline: 1px solid #111827;
      outline-offset: 0;
      box-shadow: none;
      border-color: #111827;
    }


    td.col-time .with-checkbox > input[type="text"][readonly]:focus {
      outline: none !important;
      box-shadow: none !important;
      border-color: #e5e7eb !important; /* match default border */
    }

    .sg-speed-input.is-pristine:focus {
      /* Match table behaviour: while pristine, focus should remove the orange ring
         AND suppress the black focus ring (editing state shows no ring). */
      box-shadow: none !important;
      outline: none !important;
      border-color: #d1d5db !important;
    }.sg-speed-input.is-pristine {
      box-shadow: inset 0 0 0 2px #f97316; /* orange ring (pristine) */
    }
    .sg-speed-input.is-repeat {
      color: #dc2626; /* repeated speed red */
    }

    body.hide-sg-2 .sg-header-2, body.hide-sg-3 .sg-header-3, body.hide-sg-4 .sg-header-4 {
      display: none;
    }


    body.hide-sg-2 .sg-inline-lane[data-lane-id="2"],
    body.hide-sg-2 .sg-lanes-strip .sg-inline-lane[data-lane-id="2"],
    body.hide-sg-3 .sg-inline-lane[data-lane-id="3"],
    body.hide-sg-3 .sg-lanes-strip .sg-inline-lane[data-lane-id="3"],
    body.hide-sg-4 .sg-inline-lane[data-lane-id="4"],
    body.hide-sg-4 .sg-lanes-strip .sg-inline-lane[data-lane-id="4"]{
      display: none !important;
    }

    /* Print rule: red text should not print */


    /* Header label horizontal tuning */
    .sg-header-pill .sg-header-time {
      transform: translateX(-6px);
    }
    .sg-header-pill .sg-header-speed {
      transform: translateX(-12px);
    }

    .sg-header-strip .sg-header-pill {
      transform: translateX(6px);
    }
/* Simple AT block inside SG lanes */
    .card-at {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      margin-left: 4px;
      white-space: nowrap;
    }

    .card-at-label {
      font-size: 11px;
      font-weight: 600;
      letter-spacing: 0.2px;
    }

    .card-at-input {
      width: 80px;
      padding: 2px 4px;
      font-size: 12px;
      text-align: center;
      border: 1px solid #000;
      background: #fffbe6;
      box-sizing: border-box;
    }

    /* v3.95 — Added Time SG double-deck lane (Row1: time+speed, Row2: AT) */
    .sg-inline-lane.sg-at-deck{
      display: flex;
      flex-direction: column;
      align-items: stretch;
      justify-content: flex-start;
      gap: 0;
    }
    .sg-inline-lane.sg-at-deck > .sg-pill-row1{
      flex: 0 0 var(--cell-h);
    }
    .sg-inline-lane.sg-at-deck > .sg-at-row{
      flex: 1 1 auto;
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 0;
    }

.data-row.marshal-row .cell.dist, .data-row.marshal-row .sg-inline-lane .sg-time-text {
      color: #dc2626;
      font-weight: 600;
    }
.data-row.open-control-row .cell {
      background-color: #eef2ff;
    }

      /* keep default look, no extra margin */
    }
/* Speed entry in AT demo: reuse base sg-speed-input look, aligned right */
/* Row 1 SG template pill: 120px time zone + 64px speed zone, with vertical gaps */
    .sg-inline-lane


    /* === Row 1 SG Template – Grid Based === */


/* Row1 grid template clean */
.sg-template-row1 {
  height:32px;
  display:flex;
  align-items:center;
  justify-content:center;
  padding:0;
  margin-block:2px;
}
.sg-template-row1 .sg-pill-row1 {
  display:grid;
  grid-template-rows:1fr;
  width:var(--sg-lane-width);
  height:100%;
  padding:2px 4px;
  box-sizing:border-box;
}
.sg-template-row1 .pill-line1 {
  display:grid;
  grid-template-columns:120px 64px;
  align-items:center;
  width:100%;
  height:100%;
}
.sg-template-row1 .pill-time-zone {
  width:120px;
  display:flex;
  align-items:center;
  justify-content:center;
  column-gap:4px;
  margin-left:-4px;
}
.sg-template-row1 .pill-time-zone .sg-time-checkbox {
  margin-left:6px;
}
.sg-template-row1 .pill-speed-zone {
  width:64px;
  display:inline-flex;
  justify-content:flex-start;
  align-items:center;
  padding-left:0;
}
.sg-template-row1 .pill-speed-zone .sg-speed-input {
  width:100%;
  text-align:center;
}

    /* AT demo row – fine-tune SPEED pill position (slight left + down nudge) */

#sg-transfer-harness-root .pill-time-zone {
  display:flex !important;
  align-items:center !important;
  justify-content:flex-end !important; /* shift time+tick toward speed pill */
  column-gap:10px !important;          /* keep breathing room */
  padding-right:8px !important;        /* balance against speed pill */
  flex:1 1 auto !important;
  min-width:0 !important;
}
#sg-transfer-harness-root .pill-time-zone .sg-time-checkbox {
  margin-left:6px !important;
}

tr.added-time .sg-home-frame[data-sg-home] { align-items: stretch !important; }
tr.added-time .sg-home-frame[data-sg-home] { align-items: stretch !important; }
tr.added-time .sg-home-frame[data-sg-home] .sg-lanes-strip { align-items: stretch !important; }

/* v3.97: AT lanes must fill the 56px row (unclamp) and support double-deck */
tbody#schedule-body tr.added-time .sg-inline-lane{
  height: 100% !important;
  margin-block: 0 !important;
}
tbody#schedule-body tr.added-time .sg-inline-lane.sg-at-deck{
  flex-direction: column !important;
  align-items: stretch !important;
  justify-content: space-between !important;
}
tbody#schedule-body tr.added-time .sg-inline-lane.sg-at-deck > .sg-pill-row1{
  flex: 0 0 var(--cell-h) !important;
  height: var(--cell-h) !important;
}
tbody#schedule-body tr.added-time .sg-inline-lane.sg-at-deck > .sg-at-row{
  flex: 1 1 auto !important;
  display: flex !important;
  align-items: center !important;
  justify-content: center !important;
  min-height: 0 !important;
}

/* v5.4 — AT lower deck: move the AT group left within the lane (per QA: -90px) */
tbody#schedule-body tr.added-time .sg-inline-lane.sg-at-deck > .sg-at-row{
  justify-content: flex-start !important;
  padding-left: 90px !important;
}
tbody#schedule-body tr.added-time .sg-inline-lane.sg-at-deck > .sg-at-row .card-at-label,
tbody#schedule-body tr.added-time .sg-inline-lane.sg-at-deck > .sg-at-row .card-at-input{
  position: relative !important;
  left: -90px !important;
}

.schedule-table tbody tr.added-time[data-row-type="added-time"] td.col-instr {
  padding-top: 0 !important;
  padding-bottom: 0 !important;
  vertical-align: middle !important;
}
.schedule-table tbody tr.added-time[data-row-type="added-time"] td.col-instr .added-inline {
  height: 100% !important;
  display: flex !important;
  align-items: center !important;
}
.schedule-table tbody tr.added-time[data-row-type="added-time"] td.col-instr .added-inline > * {
  align-self: center;
}
tbody#schedule-body tr.added-time td.col-instr .added-content-centre {
  height: 100% !important;
  display: flex !important;
  align-items: center !important;
  gap: 10px !important;
  width: 100% !important;
  box-sizing: border-box !important;
}
tbody#schedule-body tr.added-time td.col-instr .added-content-centre .instruction-input-sl {
  height: 26px !important;
  line-height: 26px !important;
  padding-top: 0 !important;
  padding-bottom: 0 !important;
}

tbody#schedule-body tr.added-time td.col-instr .added-content-centre {
  flex-wrap: nowrap !important;
  overflow: hidden !important;
}
tbody#schedule-body tr.added-time td.col-instr .added-content-centre .instruction-input-sl {
  flex: 1 1 auto !important;
  min-width: 0 !important;
  width: auto !important;
  white-space: nowrap !important;
  overflow: hidden !important;
  text-overflow: ellipsis !important;
}

.sg-header-2 { background: #fff8cc !important; }
.sg-header-3 { background: #eaf2ff !important; }
.sg-header-4 { background: #eaf9ee !important; }
/* 1) Remove any legacy cell padding that biases content upward */
tbody#schedule-body tr.added-time td.col-instr {
  padding-top: 0 !important;
  padding-bottom: 0 !important;
  vertical-align: middle !important;
}

/* 2) Ensure the Added Time inline strip occupies the full row height (not top-packed) */
tbody#schedule-body tr.added-time td.col-instr .added-inline {
  height: 100% !important;
  min-height: 0 !important;
  align-items: stretch !important; /* cancel older flex-start */
}

/* 3) Centre the content bar within the full-height strip */
tbody#schedule-body tr.added-time td.col-instr .added-inline .added-content-centre {
  height: 100% !important;
  min-height: 0 !important;
  display: flex !important;
  align-items: center !important;
}

/* ---- consolidated ---- */

tbody#schedule-body tr.added-time td.col-instr .added-inline {
  width: 100% !important;
  min-width: 0 !important;
}
tbody#schedule-body tr.added-time td.col-instr .added-content-centre {
  width: 100% !important;
  min-width: 0 !important;
  flex: 1 1 auto !important;
}
tbody#schedule-body tr.added-time td.col-instr .added-content-centre .instruction-input-sl {
  flex: 1 1 auto !important;
  min-width: 0 !important;
  width: auto !important;
}
#sg-transfer-harness-root .sg-time-text, #sg-transfer-harness-root .sg-speed-input, #sg-transfer-harness-root .sg-time-input, #sg-transfer-harness-root .sg-speed-text, .sg-quarantine-root .sg-time-text, .sg-quarantine-root .sg-speed-input, .sg-quarantine-root .sg-time-input, .sg-quarantine-root .sg-speed-text {
  font-family: inherit !important;
  font-size: 14px !important;
  font-weight: 400 !important;
  line-height: 1.35 !important;
  font-variant-numeric: tabular-nums !important;
  letter-spacing: 0 !important;
}
/* Ensure any SG digit container doesn't force a different line-height */
#sg-transfer-harness-root .pill-time-zone, #sg-transfer-harness-root .pill-speed-zone {
  line-height: 1.35 !important;
}

/* ---- consolidated ---- */

/* Ensure grid numeric inputs/displays inherit the table contract */

/* SG digits: explicit contract (do NOT rely on html/body inheritance) */
td.col-instr .sg-home-frame[data-sg-home] .sg-time-text, td.col-instr .sg-home-frame[data-sg-home] .sg-speed-input, td.col-instr .sg-home-frame[data-sg-home] .sg-time-input, td.col-instr .sg-home-frame[data-sg-home] .sg-speed-text, #sg-transfer-harness-root .sg-time-text, #sg-transfer-harness-root .sg-speed-input, #sg-transfer-harness-root .sg-time-input, #sg-transfer-harness-root .sg-speed-text, .sg-quarantine-root .sg-time-text, .sg-quarantine-root .sg-speed-input, .sg-quarantine-root .sg-time-input, .sg-quarantine-root .sg-speed-text {
  font-family: Arial, sans-serif !important;
  font-size: 14px !important;
  font-weight: 400 !important;
  line-height: 1.35 !important;
  font-variant-numeric: tabular-nums !important;
  letter-spacing: 0 !important;
}
/* v3.96 — AT SG lane contract (AT rows ONLY)
   Goal: AT table row is fixed 56px; AT SG lanes must fill row and stack 2-tier.
   Do not affect non-AT rows. */
tbody#schedule-body tr.added-time .sg-inline-lane{
  height: 100% !important;          /* allow full 56px row */
  align-items: stretch !important;  /* lane can fill vertically */
  margin-block: 0 !important;
}

/* Double-deck layout only when the lane has sg-at-deck (already set by JS) */
tbody#schedule-body tr.added-time .sg-inline-lane.sg-at-deck{
  flex-direction: column !important;
  justify-content: space-between !important;
  padding-top: 2px !important;
  padding-bottom: 2px !important;
}

/* Row1: keep the normal 26px contract inside the 56px lane */
tbody#schedule-body tr.added-time .sg-inline-lane.sg-at-deck .sg-pill-row1{
  height: var(--cell-h, 26px) !important;
  min-height: var(--cell-h, 26px) !important;
  display: flex !important;
  align-items: center !important;
}

/* Row2: AT tier (if present) should not force overflow */
tbody#schedule-body tr.added-time .sg-inline-lane.sg-at-deck .sg-at-row2,
tbody#schedule-body tr.added-time .sg-inline-lane.sg-at-deck .card-at{
  flex: 0 0 auto !important;
}
/* v3.99 — AT SG double-deck: make the SG container chain fill the fixed 56px Added Time row (AT rows only) */
tbody#schedule-body tr.added-time.sg-at-tall td.col-instr { padding-top: 0 !important; padding-bottom: 0 !important; }

/* Stretch the host containers to the full AT row height */
/* Ensure the AT inline wrapper itself fills the row, otherwise 100% on children collapses */
tbody#schedule-body tr.added-time.sg-at-tall td.col-instr .added-inline{
  height: 100% !important;
  min-height: 0 !important;
  align-items: stretch !important;
}
tbody#schedule-body tr.added-time.sg-at-tall td.col-instr .added-content-centre{
  height: 100% !important;
  align-items: center !important;
}

tbody#schedule-body tr.added-time.sg-at-tall .sg-home-frame[data-sg-home]{
  height: 100% !important;
  align-items: stretch !important;
}
tbody#schedule-body tr.added-time.sg-at-tall .sg-lanes-strip{
  height: 100% !important;
  align-items: stretch !important;
}

/* Lane fills AT row; deck stacks */
tbody#schedule-body tr.added-time.sg-at-tall .sg-inline-lane{
  height: 100% !important;
  align-items: stretch !important;
}
tbody#schedule-body tr.added-time.sg-at-tall .sg-inline-lane.sg-at-deck{
  flex-direction: column !important;
  justify-content: space-between !important;
  padding-top: 2px !important;
  padding-bottom: 2px !important;
}

/* Row1 remains 26px inside the 56px lane */
tbody#schedule-body tr.added-time.sg-at-tall .sg-inline-lane.sg-at-deck .sg-pill-row1{
  height: var(--cell-h) !important;
  display: flex !important;
  align-items: center !important;
}
/* v4.00 — AT row contract: force Added Time inline strip to the full 56px row height (AT rows only). */
tbody#schedule-body tr.added-time.sg-at-tall td.col-instr{
  height: 56px !important;
  min-height: 56px !important;
}
tbody#schedule-body tr.added-time.sg-at-tall td.col-instr .added-inline{
  height: 56px !important;
  min-height: 56px !important;
  display: flex !important;
  align-items: stretch !important; /* allow absolute SG home-frame to fill the full height */
}

  @media print{
    /* Schedule print mode: hide live UI, show print wrapper */
    body[data-print-mode="schedule"] .page-shell{ display:none !important; }
    body[data-print-mode="schedule"] #schedulePrintWrapper{ display:block !important; }

    /* Ensure overlays never print */
    #printOptionsOverlay{ display:none !important; }

    /* Page chrome */
    body{ padding:0 !important; margin:0 !important; }

    /* Optional TURN column suppression */
    body.turn-print-off thead th.col-turn,
    body.turn-print-off tbody td.col-turn{ display:none !important; }
    body.turn-print-off col.col-turn{ display:none !important; }

    /* Safety: anything marked as "do not print" renders invisible */
    .unprinted,
    .is-red,
    .speed-dup,
    .sg-time-text.unprinted,
    .sg-time-text.is-red{
      color: transparent !important;
      text-shadow: none !important;
    }
  }

</style>


<style id="css-timeline-mount-v4-03">
  /* v6.47 — Timeline docked split view (non-blocking) */
  :root{
    --tl-dock-w: 1000px;           /* default dock width */
    --tl-dock-min: 360px;
    --tl-dock-max: 1200px;
    --tl-dock-h: 644px;           /* default dock height */
  }
  .schedule-split{ display:flex; align-items:stretch; gap:0; }
  .schedule-left{ flex:1 1 auto; min-width:0; }
  .schedule-divider{
    width: 10px;
    flex: 0 0 10px;
    cursor: col-resize;
    display:none;
    position: relative;
    background: transparent;
  }
  body.timeline-dock-open .schedule-divider{ display:block; }
  .schedule-divider:before{
    content:"";
    position:absolute; top:0; bottom:0; left:4px; width:2px;
    background: rgba(107,114,128,0.35);
    border-radius: 2px;
  }

  .timeline-dock{
    display:none;
    flex: 0 0 auto;
    width: var(--tl-dock-w);
    min-width: var(--tl-dock-min);
    max-width: var(--tl-dock-max);
    height: var(--tl-dock-h);
    max-height: calc(100vh - 140px); /* viewport cap */
    position: sticky;
    top: 96px; /* aligns under top slab area */
    align-self: flex-start;

    background:#f9fafb;
    border: 1px solid #d3d7df;
    border-radius: 14px;
    box-shadow: 0 12px 34px rgba(15,23,42,0.18);
    overflow: hidden;

    display:none;
    flex-direction: column;
  }
  body.timeline-dock-open .timeline-dock{ display:flex; }

  /* v6.56 — Float mode: draggable within viewport (no split) */
  body.timeline-float-open .schedule-divider{ display:none !important; }
  body.timeline-float-open .timeline-dock{
    display:flex;
    position: fixed;
    top: var(--tl-float-top, 120px);
    left: var(--tl-float-left, 24px);
    z-index: 50000;
    align-self: auto;
  }
  body.timeline-float-open .timeline-dock-head{ cursor: move; }
  body.timeline-float-open .timeline-dock-head button{ cursor: pointer; }

  .timeline-dock-head{
    display:flex; align-items:center; justify-content:space-between; gap:10px;
    border-bottom:1px solid #d3d7df;
    background:#f5f5f7;
    padding: 10px 12px;
  }
  .timeline-dock-title{ font-weight:700; font-size:14px; color:#111827; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
  .timeline-dock-close{
    border:1px solid #d3d7df;
    background:#fff;
    border-radius:10px;
    padding: 6px 10px;
    font-size: 12px;
    cursor:pointer;
  }
.timeline-dock-actions{
  display:flex; align-items:center; gap:8px;
}
.timeline-dock-refresh{
  /* same base style as Close; class exists mainly for future tuning */
}

.timeline-dock-refresh.tlw-wink{
  animation: tlwRefreshWink 380ms ease-in-out 1;
}
.timeline-dock-refresh[data-stale="1"]::after{
  content: "•";
  display: inline-block;
  margin-left: 6px;
  font-size: 14px;
  line-height: 0;
  transform: translateY(-1px);
}
@keyframes tlwRefreshWink{
  0%{ transform: scale(1); }
  45%{ transform: scale(1.10); }
  100%{ transform: scale(1); }
}

.timeline-dock-compact[aria-pressed="true"]{
  background:#e5e7eb;
  border-color:#9aa4b2;
}

/* v6.55 — Compact 85% real density (no transform; uses CSS zoom) */
#timelineDockMount.tlw-compact85 #timelineDockHost{
  zoom: 0.85;
}

  .timeline-dock-close:hover{ border-color:#9aa4b2; }
  .timeline-dock-body{ flex:1; min-height:0; overflow:auto; background:#f7f7f9; padding: 10px; }


  
  /* v6.60 — Float mode width resizer (left edge grip) */
  .timeline-float-resizer{
    position:absolute;
    top:0;
    left:0;
    bottom:0;
    width:12px;
    display:none;
    cursor: ew-resize;
    background: transparent;
  }
  .timeline-float-resizer:before{
    content:"";
    position:absolute;
    top:12px;
    bottom:12px;
    left:5px;
    width:2px;
    background: rgba(107,114,128,0.28);
    border-radius:2px;
  }
  body.timeline-float-open .timeline-float-resizer{ display:block; }


#timelineOverlayMount{
    position: fixed;
    inset: 0;
    background: rgba(15,23,42,0.35);
    display: none;
    align-items: center;
    justify-content: center;
    z-index: 9999;
  }
  #timelineOverlayMount.open{ display: flex; }
  .timeline-mount-card{    background: #f9fafb;
    border: 1px solid #d3d7df;
    border-radius: 14px;
    box-shadow: 0 18px 60px rgba(15,23,42,0.35);
    width: min(1180px, calc(100vw - 28px));

    display: flex;
    flex-direction: column;
    overflow: hidden;

    height: auto;
    max-height: calc(100vh - 80px);
  }
  .timeline-mount-head{    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 10px;

    border-bottom: 1px solid #d3d7df;
    background: #f5f5f7;
    font-size: 12px;
    color: #111827;

    padding: 12px 14px;
  }
  .timeline-mount-sub{
    color: #6b7280;
    font-size: 12px;
    margin-left: 8px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  .timeline-mount-close{
    border: 1px solid #d3d7df;
    background: #ffffff;
    border-radius: 10px;
    padding: 6px 10px;
    font-size: 12px;
    cursor: pointer;
  }
  .timeline-mount-close:hover{ border-color:#9aa4b2; }
  .timeline-mount-body{    flex: 1;
    overflow: auto;
    background: #f7f7f9;
    padding: 12px;
  }
  #timelineShellFrame{
    width: 100%;
    height: 100%;
    border: 0;
    display: block;
    background: #ffffff;
  }
  body.timeline-mount-lock{
    overflow: hidden !important;
  }

  .timeline-mount-host{
    min-height: 0;
  }

  .timeline-mount-title{ font-weight:700; font-size:16px; line-height:1.2; color:#111827; }

  /* v5.63 — Admin-style print wrapper (Schedule) */
  #schedulePrintWrapper{ display:none; }
  #schedulePrintWrapper .print-page{
    width: 100%;
    max-width: 257mm;
    margin: 0 auto;
    padding-top: 8mm;
  }
  #schedulePrintWrapper .print-head{
    font-size: 12px;
    font-weight: 600;
    color: #111827;
    margin: 0 0 4mm 0;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  #schedulePrintWrapper .print-table{
    width: 100%;
    border-collapse: collapse;
    table-layout: fixed;
    font-size: 12px;
  }
  #schedulePrintWrapper .print-table th,
  #schedulePrintWrapper .print-table td{
    border: 1px solid #111;
    padding: 2mm 8px;
    vertical-align: top;
    overflow: hidden;
  }
  #schedulePrintWrapper .print-table th{ font-weight: 700; height: 8mm; padding: 0 8px; vertical-align: middle; }
  #schedulePrintWrapper .print-table td.c-dist,
  #schedulePrintWrapper .print-table td.c-time,
  #schedulePrintWrapper .print-table td.c-speed,
  #schedulePrintWrapper .print-table td.c-turn{ white-space: nowrap; }
  #schedulePrintWrapper .print-table td.c-instr{ white-space: normal; word-break: break-word; text-align: left; line-height: 1.2; overflow: visible; }

  /* v5.63 — Print options modal */
  #printOptionsOverlay{ position:fixed; inset:0; background: rgba(17,24,39,0.35); display:none; align-items:center; justify-content:center; z-index: 9999; }
  #printOptionsOverlay.is-open{ display:flex; }
  #printOptionsModal{ width: 420px; max-width: calc(100vw - 28px); background:#fff; border:1px solid #d3d7df; border-radius: 14px; box-shadow: 0 12px 34px rgba(0,0,0,0.18); padding: 14px; }
  #printOptionsModal .po-title{ font-weight:700; font-size: 14px; margin-bottom: 10px; }
  #printOptionsModal .po-grid{ display:grid; grid-template-columns: 120px 1fr; gap: 10px 10px; align-items:center; }
  #printOptionsModal label.po-l{ font-size: 12px; color:#374151; }
  #printOptionsModal select, #printOptionsModal input[type="checkbox"]{ font-size: 12px; }
  #printOptionsModal select{ width:100%; padding:6px 8px; border:1px solid #d3d7df; border-radius:10px; background:#fff; }
  #printOptionsModal .po-actions{ display:flex; justify-content:flex-end; gap: 10px; margin-top: 14px; }
  #printOptionsModal .btn-secondary{ background:#e5e7eb; color:#111827; border:1px solid #cbd5e1; box-shadow: 0 2px 4px rgba(0,0,0,.10); }
  #printOptionsModal .btn-secondary:hover{ background:#d1d5db; box-shadow: 0 3px 6px rgba(0,0,0,.16); }
  #printOptionsModal .btn-secondary:focus{ outline:2px solid #93c5fd; outline-offset:2px; }
  #printOptionsModal .po-mini{ font-size: 12px; color:#6b7280; margin-top: 8px; }




/* v6.60 — Page 85% zoom toggle (screen only; print remains 100%) */
@media screen{
  body.page-zoom85 .page-shell{ zoom: 0.85; }
}
@media print{
  body.page-zoom85 .page-shell{ zoom: 1 !important; }
}
/* Button pressed state (match compact toggle semantics) */
#pageZoomBtn[aria-pressed="true"]{
  background:#e5e7eb !important;
  color:#111827 !important;
  border:1px solid #9aa4b2 !important;
  box-shadow:none !important;
}

</style>


<style id="wsReadyCss">#saveBtn:disabled,#loadBtn:disabled{opacity:0.45;filter:grayscale(0.15);}#saveBtn:disabled:hover,#loadBtn:disabled:hover{background:inherit;}</style>

<style id="td-toast-css">
  #tdToast{
    position: fixed;
    left: 50%;
    bottom: 16px;
    transform: translateX(-50%) translateY(6px);
    background: rgba(17,24,39,0.92);
    color: #fff;
    padding: 8px 12px;
    border-radius: 10px;
    font-size: 12px;
    line-height: 1.2;
    box-shadow: 0 10px 24px rgba(0,0,0,0.18);
    opacity: 0;
    pointer-events: none;
    z-index: 9999;
    transition: opacity 140ms ease, transform 140ms ease;
    max-width: min(720px, calc(100vw - 24px));
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  #tdToast.show{
    opacity: 1;
    transform: translateX(-50%) translateY(0px);
  }
  @media print{
    #tdToast{ display:none !important; }
  }
</style>


<style id="css-loadwarn-v5-94">
  /* v5.97 — Load Rally File warning modal (Schedule) */
  #loadWarnModal{display:none;position:fixed;inset:0;z-index:9999;align-items:center;justify-content:center;background:rgba(0,0,0,.25);}
  #loadWarnModal .lw-card{background:#fff;border-radius:16px;box-shadow:0 20px 60px rgba(0,0,0,.25);width:min(560px, calc(100vw - 32px));padding:18px 18px 14px;}
  #loadWarnModal .lw-title{font-size:18px;font-weight:700;margin:0 0 8px;color:#111827;}
  #loadWarnModal .lw-msg{font-size:13px;color:#6b7280;line-height:1.35;margin:0 0 14px;}
  #loadWarnModal .lw-actions{display:flex;gap:12px;justify-content:flex-end;padding-top:6px;}
  #loadWarnModal .lw-btn{border:1px solid #d1d5db;background:#fff;border-radius:12px;padding:10px 18px;font-weight:600;cursor:pointer;}
  #loadWarnModal .lw-btn.primary{background:#111827;color:#fff;border-color:#111827;}
</style>

</head>
<body>
<div class="page-shell">
<div class="sticky-slab">
<div class="top-gap"></div><div class="cp-shell" id="cp-root-shell"><div class="control-panel" id="cp-panel">
<div class="zoneA">
<div class="addrow-group">
<button class="btn btn-green" data-cp-action="add-row-menu" id="addRowBtn" type="button">ADD ROW ▾</button>
<div aria-hidden="true" class="addrow-menu" id="addRowMenu" role="menu">
<button data-row-type="instruction" data-type="instruction">Instruction</button>
<button data-row-type="instruction-5" data-type="instruction-5">Instruction x 5</button>
<button data-row-type="stc" data-type="stc">STC</button>
<button data-row-type="marshal" data-type="marshal">Marshal</button>
<button data-row-type="open-control" data-type="open-control">Open Control</button>
<button data-row-type="added-time" data-type="added-time">Added Time</button>
<button data-row-type="start-stc" data-type="start-stc">Start STC</button>
</div>
</div><span style="margin: 0 6px; color: #999;">|</span><button class="btn btn-primary" data-cp-action="print" id="printBtn" type="button">Print</button><span style="margin: 0 6px; color: #999;">|</span><button class="btn btn-primary" data-cp-action="save" id="saveBtn" type="button">Save</button><button class="btn btn-primary" data-cp-action="load" id="loadBtn" type="button">Load</button>
<span style="margin: 0 6px; color: #999;">|</span>
<div class="card-toggle-stack" id="cpSgStack">
  <label class="card-toggle sg-line sg1-line" data-sg="1"><span>Speed Group 1</span><span class="sg-tick-spacer" aria-hidden="true"></span><span class="sg-max" data-sg="1">90</span></label>
  <label class="card-toggle sg-line" data-sg="2"><span>Speed Group 2</span><input class="toggle-card" data-card="2" data-card-id="card2" type="checkbox"/><span class="sg-max" data-sg="2">80</span></label>
  <label class="card-toggle sg-line" data-sg="3"><span>Speed Group 3</span><input class="toggle-card" data-card="3" data-card-id="card3" type="checkbox"/><span class="sg-max" data-sg="3">70</span></label>
  <label class="card-toggle sg-line" data-sg="4"><span>Speed Group 4</span><input class="toggle-card" data-card="4" data-card-id="card4" type="checkbox"/><span class="sg-max" data-sg="4">60</span></label>
</div><div aria-label="Day selector" class="center-chip daydd" id="dayPillWrap" role="group">
<button aria-expanded="false" aria-haspopup="menu" class="daydd-btn" id="dayPillBtn" type="button">
<span id="dayPillLabel">Day 1</span><span aria-hidden="true" class="daydd-chev">▾</span>
</button>
<div aria-label="Select day" class="daydd-menu" hidden="" id="dayPillMenu" role="menu"></div>
</div>
</div>
<div class="zoneB">
<div class="cp-pill cp-pill-title" id="cpTitlePill">Rally Title</div>
<div class="cp-pill cp-pill-rxx" id="cpRxxPill">r000</div>
<button class="btn btn-view" id="pageZoomBtn" type="button" aria-pressed="false" title="Toggle Compact view (screen only)">Normal</button>

</div>

<div class="zoneC">
  <button class="btn btn-primary cp-timeline-btn" data-cp-action="timeline" id="timelineBtn" type="button">Timeline</button>
</div>

</div></div>
<div class="dummy-header-shell">
<div class="dummy-header-row">
<div class="dummy-header-cell">#</div>
<div class="dummy-header-cell">DIST</div>
<div class="dummy-header-cell">TIME</div>
<div class="dummy-header-cell">SPEED</div>
<div class="dummy-header-cell instr">
<div class="instr-cards-dock"><div class="sg-header-strip">
<div class="sg-header-pill sg-header-2"><div class="sg-header-time">TIME</div><div class="sg-header-speed">SG2</div></div>
<div class="sg-header-pill sg-header-3"><div class="sg-header-time">TIME</div><div class="sg-header-speed">SG3</div></div>
<div class="sg-header-pill sg-header-4"><div class="sg-header-time">TIME</div><div class="sg-header-speed">SG4</div></div>
</div></div>
<div class="instr-label-wrap"><span class="instr-label">INSTRUCTION</span></div>
</div>
<div aria-label="Toggle TURN column printing" class="dummy-header-cell turn-header" role="button" tabindex="0"><input checked="" class="turn-print-toggle" id="turnPrintToggle" type="checkbox"/><span class="turn-header-label">TURN</span></div>
</div>
</div>
<div class="bottom-gap"></div>
</div>
<div id="scheduleSplit" class="schedule-split"><div id="scheduleLeft" class="schedule-left"><div class="table-shell">
<table>
<colgroup>
<col class="col-index"/>
<col class="col-dist"/>
<col class="col-time"/>
<col class="col-speed"/>
<col class="col-instr"/>
<col class="col-turn"/>
</colgroup>
<thead>
<tr class="rally-title-row">
<th colspan="6">
<div class="lab-title-bar">
<input class="rally-title-text" placeholder="Rally title (lab only)" type="text">
</input></div>
</th>
</tr>
<tr class="header-row">
<th class="col-index">#</th>
<th class="col-dist">DIST</th>
<th class="col-time">TIME</th>
<th class="col-speed">SPEED</th>
<th class="col-instr">INSTRUCTION</th>
<th class="col-turn">TURN</th>
</tr>
</thead>
<tbody id="schedule-body">
<tr class="instruction-row start-row">
<td class="index-cell col-index">
<span class="index-wrap">
<button class="row-del" title="Delete row" type="button">×</button>
<span class="row-num">1</span>
<button class="row-gear" title="Row menu" type="button">⚙</button>
</span>
</td>
<td class="col-dist">
<div class="with-checkbox">
<input class="is-pristine start-dist-locked" readonly="" tabindex="-1" type="text" value="0.00"/>
<input type="checkbox">
</input></div>
</td>
<td class="col-time">
<div class="with-checkbox">
<input readonly="" type="text" value="00:00:00"/>
<input type="checkbox"/>
</div>
</td>
<td class="col-speed">
<input class="is-pristine" type="text" value="80"/>
</td>
<td class="col-instr">
<div class="instruction-wrap">
<input class="instruction-input-sl" placeholder="Plain instruction row" rows="1" type="text"/>
<div class="sg-home-frame" data-sg-home=""></div>
</div>
</td>
<td class="col-turn">
<select class="turn-select">
<option value=""></option>
<option value="TL">TL</option>
<option value="TR">TR</option>
<option value="CSO">CSO</option>
<option value="B/L">B/L</option>
<option value="B/R">B/R</option>
</select>
</td>
</tr>
<tr class="added-time row-template">
<td class="index-cell col-index">
<span class="at-print-label">NO PRINT</span>
<input type="checkbox" class="at-print-flag" title="Exclude this Added Time row from print" />
<span class="index-wrap">
<button class="row-del" title="Delete row" type="button">×</button>
<span class="row-num">2</span>
<button class="row-gear" title="Row menu" type="button">⚙</button>
</span>
</td>
<td class="col-dist">
<div class="with-checkbox">
<input class="is-pristine" type="text" value="5.00">
<input type="checkbox"/>
</input></div>
</td>
<td class="col-time">
<div class="with-checkbox">
<input readonly="" type="text" value="00:10:00"/>
<input type="checkbox"/>
</div>
</td>
<td class="col-speed">
<input class="is-pristine" type="text" value="80"/>
</td>
<td class="col-instr">
<div class="added-inline">
<div class="added-content-centre">
<input class="time-to-add" inputmode="numeric" type="text" value="00:05:00"/>
<select class="added-select">
<option value=""></option>
<option>Traffic Lights</option>
<option>Intersection</option>
<option>Open Section</option>
<option>Fuel Stop</option>
<option>Coffee break</option>
<option>Lunch</option>
<option>Breakfast</option>
<option>Dinner</option>
</select>
<input class="instruction-input-sl" placeholder="Added Time included in the time to the next Instruction" rows="1" type="text"/>
</div>
<div class="sg-home-frame" data-sg-home=""></div>
</div>
</td>
<td class="col-turn">
<select class="turn-select">
<option value=""></option>
<option value="TL">TL</option>
<option value="TR">TR</option>
<option value="CSO">CSO</option>
<option value="B/L">B/L</option>
<option value="B/R">B/R</option>
</select>
</td>
</tr>
<tr class="marshal-row row-template">
<td class="index-cell col-index">
<span class="index-wrap">
<button class="row-del" title="Delete row" type="button">×</button>
<span class="row-num">3</span>
<button class="row-gear" title="Row menu" type="button">⚙</button>
</span>
</td>
<td class="col-dist">
<div class="with-checkbox">
<input class="is-pristine" type="text" value="10.00">
<input type="checkbox"/>
</input></div>
</td>
<td class="col-time">
<div class="with-checkbox">
<input readonly="" type="text" value="00:20:00"/>
<input type="checkbox"/>
</div>
</td>
<td class="col-speed">
<input class="is-pristine" type="text" value="80"/>
</td>
<td class="col-instr">
<div class="instruction-wrap">
<span class="instruction-prefix">MARSHAL 1</span>
<input class="instruction-input-sl" placeholder="Edit as required" rows="1" type="text"/>
<div class="sg-home-frame" data-sg-home=""></div>
</div>
</td>
<td class="col-turn">
<select class="turn-select">
<option value=""></option>
<option value="TL">TL</option>
<option value="TR">TR</option>
<option value="CSO">CSO</option>
<option value="B/L">B/L</option>
<option value="B/R">B/R</option>
</select>
</td>
</tr>
<tr class="stc-row row-template">
<td class="index-cell col-index">
<span class="index-wrap">
<button class="row-del" title="Delete row" type="button">×</button>
<span class="row-num">4</span>
<button class="row-gear" title="Row menu" type="button">⚙</button>
</span>
</td>
<td class="col-dist">
<div class="with-checkbox">
<input class="is-pristine" type="text" value="15.00">
<input type="checkbox"/>
</input></div>
</td>
<td class="col-time">
<div class="with-checkbox">
<input readonly="" type="text" value="00:30:00"/>
</div>
</td>
<td class="col-speed">
<input class="is-pristine" type="text" value="80"/>
</td>
<td class="col-instr">
<div class="instruction-wrap">
<span class="instruction-prefix">STC 1</span>
<input class="instruction-input-sl" placeholder="Edit as required" rows="1" type="text"/>
<div class="sg-home-frame" data-sg-home=""></div>
</div>
</td>
<td class="col-turn">
<select class="turn-select">
<option value=""></option>
<option value="TL">TL</option>
<option value="TR">TR</option>
<option value="CSO">CSO</option>
<option value="B/L">B/L</option>
<option value="B/R">B/R</option>
</select>
</td>
</tr>
<tr class="start-stc row-template">
<td class="index-cell col-index">
<span class="index-wrap">
<button class="row-del" title="Delete row" type="button">×</button>
<span class="row-num">5</span>
<button class="row-gear" title="Row menu" type="button">⚙</button>
</span>
</td>
<td class="col-dist">
<div class="with-checkbox">
<input class="is-pristine" readonly="" type="text" value="0.00">
</input></div>
</td>
<td class="col-time">
<div class="with-checkbox">
<input readonly="" type="text" value="00:00:00"/>
</div>
</td>
<td class="col-speed">
<input class="is-pristine" type="text" value="80"/>
</td>
<td class="col-instr">
<div class="instruction-wrap">
<span class="instruction-prefix">START STC 1</span>
<input class="instruction-input-sl" placeholder="Edit as required" rows="1" type="text"/>
<div class="sg-home-frame" data-sg-home=""></div>
</div>
</td>
<td class="col-turn">
<select class="turn-select">
<option value=""></option>
<option value="TL">TL</option>
<option value="TR">TR</option>
<option value="CSO">CSO</option>
<option value="B/L">B/L</option>
<option value="B/R">B/R</option>
</select>
</td>
</tr>
<tr class="open-control-row row-template">
<td class="index-cell col-index">
<span class="index-wrap">
<button class="row-del" title="Delete row" type="button">×</button>
<span class="row-num">6</span>
<button class="row-gear" title="Row menu" type="button">⚙</button>
</span>
</td>
<td class="col-dist">
<div class="with-checkbox">
<input class="is-pristine" type="text" value="0.00">
<input type="checkbox"/>
</input></div>
</td>
<td class="col-time">
<div class="with-checkbox">
<input readonly="" type="text" value="00:45:00"/>
<input type="checkbox"/>
</div>
</td>
<td class="col-speed">
<input class="is-pristine" type="text" value="80"/>
</td>
<td class="col-instr">
<div class="instruction-wrap">
<span class="instruction-prefix">OPEN CONTROL 1</span>
<input class="instruction-input-sl" placeholder="Edit as required" rows="1" type="text"/>
<div class="sg-home-frame" data-sg-home=""></div>
</div>
</td>
<td class="col-turn">
<select class="turn-select">
<option value=""></option>
<option value="TL">TL</option>
<option value="TR">TR</option>
<option value="CSO">CSO</option>
<option value="B/L">B/L</option>
<option value="B/R">B/R</option>
</select>
</td>
</tr>
</tbody>
</table>
</div>
</div><!-- schedule-left -->
<div id="timelineDivider" class="schedule-divider" aria-hidden="true" title="Drag to resize timeline"></div>
<div id="timelineDockMount" class="timeline-dock" aria-hidden="true">
  <div class="timeline-dock-head">
    <div class="timeline-dock-title">Timeline - Slower groups starting first</div>
    <div class="timeline-dock-actions">
      <button id="timelineDockCompact" class="timeline-dock-close timeline-dock-compact" type="button" aria-pressed="false" title="Toggle compact (85%) density">Normal</button>
      <button id="timelineDockFloat" class="timeline-dock-close timeline-dock-float" type="button" aria-pressed="false" title="Toggle float (draggable)">Float</button>
      <button id="timelineDockRefresh" class="timeline-dock-close timeline-dock-refresh" type="button" title="Reload Timeline from the current schedule">Refresh</button>
      <button id="timelineDockClose" class="timeline-dock-close" type="button">Close</button>
    </div>
  </div>
  <div id="timelineFloatResizer" class="timeline-float-resizer" aria-hidden="true" title="Drag to resize timeline"></div>
  <div class="timeline-dock-body">
    <div id="timelineDockHost" style="width:100%; height:100%;"></div>
  </div>
</div>
</div><!-- schedule-split -->

</div>
<div aria-hidden="true" class="lab-rowmenu hidden" id="labRowMenu" role="menu">
<h3>Row options (inserts below)</h3>
<button data-act="insert-below" data-type="instruction" type="button">Insert Instruction</button>
<button data-act="insert-below" data-type="stc" type="button">Insert STC</button>
<button data-act="insert-below" data-type="marshal" type="button">Insert Marshal</button>
<button data-act="insert-below" data-type="open-control" type="button">Insert Open Control</button>
<button data-act="insert-below" data-type="added-time" type="button">Insert Added Time</button>
<button data-act="insert-below" data-type="start-stc" type="button">Insert Start STC</button>
<hr/>
<button data-action="delete-row" type="button">Delete Row… (Ctrl+Alt+D)</button>
</div>
<div aria-hidden="true" class="lab-rowmenu lab-turnmenu hidden" id="labTurnMenu" role="menu">
<h3 class="menu-title">Turn</h3>
<button data-turn="" type="button">(none)</button>
<button data-turn="TL" type="button">TL</button>
<button data-turn="TR" type="button">TR</button>
<button data-turn="CSO" type="button">CSO</button>
<button data-turn="B/L" type="button">B/L</button>
<button data-turn="B/R" type="button">B/R</button>
</div>
<script>

// =========================================================
// Shared helpers (used across script blocks)
// =========================================================
// v7.09: bootstrap guard — prevent any TD_RALLIES writes during initial build/selection
window.__TD_SCHEDULE_BOOTSTRAP_DONE = false;
(function(){
  const _markReady = ()=>{ try{ window.__TD_SCHEDULE_BOOTSTRAP_DONE = true; window.tdTrace && window.tdTrace('[BOOT ready]'); }catch(_){ } };
  try{
    if(document.readyState === 'loading'){
      document.addEventListener('DOMContentLoaded', ()=>{ setTimeout(_markReady, 50); }, { once:true });
    }else{
      setTimeout(_markReady, 50);
    }
  }catch(_){ setTimeout(_markReady, 50); }
})();

function _laneKey(lid, suffix){ return "sg" + String(lid) + suffix; }

function _dsGet(tr, k, fallback){
  try{
    if(tr && tr.dataset && Object.prototype.hasOwnProperty.call(tr.dataset, k)) return tr.dataset[k];
  }catch(_){}
  return fallback;
}

function _dsSet(tr, k, v){
  try{
    if(!tr || !tr.dataset) return;
    if(v == null || v === ""){ try{ delete tr.dataset[k]; }catch(_){ tr.dataset[k] = ""; } return; }
    tr.dataset[k] = String(v);
  }catch(_){}
}

window.CPControlPanel = (function(){
// v6.80 — Pristine scratchpad (JS Map). DOM classes are render-only.
// Key format: "<rowId>|dist", "<rowId>|speed", "<rowId>|sg2speed", "<rowId>|sg2at", etc.
const __pristineMap = (window.__tdPristineMap instanceof Map) ? window.__tdPristineMap : new Map();
window.__tdPristineMap = __pristineMap;

const _pKey = (rowId, field) => `${rowId}|${field}`;
const _pGet = (rowId, field, fallbackEl) => {
  const k = _pKey(rowId, field);
  if (__pristineMap.has(k)) return __pristineMap.get(k) ? 1 : 0;
  // Back-compat: if no entry yet, infer once from element class then store into map.
  const v = (fallbackEl && fallbackEl.classList && fallbackEl.classList.contains('is-pristine')) ? 1 : 0;
  __pristineMap.set(k, v);
  return v;
};
const _pSet = (rowId, field, pristine, el) => {
  const k = _pKey(rowId, field);
  const v = pristine ? 1 : 0;
  __pristineMap.set(k, v);
  if (el && el.classList) {
    el.classList.toggle('is-pristine', !!v);
  }
};


// v7.03 — helper: ensure a stable rowId on a <tr> for pristine tracking
function _ensureUid(tr){
  try{
    if(!tr) return '';
    if(tr.dataset && tr.dataset.rowId) return tr.dataset.rowId;
    const id = 'r' + String(Date.now()) + '_' + String(Math.floor(Math.random()*1000000));
    if(tr.dataset) tr.dataset.rowId = id;
    return id;
  }catch(_){ return ''; }
}

const _pSetForEl = (el, pristine) => {
  if (!el) return;
  const tr = el.closest && el.closest('tr');
  if (!tr) return;
  const rowId = tr.dataset.rowId || _ensureUid(tr);
  // main grid fields
  const td = el.closest('td');
  if (td && td.classList) {
    if (td.classList.contains('col-dist')) return _pSet(rowId, 'dist', pristine, el);
    if (td.classList.contains('col-speed')) return _pSet(rowId, 'speed', pristine, el);
    if (td.classList.contains('col-time')) return _pSet(rowId, 'time', pristine, el);
  }
  // SG inline lanes
  const lane = el.closest && el.closest('.sg-inline-lane');
  if (lane) {
    const lid = lane.getAttribute('data-lane-id') || '';
    if (el.classList && el.classList.contains('sg-speed-input')) return _pSet(rowId, `sg${lid}speed`, pristine, el);
    if (el.classList && el.classList.contains('card-at-input')) return _pSet(rowId, `sg${lid}at`, pristine, el);
  }
};

// Expose pristine helper for other script blocks (keeps v6.77+ scratch semantics)
window._pSetForEl = _pSetForEl;



  let root = null;
  let state = {};
  let hooks = {};

  // Day selector helpers (ported from Controls)
  const _DAY_MONTHS = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];

  function _ddmmyyyyFromDate(d){
    const dd = String(d.getDate()).padStart(2,'0');
    const mm = String(d.getMonth()+1).padStart(2,'0');
    const yyyy = String(d.getFullYear());
    return dd + '-' + mm + '-' + yyyy;
  }
  function _makeDefaultDays(){
    const base = new Date();
    const out = [];
    for(let i=0;i<7;i++){
      const d = new Date(base.getFullYear(), base.getMonth(), base.getDate()+i);
      out.push({ date: _ddmmyyyyFromDate(d) });
    }
    return out;
  }
  function _fmtDdMon(s){
    // Accept either DD-MM-YYYY (legacy) or YYYY-MM-DD (from <input type="date">)
    if(!s || typeof s !== 'string') return '--';

    let m = s.match(/^(\d{1,2})[-\/](\d{1,2})[-\/](\d{2,4})$/);
    if(!m){
      const mi = s.match(/^(\d{4})-(\d{1,2})-(\d{1,2})$/);
      if(mi) m = [mi[0], mi[3], mi[2], mi[1]]; // normalize to [_, dd, mm, yyyy]
    }
    if(!m) return '--';

    const dd = String(parseInt(m[1],10)).padStart(2,'0');
    const mm = parseInt(m[2],10);
    const mon = _DAY_MONTHS[Math.max(1,Math.min(12,mm))-1] || '--';
    return dd + ' ' + mon;
  }
  function _normDays(days){
    const src = (Array.isArray(days) && days.length) ? days : _makeDefaultDays();
    return src.slice(0,7).map(d=>{
      if(typeof d === 'string') return { date: d };
      if(d && typeof d === 'object') return {
        date: d.date || d.dayDate || d.ddmmyyyy || null,
        label: d.label || d.dateLabel || null
      };
      return { date:null, label:null };
    });
  }
  function _buildDayLabel(i, d){
    const dayNo = i + 1;
    const rawLabel = (d && typeof d.label === 'string') ? d.label.trim() : '';
    // Only trust a provided label if it already includes a date (e.g. contains '-' or a month name).
    const hasDateHint = rawLabel && (rawLabel.indexOf('-') !== -1 || /\b(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\b/i.test(rawLabel));
    if (hasDateHint) return rawLabel;
    return 'Day ' + dayNo + ' - ' + _fmtDdMon(d && d.date ? d.date : null);
  }


  function bindActions(){
    if(!root) return;

    // Add Row menu toggle
    const addBtn = root.querySelector('#addRowBtn');
    const menu = root.querySelector('#addRowMenu');
    if(addBtn && menu){
      addBtn.addEventListener('click', ev=>{
        ev.stopPropagation();
        menu.style.display = (menu.style.display==='block'?'none':'block');
      });
      document.addEventListener('click', ev=>{
        if(!menu.contains(ev.target) && ev.target!==addBtn){
          menu.style.display='none';
        }
      });
    }

    // Row type clicks
    root.querySelectorAll('[data-row-type]').forEach(btn=>{
      btn.addEventListener('click', ()=>{
        if(hooks.onAddRow) hooks.onAddRow(btn.dataset.rowType);
      });
    });


    // Day dropdown (Controls-style)
    const dayBtn2 = root.querySelector('#dayPillBtn');
    const dayMenu2 = root.querySelector('#dayPillMenu');
    if(dayBtn2 && dayMenu2){
      function closeDayMenu(){
        dayMenu2.hidden = true;
        dayBtn2.setAttribute('aria-expanded','false');
      }
      function toggleDayMenu(){
        const open = !dayMenu2.hidden;
        if(open){ closeDayMenu(); }
        else{
          dayMenu2.hidden = false;
          dayBtn2.setAttribute('aria-expanded','true');
        }
      }
      dayBtn2.addEventListener('click', ev=>{
        ev.stopPropagation();
        toggleDayMenu();
      });
      dayMenu2.addEventListener('click', ev=>{
        const item = ev.target.closest('.daydd-item');
        if(!item) return;
        const idx = parseInt(item.dataset.dayIndex||'0',10) || 0;
        closeDayMenu();
        if(hooks.onSetDay) hooks.onSetDay(idx);
      });
      document.addEventListener('click', ev=>{
        if(dayMenu2.hidden) return;
        if(!dayMenu2.contains(ev.target) && ev.target!==dayBtn2){
          closeDayMenu();
        }
      });
      document.addEventListener('keydown', ev=>{
        if(ev.key==='Escape') closeDayMenu();
      });
    }

// Other buttons
    root.querySelectorAll('[data-cp-action]').forEach(el=>{
      el.addEventListener('click', ()=>{
        const a = el.dataset.cpAction;
        if(a==='add-row-menu') return; // handled above
        if(a==='set-day'){
          if(hooks.onSetDay) hooks.onSetDay(parseInt(el.dataset.dayIndex));
          return;
        }
        if(a==='print'){
          if(hooks.onPrint) hooks.onPrint();
          else window.print();
          return;
        }
        if(a && hooks['on'+a.charAt(0).toUpperCase()+a.slice(1)]){
          hooks['on'+a.charAt(0).toUpperCase()+a.slice(1)]();
        }
      });
    });

    // Card toggles
    root.querySelectorAll('[data-card-id]').forEach(ch=>{
      ch.addEventListener('change', ()=>{
        if(hooks.onToggleCard) hooks.onToggleCard(ch.dataset.cardId, ch.checked);
      });
    });
  }

  function render(){
    if(!root) return;

    // Title
    const titlePill = root.querySelector('#cpTitlePill');
    if(titlePill && state.rallyTitle!==undefined){
      titlePill.textContent = state.rallyTitle;
    }

    // Issue (r###)
    const rxxPill = root.querySelector('#cpRxxPill');
    if(rxxPill && state.rallyIssue!==undefined){
      rxxPill.textContent = state.rallyIssue || 'r000';
    }

    // Days (Controls-style dropdown)
    const dayWrap = root.querySelector('#dayPillWrap');
    const dayBtn = root.querySelector('#dayPillBtn');
    const dayLabel = root.querySelector('#dayPillLabel');
    const dayMenu = root.querySelector('#dayPillMenu');
    if(dayWrap && dayBtn && dayLabel && dayMenu){
            const idx = state.currentDayIndex || 0;
      const days = _normDays(state.days);
      dayLabel.textContent = _buildDayLabel(idx, days[idx] || {date:null,label:null});
      // rebuild menu
      dayMenu.innerHTML = '';
      days.forEach((d,i)=>{
        const b = document.createElement('button');
        b.type = 'button';
        b.className = 'daydd-item';
        b.setAttribute('role','menuitemradio');
        b.setAttribute('aria-checked', String(i===idx));
        b.dataset.dayIndex = String(i);
        b.textContent = _buildDayLabel(i, d);
        dayMenu.appendChild(b);
      });    }

// Card toggles
    ['card2Visible','card3Visible','card4Visible'].forEach((k,i)=>{
      const cid = 'card'+(i+2);
      const inp = root.querySelector('[data-card-id="'+cid+'"]');
      if(inp && state[k]!==undefined) inp.checked = !!state[k];
    });
  }

  return {
    initControlPanel(el, options){
      root = el;
      state = options || {};
      hooks = {
        onAddRow: options.onAddRow,
        onLoad: options.onLoad,
        onSave: options.onSave,
        onSaveAs: options.onSaveAs,
        onPrint: options.onPrint,
        onOpenTimeline: options.onOpenTimeline,
        onSetDay: options.onSetDay,
        onToggleCard: options.onToggleCard
      };
      bindActions();
      render();
    },
    setState(newState){
      state = Object.assign({}, state, newState);
      render();
    }
  };

    // Workspace snapshot LOAD helper (defined later; duplicate removed in v5.54)


})();
</script><script>

// ─────────────────────────────────────────────────────────────
// Internal row hydrator (v5.54) — builds DOM from TD_RALLIES stored rows (no file I/O)
// (Legacy “rows import” naming removed; this is now an internal hydrator helper.)
// ─────────────────────────────────────────────────────────────
(function(){
  function _toNum(v){
    const n = parseFloat(String(v||'').replace(',','.'));
    return Number.isFinite(n) ? n : null;
  }
  function _getTbody(){
    return document.querySelector('#schedule-body') || document.querySelector('tbody#schedule-body') ||
           document.querySelector('#labScheduleBody') || document.querySelector('tbody');
  }
  function _iterRows(){
    const tbody = _getTbody();
    if(!tbody) return [];
    return Array.from(tbody.querySelectorAll('tr')).filter(tr=>!tr.classList.contains('row-template'));
  }
  function _rowTypeFromTr(tr){
    const ds = tr.dataset || {};
    // Prefer canonical rowObj type if present
    if(ds.rowType) return ds.rowType;
    if(ds.type) return ds.type;
    if(tr.classList.contains('stc-row')) return 'stc';
    if(tr.classList.contains('marshal-row')) return 'marshal';
    if(tr.classList.contains('open-control-row')) return 'openControl';
    if(tr.classList.contains('start-stc-row') || tr.classList.contains('start-stc')) return 'startStc';
    if(tr.classList.contains('added-time-row') || tr.classList.contains('added-time')) return 'addedTime';
    return 'instruction';
  }
  function _ensureUid(tr, preferId){
    if(preferId){
      tr.dataset.sgRowUid = String(preferId);
      return String(preferId);
    }
    if(typeof ensureRowUid === 'function') return ensureRowUid(tr);
    // fallback
    let uid = tr.dataset.sgRowUid;
    if(!uid){
      uid = 'row_' + Math.random().toString(36).slice(2,10);
      tr.dataset.sgRowUid = uid;
    }
    return uid;
  }
  
  // expose pristine helpers for later script blocks
  window._ensureUid = window._ensureUid || _ensureUid;
  window._pSetForEl = window._pSetForEl || _pSetForEl;
function _parseAddedSecs(val){
    if(typeof parseAddedTimeShorthandToSeconds === 'function'){
      try{ return parseAddedTimeShorthandToSeconds(val); }catch(_){}
    }
    // fallback: accept HH:MM:SS / MM:SS / SS / shorthand digits
    const s = String(val||'').trim();
    if(!s) return 0;
    if(s.includes(':')){
      const parts = s.split(':').map(p=>parseInt(p,10));
      if(parts.some(n=>!Number.isFinite(n))) return 0;
      if(parts.length===3) return parts[0]*3600 + parts[1]*60 + parts[2];
      if(parts.length===2) return parts[0]*60 + parts[1];
      return parts[0]||0;
    }
    // digits: treat as seconds if <=2 digits, else MMSS, else HMMSS
    const d = s.replace(/\D/g,'');
    if(!d) return 0;
    if(d.length<=2) return parseInt(d,10);
    if(d.length<=4){
      const mm = parseInt(d.slice(0,-2),10)||0;
      const ss = parseInt(d.slice(-2),10)||0;
      return mm*60 + ss;
    }
    const hh = parseInt(d.slice(0,-4),10)||0;
    const mm = parseInt(d.slice(-4,-2),10)||0;
    const ss = parseInt(d.slice(-2),10)||0;
    return hh*3600 + mm*60 + ss;
  }
  function _fmtAddedSecs(secs){
    if(typeof formatSecondsToTime === 'function'){
      try{ return formatSecondsToTime(secs); }catch(_){}
    }
    secs = Math.max(0, secs|0);
    const hh = String(Math.floor(secs/3600)).padStart(2,'0');
    const mm = String(Math.floor((secs%3600)/60)).padStart(2,'0');
    const ss = String(secs%60).padStart(2,'0');
    return `${hh}:${mm}:${ss}`;
  }

  function importScheduleRowsFromObject(payload){
    // UI pristine restore map (optional)
    try{ window.__rcPristineTouched = (payload && payload.ui && payload.ui.touched) ? payload.ui.touched : null; }catch(_){ window.__rcPristineTouched = null; }
    if(!payload || !Array.isArray(payload.rows)){
      alert("Not a valid schedule rows payload (missing rows).");
      return;
    }
    // Schema is intentionally not enforced: payload is internal (store->DOM hydrate).
    const tbody = _getTbody();
    if(!tbody){
      alert("Schedule table body not found (cannot load rows).");
      return;
    }

    try{ window.__TD_SCHEDULE_HYDRATING = (window.__TD_SCHEDULE_HYDRATING||0) + 1; }catch(_){ }
    try{ window.__TD_SCHEDULE_SUPPRESS_PERSIST = (window.__TD_SCHEDULE_SUPPRESS_PERSIST||0) + 1; }catch(_){ }
    try{ window.tdTrace && window.tdTrace('[SUPPRESS begin]'); }catch(_){ }
    try{ window.tdTrace && window.tdTrace('[HYDRATE begin]'); }catch(_){ }
    try{ _beginScheduleHydrate_ && _beginScheduleHydrate_(); }catch(_){ }
// v4.23: rows import load row-type fidelity.
    // Ensure rows created via menu builders are forced back to the payload-declared type
    // (prevents transient dist=0 auto-classification creating START_STC / OPEN_CONTROL ghosts).
    function _forceRowTypeFromPayload(tr, logicalType, isFirst){
      if(!tr) return;

      // strip known type flags
      tr.classList.remove(
        'start-row','instruction-row','stc-row','marshal-row',
        'open-control-row','start-stc-row','start-stc','added-time-row','added-time','open-control'
      );

      // normalise dataset marker if present
      try{ delete tr.dataset.rowType; }catch(_){}

      // normalise type to kebab (matches payload)
      let lt = String(logicalType||'').trim();
      if(!lt) lt = 'instruction';
      lt = lt.replace(/_/g,'-');
      if(lt === 'addedTime') lt = 'added-time';
      if(lt === 'startStc') lt = 'start-stc';
      if(lt === 'openControl') lt = 'open-control';

      // START row is always row 1 (hard rule)
      if(isFirst){
        tr.classList.add('instruction-row','start-row');
        tr.dataset.rowType = 'start';
        return;
      }

      if(lt === 'marshal'){
        tr.classList.add('marshal-row');
        tr.dataset.rowType = 'marshal';
      }else if(lt === 'stc'){
        tr.classList.add('stc-row');
        tr.dataset.rowType = 'stc';
      }else if(lt === 'start-stc'){
        tr.classList.add('start-stc');
        tr.dataset.rowType = 'start-stc';
        // v5.91 — START STC profile: restart marker; DIST is hard 0.00, no pristine ring, no red alert
        try{
          const _d = tr.querySelector('td.col-dist input[type="text"]');
          if(_d){
            _d.value = '0.00';
            _d.classList.remove('is-pristine','dist-error');
          }
          const _tick = tr.querySelector('td.col-dist .with-checkbox input[type="checkbox"]');
          if(_tick){ _tick.checked = true; }
        }catch(_){}

      }else if(lt === 'open-control'){
        tr.classList.add('open-control-row');
        tr.dataset.rowType = 'open-control';
      }else if(lt === 'added-time'){
        tr.classList.add('added-time');
        tr.dataset.rowType = 'added-time';
      }else{
        tr.classList.add('instruction-row');
        tr.dataset.rowType = 'instruction';
      }
    }

const rowsIn = payload.rows;
// remove current rows (keep template if present)
    Array.from(tbody.querySelectorAll('tr')).forEach(tr=>{
      if(tr.classList.contains('row-template')) return;
      tr.remove();
    });

    // reset models
    window.scheduleRows = [];

    // Create rows using existing row-creation helper if present
    rowsIn.forEach((r, i)=>{
      const logicalType = r.type || 'instruction';
      const _lt = String(logicalType||'').trim().replace(/_/g,'-');
      const _ltLower = _lt.toLowerCase();
      const isAddedTimeRow = (_ltLower === 'added-time' || _ltLower === 'addedtime');

      // Create row via the same builder used by the ADD ROW menu (expects hyphenated types)
      let tr = null;
      const _typeMap = { startStc:'start-stc', openControl:'open-control', addedTime:'added-time' };
      const menuType = _typeMap[logicalType] || logicalType;

      if(window.scheduleLab && typeof window.scheduleLab.addRowFromMenuType==='function'){
        const beforeCount = tbody.querySelectorAll('tr:not(.row-template)').length;
        window.scheduleLab.addRowFromMenuType(menuType);
        const trs = Array.from(tbody.querySelectorAll('tr:not(.row-template)'));
        if(trs.length > beforeCount) tr = trs[trs.length-1];
      }

      if(!tr){
        // fallback: clone first template row of any kind
        const tpl = tbody.querySelector('tr.row-template') || tbody.querySelector('tr');
        tr = tpl ? tpl.cloneNode(true) : document.createElement('tr');
        tr.classList.remove('row-template');
        tbody.appendChild(tr);
      }

      const uid = _ensureUid(tr, r.id || null);

      // dist
      const distEl = tr.querySelector('td.col-dist input');
      if(distEl && r.dist!=null) distEl.value = (()=>{ const n = Number(String(r.dist).replace(',','.')); return Number.isFinite(n) ? n.toFixed(2) : String(r.dist); })();

      // v5.29 — restore print-enable ticks (authoritative row data)
      try{
        const distCb = tr.querySelector('td.col-dist .with-checkbox input[type="checkbox"]');
        if(distCb && typeof r.distEnabled === 'boolean'){ distCb.checked = (r.distEnabled === false); try{ distCb.dispatchEvent(new Event('change',{bubbles:true})); }catch(_e){} }
        const timeCb = tr.querySelector('td.col-time .with-checkbox input[type="checkbox"]');
        if(timeCb && typeof r.timeEnabled === 'boolean'){ timeCb.checked = (r.timeEnabled === false); try{ timeCb.dispatchEvent(new Event('change',{bubbles:true})); }catch(_e){} }
      }catch(_e){}

      // force row classes from payload type (after dist is applied)
      _forceRowTypeFromPayload(tr, logicalType, (i===0));
      // instruction text
      const instrEl = tr.querySelector('td.col-instr .instruction-input-sl') || tr.querySelector('td.col-instr textarea');
      if(instrEl && r.instr!=null) instrEl.value = String(r.instr);

      // v4.44: Restore Added-Time dropdown + page AT box when present in rows import rows.
      if (isAddedTimeRow) {
        try{ const np=tr.querySelector('.at-print-flag'); if(np && typeof r.noPrint==='boolean'){ np.checked = !!r.noPrint; } }catch(_e){}
        const atSelect = tr.querySelector('select.added-select');
        if (atSelect) {
          if (r.atLabel != null) {
            // Prefer matching by visible text
            const want = String(r.atLabel).trim();
            const opts = Array.from(atSelect.options || []);
            const hit = opts.find(o => (o && o.textContent && o.textContent.trim() === want));
            if (hit) atSelect.value = hit.value;
          }
        }
        const atBox = tr.querySelector('input.time-to-add');
        if (atBox) {
          // v6.36: page-level Added Time is stored separately (atAddTime/atAddSec)
          if (r.atAddTime != null) {
            atBox.value = String(r.atAddTime);
          } else if (r.atTime != null) { // legacy
            atBox.value = String(r.atTime);
          } else if (r.atAddSec != null) {
            try { atBox.value = _fmtAddedSecs(Number(r.atAddSec)||0); } catch(_e) {}
          }
          // Normalise/validate so downstream computations behave
          try { if (typeof normaliseAddedTimeInput === 'function') normaliseAddedTimeInput(atBox, false); } catch(_e){}
        }

        // Seed SG overlay source (dataset) so per-SG AT lanes restore correctly on first refresh.
        // IMPORTANT: these come from atTimeBySg/atSecBySg (not the page-level atAddTime).
        try {
          if (r.atTimeBySg) {
            ['1','2','3','4'].forEach(lid => {
              if (r.atTimeBySg[lid] != null) tr.dataset['sg' + lid + 'At'] = String(r.atTimeBySg[lid]);
            });
          } else if (r.atSecBySg) {
            ['1','2','3','4'].forEach(lid => {
              if (r.atSecBySg[lid] != null) tr.dataset['sg' + lid + 'At'] = _fmtAddedSecs(Number(r.atSecBySg[lid]) || 0);
            });
          } else if (r.atSec) { // older legacy
            ['1','2','3','4'].forEach(lid => {
              if (r.atSec[lid] != null) tr.dataset['sg' + lid + 'At'] = _fmtAddedSecs(Number(r.atSec[lid]) || 0);
            });
          } else if (r.atTimeBySg == null && r.atSecBySg == null && r.atTime != null) {
            // last-resort legacy: a single atTime was historically used to seed SG1
            tr.dataset['sg1At'] = String(r.atTime);
          }
        } catch(_e) {}
      }

      // turn
      const sel = tr.querySelector('td.col-turn select.turn-select');
      if (sel && r.turn != null) {
        const want = String(r.turn).trim();
        // Prefer value match; if not found, fall back to matching option label text.
        sel.value = want;
        if (sel.value !== want) {
          const opts = Array.from(sel.options || []);
          const hit = opts.find(o => (o && String(o.value || '').trim() === want) || (o && o.textContent && o.textContent.trim() === want));
          if (hit) sel.value = hit.value;
        }
        sel.dispatchEvent(new Event('change', { bubbles: true }));
      }

      // SG1: restore main grid SPEED
      {
        const sp1 = (r.sgSpeeds) ? r.sgSpeeds['1'] : null;
        const sp1El = tr.querySelector('td.col-speed input[type="text"], td.col-speed input');
        if(sp1El && sp1!=null) sp1El.value = String(sp1);
      }

      // SG2–SG4: write into DOM, and into lane store if it exists (for compatibility)
      for(let lid=2; lid<=4; lid++){
        const k = String(lid);

        const sp = r.sgSpeeds ? r.sgSpeeds[k] : null;
        const at = (isAddedTimeRow && r.atSec) ? r.atSec[k] : null;

        // v4.47 — NOTEBOOK restore: seed row dataset first (authoritative), DOM input is view-only
        try{ if(sp!=null) tr.dataset['sg' + lid + 'Speed'] = String(sp); }catch(_e){}

        const spEl = tr.querySelector(`.sg-inline-lane[data-lane-id="${lid}"] input.sg-speed-input`);
        if(spEl && sp!=null) spEl.value = String(sp);

        const atEl = tr.querySelector(`.sg-inline-lane[data-lane-id="${lid}"] input.card-at-input`);
        if(atEl && at!=null){
          // atSec values are stored in seconds; display as HH:MM:SS in the pill
          const n = Number(at);
          atEl.value = (Number.isFinite(n)) ? _fmtAddedSecs(n) : String(at);
        }
      }
    });

    // After load: refresh lanes/times and restore pristine UI state (bitmap)
    try{ if(typeof scheduleSgRefresh === 'function') scheduleSgRefresh(); }catch(_){ }
    try{ if(typeof queueLaneRecalc === 'function'){ queueLaneRecalc(2); queueLaneRecalc(3); queueLaneRecalc(4); } }catch(_){ }
    try{ _applyPristineBitmap(); }catch(_){}
    try{ requestAnimationFrame(()=>{ try{ _applyPristineBitmap(); }catch(_){} }); }catch(_){}
    // v5.31 — after hydrate, apply print styling from restored ticks (no logic changes)
    try{ if(typeof refreshAllPrintStyles==='function') refreshAllPrintStyles(); }catch(_){ }
    // v4.44: after rows import completes, allow a short settle before writing TD_RALLIES
    try{ _endScheduleHydrate_ && _endScheduleHydrate_(); }catch(_){ }
    try{ window.__TD_SCHEDULE_HYDRATING = Math.max(0, (window.__TD_SCHEDULE_HYDRATING||0) - 1); }catch(_){ }
    try{
      setTimeout(()=>{
        try{ window.__TD_SCHEDULE_SUPPRESS_PERSIST = Math.max(0, (window.__TD_SCHEDULE_SUPPRESS_PERSIST||0) - 1); }catch(_){ }
        try{ window.tdTrace && window.tdTrace('[SUPPRESS end]'); }catch(_){ }
      }, 650);
    }catch(_){ }
    try{ window.tdTrace && window.tdTrace('[HYDRATE end]'); }catch(_){ }
try{ _scheduleSettleSync_ && _scheduleSettleSync_(250); }catch(_){}
  }

  function _applyPristineBitmap(){
    const tbody = _getTbody();
    if(!tbody) return;

    // v3.91 — Pristine rings are UI state: only user edits clear them.
    // Restore from optional ui.touched bitmap in the payload.
    const touched = (typeof window !== 'undefined') ? window.__rcPristineTouched : null;
    if(!touched) return; // back-compat: no UI info, leave template defaults

    // Bit meaning per row (stable, small):
    const B = { DIST:1<<0, TIME:1<<1, SPEED:1<<2, SG2:1<<3, SG3:1<<4, SG4:1<<5, AT2:1<<6, AT3:1<<7, AT4:1<<8 };

    const applyBit = (el, mask, bit)=>{
      if(!el) return;
      const pristine = !(mask & bit);
      window._pSetForEl(el, pristine);
    };

    _iterRows().forEach(tr=>{
      const id = _ensureUid(tr);
      const mask = Number(touched && touched[id]) || 0;

      applyBit(tr.querySelector('td.col-dist input'), mask, B.DIST);
      applyBit(tr.querySelector('td.col-time input'), mask, B.TIME);
      applyBit(tr.querySelector('td.col-speed input[type="text"], td.col-speed input'), mask, B.SPEED);

      for(let lid=2; lid<=4; lid++){
        const sp = tr.querySelector(`.sg-inline-lane[data-lane-id="${lid}"] input.sg-speed-input`);
        applyBit(sp, mask, (lid===2)?B.SG2:(lid===3)?B.SG3:B.SG4);

        if(_rowTypeFromTr(tr) === 'addedTime'){
          const at = tr.querySelector(`.sg-inline-lane[data-lane-id="${lid}"] input.card-at-input`);
          applyBit(at, mask, (lid===2)?B.AT2:(lid===3)?B.AT3:B.AT4);
        }
      }
    });
  }

  // Expose a single hydrator entry point for TD_RALLIES → DOM rebuild
  window.tdHydrateScheduleFromRows = function(payload){
    return importScheduleRowsFromObject(payload);
  };
})();


function initTurnPrintToggle(){
  const body = document.body;
  const headers = Array.from(document.querySelectorAll('.turn-header'));
  if (!headers.length) return;

  // Start from the checkbox state if present.
  const anyChk = document.querySelector('.turn-print-toggle');
  if (anyChk) {
    const off = !anyChk.checked;
    body.classList.toggle('turn-print-off', off);
  }

  function setOff(off){
    body.classList.toggle('turn-print-off', !!off);
    document.querySelectorAll('.turn-print-toggle').forEach(chk => { chk.checked = !off; });
  }
  function toggle(){ setOff(!body.classList.contains('turn-print-off')); }

  headers.forEach(h => {
    h.addEventListener('click', (e)=>{ e.preventDefault(); toggle(); });
    h.addEventListener('keydown', (e)=>{
      if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); toggle(); }
    });
  });
}


// v5.50 — Workspace SAVE protocol (Admin-owned workspace handle; Schedule uses it)
(function(){
  // Admin is the only page allowed to create/upgrade the workspace DB.
  // Schedule must only *read* the existing Admin handle and must never probe/create other DBs.
  const DB_NAME  = 'TD_WORKSPACE_DB_v1';
  const STORE    = 'kvs';
  const KEY_NAME = 'workspaceDirHandle';

  async function idbDbExists_(name){
    try{
      if(typeof indexedDB.databases !== 'function') return true; // best-effort: cannot preflight
      const list = await indexedDB.databases();
      return Array.isArray(list) && list.some(d => d && d.name === name);
    }catch(_){ return true; }
  }

  function tryOpen_(dbName){
    return new Promise((resolve, reject)=>{
      try{
        const req = indexedDB.open(dbName);
        req.onsuccess = ()=>resolve(req.result);
        req.onerror = ()=>reject(req.error);
      }catch(e){ reject(e); }
    });
  }

  async function idbGetAny_(){
    // Preflight: avoid creating DBs when Admin has not set workspace yet.
    const exists = await idbDbExists_(DB_NAME);
    if(!exists) return null;

    let db = null;
    try{ db = await tryOpen_(DB_NAME); }catch(_){ db = null; }
    if(!db) return null;

    try{
      if(!db.objectStoreNames.contains(STORE)) return null;
      const val = await new Promise((resolve)=>{
        try{
          const tx = db.transaction(STORE, 'readonly');
          const st = tx.objectStore(STORE);
          const req = st.get(KEY_NAME);
          req.onsuccess = ()=>resolve(req.result);
          req.onerror = ()=>resolve(undefined);
        }catch(_){ resolve(undefined); }
      });
      return val || null;
    }finally{
      try{ db.close(); }catch(_){ }
    }
  }

  function tdRead_(){
    const raw = localStorage.getItem('TD_RALLIES');
    if(!raw) return null;
    try{ return JSON.parse(raw); }catch(_){ return null; }
  }

  function tdWrite_(td){
  // v6.98 — Mirror/boot write fence: prevent TD_RALLIES overwrites during day-mirror + iframe boot
  try{
    const now = Date.now();
    if(!window.__TD_SCHED_BOOT_TS) window.__TD_SCHED_BOOT_TS = now;
    if(window.__TD_DAY_MIRROR_APPLYING) return false;
    if(window.__TD_SCHED_DAY_SWITCHING) return false;
    if(window.__TD_SCHED_WRITE_FENCE_UNTIL && now < window.__TD_SCHED_WRITE_FENCE_UNTIL) return false;
    if(window.__TD_SCHED_BOOT_TS && (now - window.__TD_SCHED_BOOT_TS) < 1200) return false;
  }catch(_e){}
    const raw0 = localStorage.getItem('TD_RALLIES');
    if(!raw0) return false;
    try{ localStorage.setItem('TD_RALLIES', JSON.stringify(td)); return true; }catch(_){ return false; }
  }

  // v6.31 — explicit FORCE write helper
  // Only used by explicit user LOAD flows. Normal schedule writes must never create TD_RALLIES.
  function tdWriteForce_(td){
    try{ localStorage.setItem('TD_RALLIES', JSON.stringify(td)); return true; }catch(_){ return false; }
  }


  // v6.31 — Workspace rehydrate on boot (Schedule)
  // If TD_RALLIES is missing workspaceReady but an Admin-owned workspace handle exists in IDB,
  // stamp TD_RALLIES.global.workspaceReady so Save/Load can be used from any page.
  function wsUiApply_(td){
    try{
      const ready = !!(td && td.global && td.global.workspaceReady);
      const label = (td && td.global && typeof td.global.workspaceLabel === 'string') ? td.global.workspaceLabel : '';
      const sb = document.getElementById('saveBtn');
      const lb = document.getElementById('loadBtn');
      if (sb) { sb.disabled = !ready; sb.title = ready ? ('Workspace: ' + (label||'set')) : 'Workspace not set (open Admin → Set Workspace)'; }
      if (lb) { lb.disabled = !ready; lb.title = ready ? ('Workspace: ' + (label||'set')) : 'Workspace not set (open Admin → Set Workspace)'; }
    }catch(_e){}
  }

  async function wsRehydrateFromIdbOnBoot_(){
    try{
      let td = tdRead_();
      // RULE: Schedule must not create TD_RALLIES on boot.
      if(!td){ return false; }
      td.global = td.global || {};
      if(td.global.workspaceReady){
        wsUiApply_(td);
        return false;
      }
      let handle = null;
      try{ handle = await idbGetAny_(); }catch(_e){ handle = null; }
      if(!handle){
        wsUiApply_(td);
        return false;
      }
      td.global.workspaceReady = true;
      if(typeof td.global.workspaceLabel !== 'string' || !td.global.workspaceLabel.trim()){
        td.global.workspaceLabel = 'Workspace';
      }
      try{ localStorage.setItem('TD_RALLIES', JSON.stringify(td)); }catch(_e){}
      wsUiApply_(td);
      return true;
    }catch(_e){
      return false;
    }
  }

  // Run after DOM is ready so we can safely update Save/Load buttons.
  try{
    if(document.readyState === 'loading'){
      document.addEventListener('DOMContentLoaded', ()=>{ wsRehydrateFromIdbOnBoot_(); }, { once:true });
    }else{
      wsRehydrateFromIdbOnBoot_();
    }
  }catch(_e){}

  function getRid_(){
    try{
      const td = tdRead_();
      if(window.tdScheduleGetActiveRid_){
        const rid = window.tdScheduleGetActiveRid_();
        if(rid) return rid;
      }
      // fallback for older snapshots
      if(td){
        const rid2 = td.currentRid || td.activeRid || td.currentRallyId || null;
        if(rid2) return String(rid2);
      }
    }catch(_){ }
    return '';
  }

  function getRallyTitle_(td, rid){
    try{
      const r = td && td.rallies && td.rallies[rid] ? td.rallies[rid] : null;
      const meta = r && r.meta ? r.meta : null;
      const admin = r && r.admin ? r.admin : null;
      return String((meta && meta.title) || (admin && (admin.title || admin.rallyTitle)) || r.title || 'Rally').trim() || 'Rally';
    }catch(_){ return 'Rally'; }
  }

  function sanitizeFolder_(s){
    return String(s||'Rally').trim().replace(/[^a-z0-9\-_ ]/gi,'').replace(/\s+/g,' ').trim().replace(/ /g,'_') || 'Rally';
  }


  function tdToast_(msg, ms){
    try{
      const el = document.getElementById('tdToast');
      if(!el) return;
      el.textContent = String(msg||'');
      el.classList.add('show');
      const dur = (ms==null) ? 1700 : Math.max(400, Number(ms)||1700);
      try{ clearTimeout(window.__TD_TOAST_T__); }catch(_){}
      window.__TD_TOAST_T__ = setTimeout(()=>{ try{ el.classList.remove('show'); }catch(_e){} }, dur);
    }catch(_){}
  }

function nextRref_(td, rid){
    const r = (td && td.rallies && td.rallies[rid]) ? td.rallies[rid] : null;
    if(!r){ throw new Error('Rally missing for SAVE'); }
    r.meta = r.meta || {};
    let n = parseInt(r.meta.rCounter,10);
    if(!Number.isFinite(n) || n<1) n = 1;
    const ref = 'r' + String(n).padStart(3,'0');
    r.meta.rCounter = n + 1;
    r.meta.lastSavedAt = new Date().toISOString();
    r.meta.lastSavedRef = ref;
    return ref;
  }

  async function writeFile_(dirHandle, filename, text){
    const fileHandle = await dirHandle.getFileHandle(filename, { create:true });
    const writable = await fileHandle.createWritable();
    await writable.write(text);
    await writable.close();
  }

  window.tdWorkspaceSaveSnapshot = async function(){
  try{
    const td = tdRead_();
    if(!td || !td.rallies){
      alert('Nothing to save: TD_RALLIES is empty.');
      return false;
    }
    if(!window.isSecureContext){
      alert('SAVE requires https or localhost.');
      return false;
    }
    if(!window.showDirectoryPicker && !window.showSaveFilePicker){
      alert('SAVE requires a modern browser (Chrome/Edge) File System Access API.');
      return false;
    }

    // Workspace handle is Admin-owned. Prefer Admin's live handle, else restore from IndexedDB.
    let workspace = null;
    try{
      if (window.__WORKSPACE && window.__WORKSPACE.ready && window.__WORKSPACE.handle){
        workspace = window.__WORKSPACE.handle;
      }
    }catch(_e){ workspace = null; }
    if(!workspace){
      try{ workspace = await idbGetAny_(); }catch(_e){ workspace = null; }
    }
    if(!workspace){
      alert('Workspace not set. Open Admin and set the workspace folder, then SAVE again.');
      return false;
    }

    // Preflight: ensure we have readwrite permission on the stored directory handle.
    let perm = null;
    try{ perm = await workspace.queryPermission({mode:'readwrite'}); }catch(_e){ perm = null; }
    if(perm !== 'granted'){
      try{ perm = await workspace.requestPermission({mode:'readwrite'}); }catch(_e){ perm = null; }
    }
    if(perm !== 'granted'){
      try{
        if(td && td.global){
          td.global.workspaceReady = false;
          localStorage.setItem('TD_RALLIES', JSON.stringify(td));
        }
      }catch(_e){}
      try{ if(window.__WORKSPACE) window.__WORKSPACE.ready = false; }catch(_e){}
      alert('Set Rally Workspace (permission required). Open Admin and set the workspace folder, then SAVE again.');
      return false;
    }


    const rid = getRid_();
    td.rallies = td.rallies || {};
    if(!td.rallies[rid]){
      alert('Rally not found in TD_RALLIES. Open Admin and select a rally, then SAVE again.');
      return false;
    }

    const rallyNameRaw = getRallyTitle_(td, rid);
    const rallyName = String(rallyNameRaw || '').trim();
    if(!rallyName){
      alert('Rally title missing. Open Admin and commit the rally title, then SAVE again.');
      return false;
    }

    // Next r### (match Admin semantics)
    let curIssue = 'r000';
    try{
      curIssue = (td.rallies[rid].meta && td.rallies[rid].meta.issue) ? String(td.rallies[rid].meta.issue).trim() : 'r000';
    }catch(_e){ curIssue = 'r000'; }
    let n = parseInt(curIssue.replace(/[^0-9]/g,''), 10);
    if(!isFinite(n)) n = 0;
    const nextIssue = 'r' + String(n + 1).padStart(3, '0');

    // Build snapshot wrapper (match Admin)
    const fullData = {
      kind: 'TD_RALLIES_SNAPSHOT',
      version: String(document.title || 'Schedule').trim(),
      savedAt: new Date().toISOString(),
      activeRallyId: rid,
      td_rallies: td
    };

    // Folder based on rally title (prefer raw; fallback to sanitized if needed)
    try{
      let rallyDir = null;
      let folderUsed = rallyName;
      try{
        rallyDir = await workspace.getDirectoryHandle(rallyName, { create:true });
      }catch(_e){
        folderUsed = sanitizeFolder_(rallyName);
        rallyDir = await workspace.getDirectoryHandle(folderUsed, { create:true });
      }

      const fileHandle = await rallyDir.getFileHandle(nextIssue + '.json', { create:true });
      const writable = await fileHandle.createWritable();
      await writable.write(JSON.stringify(fullData, null, 2));
      await writable.close();
    }catch(e){
      const msg = String(e && (e.name || e.message) ? (e.name + ': ' + e.message) : e);
      // NotAllowed / prompt permission or other FS errors: route to Set Rally Workspace.
      try{
        if(td && td.global){
          td.global.workspaceReady = false;
          localStorage.setItem('TD_RALLIES', JSON.stringify(td));
        }
      }catch(_e){}
      try{ if(window.__WORKSPACE) window.__WORKSPACE.ready = false; }catch(_e){}
      alert('Set Rally Workspace (write permission). Then try SAVE again.\n\n' + msg);
      return false;
    }

    // Mirror issue into TD_RALLIES meta so all pages stay aligned.
    try{
      td.rallies[rid].meta = (td.rallies[rid].meta && typeof td.rallies[rid].meta === 'object') ? td.rallies[rid].meta : {};
      td.rallies[rid].meta.issue = nextIssue;
      td.rallies[rid].meta.lastSavedAt = fullData.savedAt;
      td.rallies[rid].meta.lastSavedBy = 'Schedule';
    }catch(_e){}

    tdWriteForce_(td);

    try{ window.dispatchEvent(new CustomEvent('TD_RALLIES_CHANGED', { detail:{ rid: rid, reason:'WORKSPACE_SAVE' } })); }catch(_e){}
    try{ false && console.log('[WORKSPACE_SAVE]', { rid, rallyName, issue: nextIssue }); }catch(_e){}
    try{ tdToast_('Saved: ' + folderUsed + ' / ' + nextIssue + '.json'); }catch(_e){}
    return true;
  }catch(e){
    alert('SAVE failed: ' + (e && e.message ? e.message : e));
    return false;
  }
};
  // v5.94 — Load warning modal (Schedule)
  function openLoadWarnModal_(){
    return new Promise((resolve)=>{
      const modal = document.getElementById('loadWarnModal');
      const btnCancel = document.getElementById('lwCancelBtn');
      const btnLoad = document.getElementById('lwLoadBtn');
      if(!modal || !btnCancel || !btnLoad){
        // Fallback (should not happen)
        try{ resolve(window.confirm('Loading will overwrite current work. Continue?')); }catch(_e){ resolve(false); }
        return;
      }
      const cleanup = ()=>{
        try{ btnCancel.onclick = null; btnLoad.onclick = null; }catch(_e){}
        try{ modal.style.display = 'none'; modal.setAttribute('aria-hidden','true'); }catch(_e){}
      };
      btnCancel.onclick = ()=>{ cleanup(); resolve(false); };
      btnLoad.onclick   = ()=>{ cleanup(); resolve(true);  };
      try{
        modal.style.display = 'flex';
        modal.setAttribute('aria-hidden','false');
      }catch(_e){}
    });
  }

// v5.54 — Workspace LOAD protocol (shared entry point; uses Admin-owned workspace handle)
  window.tdWorkspaceLoadSnapshot = async function(){
  try{
    if(!window.isSecureContext){
      alert('LOAD requires https or localhost.');
      return false;
    }
    if(!window.showOpenFilePicker){
      alert('LOAD requires a modern browser (Chrome/Edge) File System Access API.');
      return false;
    }

    // Workspace handle is Admin-owned. Prefer Admin's live handle, else restore from IndexedDB.
    let workspace = null;
    try{
      if (window.__WORKSPACE && window.__WORKSPACE.ready && window.__WORKSPACE.handle){
        workspace = window.__WORKSPACE.handle;
      }
    }catch(_e){ workspace = null; }
    if(!workspace){
      try{ workspace = await idbGetAny_(); }catch(_e){ workspace = null; }
    }
    if(!workspace){
      alert('Workspace not set. Open Admin and set the workspace folder, then try LOAD again.');
      return false;
    }

    const ok = await openLoadWarnModal_();
    if(!ok) return false;


    const handles = await window.showOpenFilePicker({
      multiple: false,
      types: [{ description: 'TD Rallies Snapshot', accept: { 'application/json': ['.json'] } }],
      // Try to start in workspace, but allow user to browse anywhere
      startIn: workspace
    });
    const fh = handles && handles[0] ? handles[0] : null;
    if(!fh) return false;

    const file = await fh.getFile();
    const jsonText = await file.text();

    let parsed = null;
    try{ parsed = JSON.parse(String(jsonText||'{}')); }catch(e){
      alert('Could not read JSON: ' + (e && e.message ? e.message : e));
      return false;
    }

    // Accept either wrapper snapshots (preferred) or raw TD_RALLIES objects (legacy)
    let td = null;
    if (parsed && parsed.kind === 'TD_RALLIES_SNAPSHOT' && parsed.td_rallies){
      td = parsed.td_rallies;
    }else{
      td = parsed;
    }

    if(!td || !td.rallies){
      alert('Not a valid TD_RALLIES snapshot (missing rallies).');
      return false;
    }

    tdWriteForce_(td);

    let rid = null;
    try{ rid = (parsed && parsed.activeRallyId) ? String(parsed.activeRallyId) : null; }catch(_e){ rid = null; }
    if(!rid){
      try{ rid = td.global && td.global.activeRallyId ? String(td.global.activeRallyId) : null; }catch(_e){ rid = null; }
    }
    if(!rid){
      try{ rid = Object.keys(td.rallies||{})[0] || null; }catch(_e){ rid = null; }
    }
    if(rid){
      try{
        td.global = (td.global && typeof td.global === 'object') ? td.global : {};
        td.global.activeRallyId = rid;
        tdWriteForce_(td);
      }catch(_e){}
    }

    try{ window.dispatchEvent(new CustomEvent('TD_RALLIES_CHANGED', { detail:{ rid: rid || null, reason:'WORKSPACE_LOAD' } })); }catch(_e){}
    try{ false && console.log('[WORKSPACE_LOAD]', { rid: rid || null, file: (file && file.name) ? file.name : '' }); }catch(_e){}
    try{ tdToast_('Loaded: ' + ((file && file.name) ? file.name : 'snapshot')); }catch(_e){}

    // Clean re-hydrate: simplest + safest is reload (allow toast to render)
    try{ setTimeout(()=>{ try{ location.reload(); }catch(_e2){} }, 300); }catch(_e){}
    return true;
  }catch(e){
    alert('LOAD failed: ' + (e && e.message ? e.message : e));
    return false;
  }
};})();


// ─────────────────────────────────────────────────────────────
// Admin-owned TD_RALLIES reader helpers (v5.64)
// - Schedule NEVER creates TD_RALLIES
// - Schedule resolves active RID from TD_RALLIES (Admin-owned)
// ─────────────────────────────────────────────────────────────
(function(){
  function tdRead_(){
    try{ const raw = localStorage.getItem('TD_RALLIES'); if(!raw) return null; return JSON.parse(raw); }catch(_){ return null; }
  }
  function tdGetActiveRid_(td){
    try{
      // Preferred: Admin global
      const g = td && td.global ? td.global : null;
      const rid = (g && (g.activeRallyId || g.activeRid || g.activeRally)) || td.activeRid || td.currentRid || td.currentRallyId || td.__ACTIVE_RID__ || null;
      return rid ? String(rid).trim() : null;
    }catch(_){ return null; }
  }
  function getAdminMeta_(td){
    const rid = tdGetActiveRid_(td);
    if(!rid) return { ok:false, rid:null };
    const rally = td && td.rallies && td.rallies[rid] ? td.rallies[rid] : null;
    const meta = rally && rally.meta ? rally.meta : {};
    const admin = rally && rally.admin ? rally.admin : {};
    const ui = admin && admin.ui ? admin.ui : {};
    const dayCount = Math.max(1, Math.min(10, Number(ui.dayCount || 1) || 1));
    const sgCount  = Math.max(1, Math.min(4, Number(ui.sgCount || 1) || 1));
    const days = [];
    try{
      const admDays = admin.days || {};
      for(let i=1;i<=dayCount;i++){
        const d = admDays[String(i)] || {};
        days.push({ label: 'Day ' + i, date: d.date || null, start: d.start || null, incMin: d.incMin || null });
      }
    }catch(_){ }
    const speeds = {};
    try{
      const sgs = admin.speedGroups || {};
      for(let i=1;i<=4;i++){
        const sg = sgs[String(i)] || sgs[i] || null;
        if(sg && sg.speed!=null) speeds[String(i)] = Number(sg.speed);
      }
    }catch(_){ }
    return {
      ok: true,
      rid,
      title: String(meta.title || 'Rally'),
      issue: String(meta.issue || ''),
      dayCount,
      sgCount,
      days,
      speeds
    };
  }

  window.tdScheduleRead_ = tdRead_;
  window.tdScheduleGetActiveRid_ = function(){ return tdGetActiveRid_(tdRead_()); };
  window.tdScheduleGetAdminMeta_ = function(){ return getAdminMeta_(tdRead_()); };
})();

// ─────────────────────────────────────────────────────────────
// ─────────────────────────────────────────────────────────────
// Days A-simple \(v5\.57\) — dayKey routing only (no date logic yet)
// Single source of truth: TD_RALLIES. Current day selection is stored in-memory here.
// ─────────────────────────────────────────────────────────────
(function(){
  const DEFAULT_DAYKEY = '1';
  window.__TD_SCHEDULE_CURRENT_DAYKEY = window.__TD_SCHEDULE_CURRENT_DAYKEY || DEFAULT_DAYKEY;

  window.getScheduleDayKey_ = function(){
    const k = String(window.__TD_SCHEDULE_CURRENT_DAYKEY || DEFAULT_DAYKEY).trim();
    return k || DEFAULT_DAYKEY;
  };

  // Capture a safe "empty day" DOM snapshot (the starter table as shipped) so new days can start blank.
  window.__TD_SCHEDULE_EMPTY_DAY_HTML = window.__TD_SCHEDULE_EMPTY_DAY_HTML || null;
  window.captureEmptyDaySnapshot_ = function(){
    try{
      const tbody = document.querySelector('tbody#schedule-body');
      if(!tbody) return false;
      if(window.__TD_SCHEDULE_EMPTY_DAY_HTML) return true;
      // Capture only visible, non-template rows as the baseline starter set.
      window.__TD_SCHEDULE_EMPTY_DAY_HTML = tbody.innerHTML;
      return true;
    }catch(_){ return false; }
  };

  window.setScheduleDayIndex_ = function(dayIndex0){
    const idx = Number(dayIndex0||0);
    const newKey = String(Math.max(1, idx+1));
    const oldKey = window.getScheduleDayKey_();
    if(newKey === oldKey) return;

    // v7.03 — Day switch is navigation-only: do NOT sync/write TD_RALLIES here.
    // v6.98 — Write fence during day switch (prevents cross-page overwrite races)
    try{ window.__TD_SCHED_WRITE_FENCE_UNTIL = Date.now() + 1600; }catch(_e){}

    // v6.96 — Day switch guard: suppress TD_RALLIES writes during DOM rebuild/hydrate
    window.__TD_SCHED_DAY_SWITCHING = true;

    // Switch key
    window.__TD_SCHEDULE_CURRENT_DAYKEY = newKey;

    // Update control panel label immediately (if present)
    try{ if(window.CPControlPanel && typeof window.CPControlPanel.setState==='function') window.CPControlPanel.setState({ currentDayIndex: idx }); }catch(_){ }

    // Rebuild grid for the new day
    try{
      const raw = localStorage.getItem('TD_RALLIES');
      const td = raw ? JSON.parse(raw) : null;
      const meta = (window.tdScheduleGetAdminMeta_?window.tdScheduleGetAdminMeta_():{ok:false});
      const rid = meta.ok ? meta.rid : null;
      const rally = (td && rid && td.rallies && td.rallies[rid]) ? td.rallies[rid] : null;
      const storedRows = rally && rally.schedule && rally.schedule.days && rally.schedule.days[newKey] && Array.isArray(rally.schedule.days[newKey].rows) ? rally.schedule.days[newKey].rows : null;

      if(storedRows && storedRows.length){
        if(typeof window.autoHydrateScheduleFromTdRallies==='function') window.autoHydrateScheduleFromTdRallies(newKey);
      } else {
        // New/empty day — restore starter DOM snapshot
        const tbody = document.querySelector('tbody#schedule-body');
        if(tbody && window.__TD_SCHEDULE_EMPTY_DAY_HTML){
          tbody.innerHTML = window.__TD_SCHEDULE_EMPTY_DAY_HTML;
          // Re-snapshot models + refresh styling
          try{ if(window.scheduleLab && typeof window.scheduleLab.snapshot==='function') window.scheduleRows = window.scheduleLab.snapshot(); }catch(_){ }
          try{ if(typeof refreshAllPrintStyles==='function') refreshAllPrintStyles(); }catch(_){ }
          try{ if(typeof window.sgAdapterRefresh==='function') window.sgAdapterRefresh(); }catch(_){ }
        }
      }

      // Notify other pages (Controls) which day is now active (same-tab listeners)
      try{ window.dispatchEvent(new CustomEvent('TD_RALLIES_CHANGED', { detail:{ rid: (window.tdScheduleGetActiveRid_?window.tdScheduleGetActiveRid_():null) || '', dayKey:newKey, reason:'DAY_SELECT' } })); }catch(_){ }

      // Cross-tab "telephone line": mirror active day without requiring TD_RALLIES

      // v7.13: TD_ACTIVE_DAY write discipline:
      // - Only user/day-mirror events may write TD_ACTIVE_DAY.
      // - Init/open must never overwrite an existing TD_ACTIVE_DAY.
      window.__tdSetActiveDay = window.__tdSetActiveDay || function(dayNo, reason){
        try{
          const v = String(dayNo);
          const r = String(reason||'');
          if(window.tdTrace) window.tdTrace(`[TD_ACTIVE_DAY] set=${v} reason=${r}`);
          if(r==='init' || r==='open' || r==='select' || r==='hydrate'){
            const cur = (()=>{ try{ return localStorage.getItem('TD_ACTIVE_DAY'); }catch(_){ return null; } })();
            if(cur!==null && cur!==undefined && cur!==''){
              if(window.tdTrace) window.tdTrace(`[TD_ACTIVE_DAY] skip-init existing=${cur}`);
              return;
            }
          }
          try{ localStorage.setItem('TD_ACTIVE_DAY', v); }catch(_e){}
        }catch(_e){}
      };
      try{
        const dayNo = Number(newKey)||1;
        if(!window.__TD_DAY_MIRROR_APPLYING){
          try{ window.__tdSetActiveDay(dayNo,'mirror'); }catch(_e){}
          try{
            if('BroadcastChannel' in window){
              window.__TD_DAY_BC = window.__TD_DAY_BC || new BroadcastChannel('TD_RALLIES_CHANGED');
              window.__TD_DAY_BC.postMessage({ type:'TD_RALLIES_CHANGED', reason:'DAY_SELECT', dayNo, ts: Date.now() });
            }
          }catch(_e){}
        }
      }catch(_e){}
}catch(_){ }
    try{ window.__TD_SCHED_DAY_SWITCHING = false; }catch(_e){}
  };
})();
document.addEventListener('DOMContentLoaded', function(){
  // Day mirror (Schedule ↔ Controls) for when both pages are open in separate tabs/windows.
  // Uses localStorage key TD_ACTIVE_DAY as a lightweight signal, plus BroadcastChannel when available.
  try{
    if(!window.__TD_DAY_MIRROR_INIT){
      window.__TD_DAY_MIRROR_INIT = true;
      // New Rally hard reset (distinct signal; not tied to store/date/title churn)
      try{
        if(!window.__TD_RALLY_RESET_INIT && ('BroadcastChannel' in window)){
          window.__TD_RALLY_RESET_INIT = true;

          const hardResetScheduleTable_ = (why) => {
            try{ if(typeof window.captureEmptyDaySnapshot_==='function') window.captureEmptyDaySnapshot_(); }catch(_){ }
            try{
              // Force Day 1 view label (without persisting current day)
              window.__TD_SCHEDULE_CURRENT_DAYKEY = '1';
              try{ window.__tdSetActiveDay('1','init'); }catch(_){ }
              try{ if(window.CPControlPanel && typeof window.CPControlPanel.setState==='function') window.CPControlPanel.setState({ currentDayIndex: 0 }); }catch(_){ }
            }catch(_){ }

            try{
              const tbody = document.querySelector('tbody#schedule-body');
              if(tbody && window.__TD_SCHEDULE_EMPTY_DAY_HTML){
                tbody.innerHTML = window.__TD_SCHEDULE_EMPTY_DAY_HTML;
                try{ if(window.scheduleLab && typeof window.scheduleLab.snapshot==='function') window.scheduleRows = window.scheduleLab.snapshot(); }catch(_){ }
                try{ if(typeof refreshAllPrintStyles==='function') refreshAllPrintStyles(); }catch(_){ }
                try{ if(typeof window.sgAdapterRefresh==='function') window.sgAdapterRefresh(); }catch(_){ }
              }
            }catch(_){ }
          };

          window.__TD_RALLY_RESET_BC = window.__TD_RALLY_RESET_BC || new BroadcastChannel('TD_RALLY_RESET');
          window.__TD_RALLY_RESET_BC.onmessage = (ev) => {
            const d = ev && ev.data ? ev.data : null;
            const reason = d && (d.reason || d.type) ? String(d.reason || d.type) : '';
            if(reason === 'new_rally' || reason === 'NEW_RALLY' || reason === 'reset'){
              hardResetScheduleTable_(reason);
            } else {
              // Be permissive: any TD_RALLY_RESET message triggers a hard reset.
              hardResetScheduleTable_('TD_RALLY_RESET');
            }
          };
        }
      }catch(_){ }

      const applyDayNo = (dayNo, source) => {
        dayNo = Number(dayNo);
        if(!(dayNo>=1 && dayNo<=7)) return;
        const cur = Number(window.getScheduleDayKey_?window.getScheduleDayKey_():'1')||1;
        if(dayNo === cur) return;
        window.__TD_DAY_MIRROR_APPLYING = true;
        try{ window.__TD_SCHED_WRITE_FENCE_UNTIL = Date.now() + 1600; }catch(_e){}
        try{ if(typeof window.setScheduleDayIndex_==='function') window.setScheduleDayIndex_(dayNo-1); }catch(_e){}
        window.__TD_DAY_MIRROR_APPLYING = false;
      };

      // storage-event listener (fires in other tabs/windows)
      window.addEventListener('storage', function(e){
        try{
          if(e && e.key === 'TD_ACTIVE_DAY'){
            applyDayNo(e.newValue, 'storage');
          }
        }catch(_e){}
      });

      // BroadcastChannel listener (best-effort)
      try{
        if('BroadcastChannel' in window){
          window.__TD_DAY_BC = window.__TD_DAY_BC || new BroadcastChannel('TD_RALLIES_CHANGED');
          window.__TD_DAY_BC.onmessage = function(ev){
            try{
              const msg = ev && ev.data ? ev.data : null;
              if(!msg) return;
              if(msg.type === 'TD_RALLIES_CHANGED' && msg.dayNo != null){
                applyDayNo(msg.dayNo, 'bc');
              }
            }catch(_e){}
          };
        }
      }catch(_e){}

            // Boot reconcile: if today's date matches r.admin.days[*].date, set TD_ACTIVE_DAY to that day
      try{
        const todayIso = new Date().toISOString().slice(0,10);

        let td=null, rid=null, days=null, match=null;
        try{ td = JSON.parse(localStorage.getItem('TD_RALLIES')||'null'); }catch(_x){ td=null; }

        if(td && td.rallies){
          try{ rid = td.global && td.global.activeRallyId ? String(td.global.activeRallyId) : null; }catch(_x){ rid=null; }
          if(!rid){ try{ rid = Object.keys(td.rallies||{})[0] || null; }catch(_x){ rid=null; } }

          if(rid && td.rallies[rid] && td.rallies[rid].admin && td.rallies[rid].admin.days){
            days = td.rallies[rid].admin.days;
            try{
              const keys = Object.keys(days).sort((a,b)=>Number(a)-Number(b));
              for(const k of keys){
                const d = days[k] && days[k].date ? String(days[k].date).slice(0,10) : '';
                if(d && d === todayIso){ match = String(k); break; }
              }
            }catch(_x){}
          }
        }

        const pick = match || localStorage.getItem('TD_ACTIVE_DAY');
        if(pick!=null){
          if(match){
            try{
              if(!window.__TD_DAY_MIRROR_APPLYING){
                window.__tdSetActiveDay(match,'mirror-match');
              }
            }catch(_x){}
          }
          applyDayNo(pick, match ? 'boot_rallyDate' : 'boot');
        }
      }catch(_e){}
    }
  }catch(_e){}

  try{ window.captureEmptyDaySnapshot_ && window.captureEmptyDaySnapshot_(); }catch(_){ }
  // v5.25 — auto-hydrate grid from TD_RALLIES after settle (no writes)
  setTimeout(()=>{ try{ window.autoHydrateScheduleFromTdRallies && window.autoHydrateScheduleFromTdRallies(); }catch(_){} }, 450);

  // AT debug overlay is OFF by default; toggled only via the on-page button.
  const shell = document.getElementById('cp-root-shell');
  if (shell && window.CPControlPanel) {
    window.CPControlPanel.initControlPanel(shell, {
      rallyTitle: (window.tdScheduleGetAdminMeta_&&window.tdScheduleGetAdminMeta_().ok)?window.tdScheduleGetAdminMeta_().title:'(Open Admin to load rally)',
      rallyIssue: (window.tdScheduleGetAdminMeta_&&window.tdScheduleGetAdminMeta_().ok)?window.tdScheduleGetAdminMeta_().issue:'r000',
      currentDayIndex: Math.max(0, (Number(window.getScheduleDayKey_?window.getScheduleDayKey_():'1')||1)-1),
      days: (window.tdScheduleGetAdminMeta_&&window.tdScheduleGetAdminMeta_().ok)?window.tdScheduleGetAdminMeta_().days:[],
      card2Visible: false,
      card3Visible: false,
      card4Visible: false,
      hasTimeline: true,
      canPrint: false,
      onAddRow: function(rowType){ if(window.scheduleLab&&typeof window.scheduleLab.addRowFromMenuType==='function'){ window.scheduleLab.addRowFromMenuType(rowType);} },
      onSave: function(){ try{ window.tdWorkspaceSaveSnapshot && window.tdWorkspaceSaveSnapshot(); }catch(_){ } },
      onSaveAs: function(){},
      onLoad: function(){ try{ window.tdWorkspaceLoadSnapshot && window.tdWorkspaceLoadSnapshot(); }catch(_){ } },
      onPrint: function(){},
      onOpenTimeline: function(){ try{ const b=document.querySelector('#timelineBtn,[data-cp-action="timeline"]'); b && b.click(); }catch(_){} },
      onSetDay: function(idx){ try{ window.setScheduleDayIndex_ && window.setScheduleDayIndex_(idx); }catch(_){ } },
      onToggleCard: function(cardId, isOn){
        try{
          // UI-only toggles: checked = show, unchecked = hide. No persistence.
          const patch = {};
          if(cardId==="card2") patch.card2Visible = !!isOn;
          if(cardId==="card3") patch.card3Visible = !!isOn;
          if(cardId==="card4") patch.card4Visible = !!isOn;
          if(window.CPControlPanel && typeof window.CPControlPanel.setState==="function"){
            window.CPControlPanel.setState(patch);
          }
          const n = String(cardId||"").replace(/[^0-9]/g,"");
          if(n){
            const off = !isOn;
            document.body.classList.toggle("hide-sg-" + n, off);
            document.body.classList.toggle("hide-card-" + n, off);
          }
          try{ requestDockWidth(); }catch(_){ }
        }catch(_e){}
      }
    });
  }
  initTurnPrintToggle();

  // v5.68 — listen for Admin TD_RALLIES_CHANGED and refresh title/days/SG meta (no writes).
  (function(){
    if (window.__TD_SCHED_TDCHG_BOUND) return;
    window.__TD_SCHED_TDCHG_BOUND = true;

    function applyMeta(){
      try{
        const meta = (window.tdScheduleGetAdminMeta_ ? window.tdScheduleGetAdminMeta_() : { ok:false });
        if(!meta || !meta.ok) return false;

        // WorkspaceReady status (v5.88) — UI enable/disable only (Admin is truth)
        try{
          let td = null;
          try{ td = JSON.parse(localStorage.getItem('TD_RALLIES')||'null'); }catch(_e){ td = null; }
          const ready = !!(td && td.global && td.global.workspaceReady);
          const label = (td && td.global && typeof td.global.workspaceLabel === 'string') ? td.global.workspaceLabel : '';
          const sb = document.getElementById('saveBtn');
          const lb = document.getElementById('loadBtn');
          if (sb) { sb.disabled = !ready; sb.title = ready ? ('Workspace: ' + (label||'set')) : 'Workspace not set (open Admin → Set Workspace)'; }
          if (lb) { lb.disabled = !ready; lb.title = ready ? ('Workspace: ' + (label||'set')) : 'Workspace not set (open Admin → Set Workspace)'; }
        }catch(_e){}

        // Control panel title + days
        try{
          if(window.CPControlPanel && typeof window.CPControlPanel.setState==='function'){
            window.CPControlPanel.setState({ rallyTitle: meta.title, rallyIssue: meta.issue || 'r000', days: meta.days || [] });
          }
        }catch(_e){}

        // SG stack numbers + assignment
        try{ if(window.refreshCpSgMeta) window.refreshCpSgMeta(); }catch(_e){}
        try{ if(window.cpRefreshSgStackMeta) window.cpRefreshSgStackMeta(); }catch(_e){}
        return true;
      }catch(_e){ return false; }
    }

    function onChanged(payload){
      // Always re-read from localStorage (Admin is the writer).
      const ok = applyMeta();
      
      // v6.80 — SEED ONLY (not a general autosave):
      // If Admin writes a fresh TD_RALLIES (e.g., title/meta edit) and the schedule subtree is missing/empty,
      // publish the current Schedule model once so Controls can boot without requiring a manual edit in Schedule.
      try{
        const r = (payload && payload.reason) ? String(payload.reason) : '';
        if(r !== 'DAY_SELECT' && r !== 'DAY_MIRROR'){
          if(!window.__TD_SCHED_SEEDING && typeof window.syncScheduleToTdRallies==='function'){
            window.__TD_SCHED_SEEDING = true;
            try{ clearTimeout(window.__TD_SCHED_SEED_TMR); }catch(_){ }
            window.__TD_SCHED_SEED_TMR = setTimeout(function(){
              try{
                // Never seed while day-mirror/apply is in-flight (avoid code fighting / flicker loops)
                if(window.__TD_DAY_MIRROR_APPLYING) return;
                if(window.__TD_SCHED_DAY_SWITCHING) return;
            if(window.__TD_SCHED_DAY_SWITCHING) return;

                const raw = localStorage.getItem('TD_RALLIES');
                if(!raw) return; // do not create TD_RALLIES from Schedule

                let td=null; try{ td = JSON.parse(raw); }catch(_){ td=null; }
                if(!td || !td.rallies) return;

                const rid = (window.tdScheduleGetActiveRid_ ? window.tdScheduleGetActiveRid_() : null) ||
                            (td.global && td.global.activeRallyId ? String(td.global.activeRallyId) : null) ||
                            (Object.keys(td.rallies||{})[0]||null);
                if(!rid || !td.rallies[rid]) return;

                const dayKey = (window.getScheduleDayKey_ ? window.getScheduleDayKey_() : '1') || '1';
                const sched = td.rallies[rid].schedule || null;
                const rows = (sched && sched.days && sched.days[dayKey]) ? sched.days[dayKey].rows : null;

                const missing = (!sched) || (!sched.days) || (!rows);
                if(missing){
                  try{ window.syncScheduleToTdRallies('SEED_PUBLISH'); }catch(_e){}
                }
              }finally{
                window.__TD_SCHED_SEEDING = false;
              }
            }, 260);
          }
        }
      }catch(_e){}

      if(ok){
        try{
          const m = (window.tdScheduleGetAdminMeta_ ? window.tdScheduleGetAdminMeta_() : { ok:false });
          if(m && m.ok){
            const reason = (payload && payload.reason) ? String(payload.reason) : 'TD_RALLIES_CHANGED';
            if(false){ console.log('[EXT_HYDRATE]', { rid:m.rid, dayCount:m.dayCount, days:(m.days||[]).map(d=>d.label), sgCount:m.sgCount, reason }); }
          }
        }catch(_e){}
      }
    }

    // Same-tab
    try{
      window.addEventListener('TD_RALLIES_CHANGED', function(ev){
        try{ onChanged(ev && ev.detail ? ev.detail : null); }catch(_e){}
      });
    }catch(_e){}

    // Cross-tab
    try{
      if ('BroadcastChannel' in window){
        const bc = new BroadcastChannel('TD_RALLIES_CHANGED');
        bc.onmessage = function(e){ try{ onChanged(e && e.data ? e.data : null); }catch(_e){} };
        window.__TD_SCHED_TDCHG_BC = bc;
      }
    }catch(_e){}

    // Cross-tab fallback: storage event (Admin does not broadcast)
    try{
      window.addEventListener('storage', function(ev){
        try{
          if(!ev || ev.key !== 'TD_RALLIES') return;
          onChanged({ reason:'STORAGE_EVENT' });
        }catch(_e){}
      });
    }catch(_e){}


    // Initial apply (after CP init)
    setTimeout(applyMeta, 60);
    // Boot seed publish (v6.84): if TD_RALLIES exists and schedule subtree missing/empty, publish once.
    try{
      if(!window.__TD_SCHED_BOOT_SEEDED && typeof window.syncScheduleToTdRallies==='function'){
        window.__TD_SCHED_BOOT_SEEDED = true;
        setTimeout(function(){
          try{
            if(window.__TD_DAY_MIRROR_APPLYING) return;
            if(window.__TD_SCHED_DAY_SWITCHING) return;
            const raw = localStorage.getItem('TD_RALLIES');
            if(!raw) return; // do not create TD_RALLIES from Schedule
            let td=null; try{ td = JSON.parse(raw); }catch(_){ td=null; }
            if(!td || !td.rallies) return;
            const rid = (window.tdScheduleGetActiveRid_ ? window.tdScheduleGetActiveRid_() : null) ||
                        (td.global && td.global.activeRallyId ? String(td.global.activeRallyId) : null) ||
                        (Object.keys(td.rallies||{})[0]||null);
            if(!rid || !td.rallies[rid]) return;
            const dayKey = (window.getScheduleDayKey_ ? window.getScheduleDayKey_() : '1') || '1';
            const sched = td.rallies[rid].schedule || null;
            const rows = (sched && sched.days && sched.days[dayKey]) ? sched.days[dayKey].rows : null;
            const missing = (!sched) || (!sched.days) || (!rows);
            if(missing){
              try{ window.syncScheduleToTdRallies('BOOT_SEED'); }catch(_e){}
            }
          }catch(_e){}
        }, 420);
      }
    }catch(_e){}

  })();
});

  // v5.63: Print options → Admin-style print wrapper (capture phase)
  (function(){
    document.addEventListener('DOMContentLoaded', function(){
    const btn = document.getElementById('printBtn');
    if(!btn) return;

    const ov = document.getElementById('printOptionsOverlay');
    const selDay = document.getElementById('poDay');
    const selSg  = document.getElementById('poSg');
    // TURN print is controlled by the page toggle (body.turn-print-off)
    const bCancel= document.getElementById('poCancel');
    const bPrint = document.getElementById('poPrint');


    let lastFocusEl = null;

    function tdRead(){
      try{ const raw = localStorage.getItem('TD_RALLIES'); return raw ? JSON.parse(raw) : null; }catch(_){ return null; }
    }
    function getRid(){
      try{
        const rid = (window.tdScheduleGetActiveRid_?window.tdScheduleGetActiveRid_():null) || (typeof getRallyId==='function'?getRallyId():null);
        return rid ? String(rid).trim() : '';
      }catch(_){ return ''; }
    }
    function getRally(td, rid){
      try{ return td && td.rallies && td.rallies[rid] ? td.rallies[rid] : null; }catch(_){ return null; }
    }
    function getTitle(td, rid){
      try{
        const r = getRally(td, rid);
        const admin = r && r.admin ? r.admin : null;
        return String((admin && (admin.title || admin.rallyTitle)) || r.title || 'Rally').trim() || 'Rally';
      }catch(_){ return 'Rally'; }
    }
    function getDays(td, rid){
      try{
        // Prefer schedule days (set up by Admin), else fallback to CP state, else Day 1/2 defaults
        const r = getRally(td, rid);
        const schedDays = r && r.schedule && r.schedule.days ? Object.keys(r.schedule.days) : [];
        if(schedDays && schedDays.length){
          const keys = schedDays.map(k=>String(k)).sort((a,b)=>Number(a)-Number(b));
          return keys.map((k,i)=>({ key:k, label:'Day ' + (i+1) }));
        }
      }catch(_){ }
      // fallback: use the control panel day menu items if available
      try{
        const menu = document.getElementById('dayPillMenu');
        const items = menu ? Array.from(menu.querySelectorAll('[data-day-index]')) : [];
        if(items.length){
          return items.map(el=>({ key:String((Number(el.dataset.dayIndex)||0)+1), label: (el.textContent||'').trim() || ('Day ' + (Number(el.dataset.dayIndex||0)+1)) }));
        }
      }catch(_){ }
      return [{key:'1',label:'Day 1'},{key:'2',label:'Day 2'}];
    }
    function getSgCount(td, rid){
      try{ if(typeof getRallySgCount_==='function') return getRallySgCount_(td, rid); }catch(_){ }
      // fallback: infer from visible SG toggles
      try{
        const stack = document.getElementById('cpSgStack');
        const lids = stack ? Array.from(stack.querySelectorAll('[data-sg]')).map(x=>Number(x.dataset.sg||0)) : [];
        const max = Math.max(1, ...lids);
        return Math.max(1, Math.min(4, max));
      }catch(_){ return 1; }
    }

    function open(){
      lastFocusEl = document.activeElement || btn;
      const td = tdRead();
      const rid = getRid();

      const days = getDays(td, rid);
      selDay.innerHTML = '';
      days.forEach((d,i)=>{
        const opt = document.createElement('option');
        opt.value = d.key;
        opt.textContent = d.label;
        selDay.appendChild(opt);
      });

      function inferAssignedSgsFromCp(){
        try{
          const stack = document.getElementById('cpSgStack') || document.querySelector('.card-toggle-stack');
          if(!stack) return [];
          const labs = Array.from(stack.querySelectorAll('.card-toggle[data-sg]'));
          const set = new Set();
          for(const lab of labs){
            const sg = Number(lab.getAttribute('data-sg')||'0');
            if(!(sg>=1 && sg<=4)) continue;
            // Allocation source of truth: SG lines marked .sg-unassigned are not allocated.
            if(lab.classList.contains('sg-unassigned')) continue;
            set.add(sg);
          }
          return Array.from(set).sort((a,b)=>a-b);
        }catch(_){ return []; }
      }
      function buildSgOptions(dayKey){
        const td = tdRead();
        const rid = getRid();
        const prev = selSg.value;
        let list = inferAssignedSgsFromCp();
        if(!list.length){
          const sgCount = getSgCount(td, rid);
          list = [];
          for(let k=1;k<=sgCount;k++) list.push(k);
        }
        selSg.innerHTML = '';
        list.forEach(k=>{
          const opt = document.createElement('option');
          opt.value = String(k);
          opt.textContent = 'SG' + String(k);
          selSg.appendChild(opt);
        });
        if(prev && Array.from(selSg.options).some(o=>o.value===prev)) selSg.value = prev;
      }

// default: current day selection if present
      try{
        const curIdx = (window.CPControlPanel && window.CPControlPanel.state && Number.isFinite(Number(window.CPControlPanel.state.currentDayIndex))) ? Number(window.CPControlPanel.state.currentDayIndex) : 0;
        const curKey = String(curIdx + 1);
        if(Array.from(selDay.options).some(o=>o.value===curKey)) selDay.value = curKey;
      }catch(_){ }

      buildSgOptions(selDay.value || '1');
      selDay.onchange = ()=>{ try{ buildSgOptions(selDay.value || '1'); }catch(_){} };


      ov.classList.add('is-open');
      ov.setAttribute('aria-hidden','false');
      // v5.63 — move focus into the dialog (and avoid aria-hidden warnings on close)
      setTimeout(()=>{ try{ selDay && selDay.focus(); }catch(_){} }, 0);
    }

    function close(){
      // v5.63 — if focus is inside the overlay, return it to the launcher before hiding
      try{
        const ae = document.activeElement;
        if(ae && ov && ov.contains(ae)) {
          (lastFocusEl || btn).focus();
        }
      }catch(_){}
      ov.classList.remove('is-open');
      ov.setAttribute('aria-hidden','true');
    }

    function hmsToSec(hms){
      const m = String(hms||'').trim().match(/^(\d{1,2}):(\d{2}):(\d{2})$/);
      if(!m) return 0;
      return (parseInt(m[1],10)||0)*3600 + (parseInt(m[2],10)||0)*60 + (parseInt(m[3],10)||0);
    }
    function secToHms(sec){
      sec = Math.max(0, Math.round(Number(sec)||0));
      const h = Math.floor(sec/3600); sec -= h*3600;
      const mn= Math.floor(sec/60); sec -= mn*60;
      const s = sec;
      const z = (n)=>String(n).padStart(2,'0');
      return z(h)+':'+z(mn)+':'+z(s);
    }

    function getStartTime(td, rid, dayKey){
      try{
        const r = getRally(td, rid);
        const shared = r && r.shared ? r.shared : null;
        const days = shared && shared.days ? shared.days : null;
        const d = days && (days[String(dayKey)] || days[Number(dayKey)]) ? (days[String(dayKey)] || days[Number(dayKey)]) : null;
        if(d && d.startTime) return String(d.startTime);
        const d1 = days && (days['1']||days[1]) ? (days['1']||days[1]) : null;
        if(d1 && d1.startTime) return String(d1.startTime);
      }catch(_){ }
      return '00:00:00';
    }

    function buildPrint(td, rid, dayKey, sgId, printTurn){
      const r = getRally(td, rid);
      const title = getTitle(td, rid);
      const dayLabel = 'Day ' + String(Number(dayKey)||1);
      const sgLabel = 'SG' + String(sgId);

      const head = document.getElementById('schedulePrintHead');
      if(head) head.textContent = `${title} — ${dayLabel} — ${sgLabel}`;

      const table = document.getElementById('schedulePrintTable');
      if(!table) return;
      table.innerHTML = '';

      // column plan
      const cols = [
        { key:'dist', w:'22mm', label:'DIST' },
        { key:'time', w:'28mm', label:'TIME' },
        { key:'speed', w:'18mm', label:'SPEED' },
        { key:'instr', w:null, label:'INSTRUCTION' },
      ];
      if(printTurn) cols.push({ key:'turn', w:'18mm', label:'TURN' });

      // colgroup
      const cg = document.createElement('colgroup');
      cols.forEach(c=>{
        const col = document.createElement('col');
        if(c.w) col.style.width = c.w;
        cg.appendChild(col);
      });
      table.appendChild(cg);

      const thead = document.createElement('thead');
      const trh = document.createElement('tr');
      cols.forEach(c=>{ const th=document.createElement('th'); th.textContent=c.label; trh.appendChild(th); });
      thead.appendChild(trh);
      table.appendChild(thead);

      const tbody = document.createElement('tbody');

      const rows = (r && r.schedule && r.schedule.days && r.schedule.days[String(dayKey)] && Array.isArray(r.schedule.days[String(dayKey)].rows)) ? r.schedule.days[String(dayKey)].rows : [];

      // compute running times (same conceptual model as lane recompute)
      let curSec = hmsToSec(getStartTime(td, rid, dayKey));
      let pendingAdd = 0;

      function rowSpeed(row){
        try{
          const m = row && row.sgSpeeds ? row.sgSpeeds : null;
          const v = m && m[String(sgId)]!=null ? Number(m[String(sgId)]) : null;
          return (Number.isFinite(v) && v>0) ? v : 0;
        }catch(_){ return 0; }
      }
      function rowAtSec(row){
        try{
          if(row && row.type==='ADDED_TIME'){
            if(row.atSecBySg && row.atSecBySg[String(sgId)]!=null) return Number(row.atSecBySg[String(sgId)])||0;
            if(row.atTimeBySg && row.atTimeBySg[String(sgId)]) return hmsToSec(row.atTimeBySg[String(sgId)]);
            if(row.atTime) return hmsToSec(row.atTime);
          }
        }catch(_){ }
        return 0;
      }

      // second pass to advance time values correctly (needs lookahead); rebuild using a running loop
      // Rebuild with proper time advance
      tbody.innerHTML = '';
      curSec = hmsToSec(getStartTime(td, rid, dayKey));
      pendingAdd = 0;
      let stcN=0, openN=0, startStcN=0;
      let _prevPrintedSpeed = null; // v7.03 print suppression: blank repeated speeds
      for(let i=0;i<rows.length;i++){
        const row = rows[i] || {};
        if(i>0 && pendingAdd){ curSec += pendingAdd; pendingAdd = 0; }

        const dist = Number(row.dist||0);
        const timeStr = secToHms(curSec);
        const sp = rowSpeed(row);

        // Print semantics (row/cell rules)
        const _type = String(row.type||'').toUpperCase();
        const _isMarshal = (_type === 'MARSHAL');
        const _distPrintable = (row.distEnabled !== false);
        const _timePrintable = (row.timeEnabled !== false);

        let _instrText = String(row.instr||'');
        if(_type === 'STC'){
          stcN += 1;
          _instrText = `STC ${stcN}` + (_instrText ? `  ${_instrText}` : '');
        } else if(_type === 'OPEN' || _type === 'OPEN_CONTROL'){
          openN += 1;
          _instrText = `OPEN CONTROL ${openN}` + (_instrText ? `  ${_instrText}` : '');
        } else if(_type === 'START_STC'){
          startStcN += 1;
          _instrText = `START STC ${startStcN}` + (_instrText ? `  ${_instrText}` : '');
        } else if(_type === 'ADDED_TIME'){
          const atStr = secToHms(rowAtSec(row));
          const label = (row && row.atLabel!=null) ? String(row.atLabel) : 'Added Time';
          // Print: include menu label + SG-specific added time, then any free-text suffix
          _instrText = label + '  ' + atStr + (_instrText ? `  ${_instrText}` : '');
        }


        if(!_isMarshal){
          // NO PRINT: omit Added Time row from print output only
          if(_type==='ADDED_TIME' && row && row.noPrint){
            // skip building a printed row
          } else {
          const tr = document.createElement('tr');

          const tdDist = document.createElement('td');
          tdDist.className='c-dist';
          tdDist.textContent = _distPrintable ? (Number.isFinite(dist)?dist:0).toFixed(2) : '';

          const tdTime = document.createElement('td');
          tdTime.className='c-time';
          tdTime.textContent = _timePrintable ? timeStr : '';

          const tdSp   = document.createElement('td');
          tdSp.className='c-speed';
          {
            const _spStr = sp ? String(Math.round(sp)) : '';
            // v7.03: if speed repeats the row above, do not print it
            if(_spStr && _prevPrintedSpeed === _spStr){
              tdSp.textContent = '';
            }else{
              tdSp.textContent = _spStr;
              if(_spStr) _prevPrintedSpeed = _spStr;
            }
          }

          const tdIn   = document.createElement('td');
          tdIn.className='c-instr';
          tdIn.textContent = _instrText;

          tr.appendChild(tdDist); tr.appendChild(tdTime); tr.appendChild(tdSp); tr.appendChild(tdIn);

          if(printTurn){
            const tdT=document.createElement('td');
            tdT.className='c-turn';
            tdT.textContent=String(row.turn||'');
            tr.appendChild(tdT);
          }

          tbody.appendChild(tr);
          }
        }

        if(String(row.type)==='ADDED_TIME') pendingAdd = rowAtSec(row);

        if(i < rows.length-1){
          const next = rows[i+1] || {};
          let dKm = Number(next.dist||0) - Number(dist||0);
          if(!Number.isFinite(dKm) || dKm < 0) dKm = 0;
          if(sp > 0 && dKm > 0){
            curSec += (dKm / sp) * 3600;
          }
        }
      }

      table.appendChild(tbody);

      // print mode flags
      document.body.dataset.printMode = 'schedule';
    }

    function doPrint(){
      const td = tdRead() || { rallies: {} };
      const rid = getRid();

      const dayKey = String(selDay.value || '1');
      const sgId = String(selSg.value || '1');
      const printTurn = !document.body.classList.contains('turn-print-off');

      close();
      buildPrint(td, rid, dayKey, sgId, printTurn);

      // run print on next tick so DOM is ready
      setTimeout(()=>{ try{ window.print(); }catch(_){ } }, 0);
    }

    function cleanupAfterPrint(){
      try{ delete document.body.dataset.printMode; }catch(_){ }
    }

    btn.addEventListener('click', function(e){
      e.preventDefault();
      e.stopPropagation();
      open();
    }, true);

    bCancel && bCancel.addEventListener('click', function(e){ e.preventDefault(); close(); });
    ov && ov.addEventListener('click', function(e){ if(e.target===ov) close(); });
    bPrint && bPrint.addEventListener('click', function(e){ e.preventDefault(); doPrint(); });

    window.addEventListener('afterprint', cleanupAfterPrint);
      });
})();;
</script><script>
  // SG refresh scheduler: coalesce multiple triggers into one refresh per animation frame.
  let _sgRefreshQueued = false;
  function scheduleSgRefresh(){
    if (_sgRefreshQueued) return;
    _sgRefreshQueued = true;
    requestAnimationFrame(() => {
      _sgRefreshQueued = false;
      if (typeof window.sgAdapterRefresh === 'function') window.sgAdapterRefresh();
    });
  }

  (function(){
    const LAB_DEBUG = false; // guard: keep console clean by default
    function getRowType(tr) {
      if (tr.classList.contains('added-time')) return 'addedTime';
      if (tr.classList.contains('stc-row')) return 'stc';
      if (tr.classList.contains('start-stc')) return 'startStc';
      if (tr.classList.contains('marshal-row')) return 'marshal';
      if (tr.classList.contains('open-control-row')) return 'openControl';
      return 'instruction';
    }


    function rowTypeCamelToKebab(t){
      switch(t){
        case 'addedTime': return 'added-time';
        case 'startStc': return 'start-stc';
        case 'openControl': return 'open-control';
        default: return t; // instruction, stc, marshal
      }
    }
    function normalizeRowTypeMarkers(){
      const tbody = document.getElementById('schedule-body');
      if(!tbody) return;
      const trs = Array.from(tbody.querySelectorAll('tr'));
      trs.forEach(tr=>{
        const camel = getRowType(tr);
        tr.setAttribute('data-row-type', rowTypeCamelToKebab(camel));
      });
    }
function snapshotScheduleTable() {
      const rows = [];
      const tbody = document.getElementById('schedule-body');
      if (!tbody) return rows;
      const trs = Array.from(tbody.querySelectorAll('tr:not(.row-template)'));
      trs.forEach((tr, idx) => {
        const distInput = tr.querySelector('td.col-dist input[type="text"]');
        const distTick = tr.querySelector('td.col-dist .with-checkbox input[type="checkbox"]');
        const timeInput = tr.querySelector('td.col-time .with-checkbox input[type="text"]');
        const timeTick = tr.querySelector('td.col-time .with-checkbox input[type="checkbox"]');
        const speedInput = tr.querySelector('td.col-speed input[type="text"]');
        const noteTextarea = tr.querySelector('.instruction-input-sl');
        const atSelect = tr.querySelector('.added-select');
        const atTime = tr.querySelector('.time-to-add');
        const turnSelect = tr.querySelector('td.col-turn .turn-select');

        rows.push({
          index: idx + 1,
          type: getRowType(tr),
          dist: distInput ? distInput.value : '',
          distEnabled: distTick ? !distTick.checked : true,
          time: timeInput ? timeInput.value : '',
          timeEnabled: timeTick ? !timeTick.checked : true,
          speed: speedInput ? speedInput.value : '',
          addedReason: atSelect ? atSelect.value : '',
          addedTime: atTime ? atTime.value : '',
          note: noteTextarea ? noteTextarea.value : '',
          turn: turnSelect ? turnSelect.value : ''
        });
      });
      return rows;
    }

    const tbody = document.getElementById('schedule-body') || null;

    // Capture template rows for each type
    const rowTemplates = tbody ? {
      instruction: tbody.querySelector('tr.instruction-row'),
      addedTime: tbody.querySelector('tr.added-time'),
      stc: tbody.querySelector('tr.stc-row'),
      startStc: tbody.querySelector('tr.start-stc'),
      marshal: tbody.querySelector('tr.marshal-row'),
      openControl: tbody.querySelector('tr.open-control-row')
    } : {};

    // v5.22 — remove hidden row-template DOM nodes (templates are kept via rowTemplates refs)
    try{
      Object.values(rowTemplates).forEach((tr)=>{
        if(tr && tr.classList && tr.classList.contains("row-template") && tr.parentElement === tbody){
          tr.parentElement.removeChild(tr);
        }
      });
    }catch(e){}


    function makeRowObject(menuType) {
      const logicalMap = {
        'instruction': 'instruction',
        'instruction-5': 'instruction',
        'added-time': 'addedTime',
        'stc': 'stc',
        'start-stc': 'startStc',
        'marshal': 'marshal',
        'open-control': 'openControl'
      };
      const logicalType = logicalMap[menuType] || 'instruction';
      const rows = window.scheduleRows || [];
      const last = rows[rows.length - 1] || null;

      const baseDist = last ? last.dist : '0.00';
      const baseSpeed = '80'; // v6.03 default-only: fixed SG1 speed (no copy-from-row-above)
      const baseTime = last ? last.time : '00:00:00';

      const isStartStc = (logicalType === 'startStc');

      return {
        index: (last ? last.index + 1 : 1),
        type: logicalType,
        dist: isStartStc ? '0.00' : (last? ( (parseFloat(baseDist)||0)+1 ).toFixed(2) : '0.00'),
        distEnabled: (!isStartStc && logicalType !== 'stc'),
        time: baseTime,
        timeEnabled: true,
        speed: baseSpeed,
        addedReason: '',
        addedTime: (logicalType === 'addedTime') ? '00:00:00' : '',
        note: '',
        turn: ''
      };
    }

    function enhanceTurnCell(tr) {
      const td = tr.querySelector('td.col-turn');
      if (!td) return;
      const select = td.querySelector('.turn-select');
      if (!select) return;

      let pill = td.querySelector('.turn-pill');
      if (!pill) {
        pill = document.createElement('button');
        pill.type = 'button';
        pill.className = 'turn-pill';
        td.appendChild(pill);
      }

      // Sync pill label from the *current* select selection.
      // IMPORTANT: do not close over a stale pill reference; always re-query.
      const sync = () => {
        const tdNow = select.closest('td');
        if (!tdNow) return;
        const pillNow = tdNow.querySelector('.turn-pill');
        if (!pillNow) return;
        const opt = (select.selectedIndex >= 0 && select.options) ? select.options[select.selectedIndex] : null;
        const label = opt ? String(opt.textContent || '').trim() : '';
        pillNow.textContent = label || String(select.value || '').trim() || '';
      };

      // Initial sync (covers hydrate paths that set select.value before/after pill creation)
      sync();

      // Bind per-select change only once, but keep sync robust.
      if (!select.dataset.turnPillSyncBound) {
        select.addEventListener('change', sync);
        select.dataset.turnPillSyncBound = '1';
      }

      // Click is handled via delegated listener (supports all rows)
}


    // v5.47 — TURN pill sync helpers (single source: select -> button.turn-pill)
    function _syncTurnPillForSelect_(select){
      try{
        if(!select) return;
        const td = select.closest('td');
        if(!td) return;
        const pill = td.querySelector('button.turn-pill, .turn-pill');
        if(!pill) return;
        const opt = (select.selectedIndex >= 0 && select.options) ? select.options[select.selectedIndex] : null;
        const label = opt ? String(opt.textContent || '').trim() : '';
        pill.textContent = label || String(select.value || '').trim() || '';
      }catch(_){ }
    }
    function _syncAllTurnPills_(){
      try{
        const tbody = document.getElementById('schedule-body');
        const scope = tbody || document;
        scope.querySelectorAll('select.turn-select').forEach(_syncTurnPillForSelect_);
      }catch(_){ }
    }
// TURN floating menu wiring (no visible <select> in-cell)
    const __turnMenuState = { open:false, pill:null, select:null };

    function getTurnMenuEl(){
      return document.getElementById('labTurnMenu');
    }

    function closeTurnMenu(){
      const menu = getTurnMenuEl();
      if (!menu) return;
      menu.classList.add('hidden');
      __turnMenuState.open = false;
      __turnMenuState.pill = null;
      __turnMenuState.select = null;
    }

    function positionTurnMenu(menu, anchorTd){
      const r = anchorTd.getBoundingClientRect();
      menu.style.position = 'fixed';
      menu.style.left = Math.round(r.left) + 'px';
      menu.style.width = Math.round(r.width) + 'px';
      // default below
      let top = Math.round(r.bottom + 6);
      menu.style.top = top + 'px';

      // after paint, ensure it stays in viewport
      requestAnimationFrame(() => {
        const mr = menu.getBoundingClientRect();
        let t = top;
        if (mr.bottom > window.innerHeight - 8) {
          t = Math.round(r.top - mr.height - 6);
        }
        if (t < 8) t = 8;
        menu.style.top = t + 'px';
      });
    }

    function openTurnMenuForPill(pill){
      const menu = getTurnMenuEl();
      if (!menu) return;

      const td = pill.closest('td');
      const select = td ? td.querySelector('.turn-select') : null;
      if (!td || !select) return;

      __turnMenuState.open = true;
      __turnMenuState.pill = pill;
      __turnMenuState.select = select;

      // Highlight current selection
      const current = select.value || '';
      menu.querySelectorAll('button[data-turn]').forEach(btn => {
        const v = btn.getAttribute('data-turn') || '';
        btn.style.background = (v === current) ? '#eef2ff' : '';
      });

      menu.classList.remove('hidden');
      positionTurnMenu(menu, td);
    }

    function initTurnMenu(){
      const menu = getTurnMenuEl();
      if (!menu) return;

      // Click a choice
      menu.querySelectorAll('button[data-turn]').forEach(btn => {
        if (btn.dataset.turnChoiceWired) return;
        btn.dataset.turnChoiceWired = '1';
        btn.addEventListener('click', (ev) => {
          ev.preventDefault();
          ev.stopPropagation();
          if (!__turnMenuState.open || !__turnMenuState.select || !__turnMenuState.pill) return;

          const v = btn.getAttribute('data-turn') || '';
          __turnMenuState.select.value = v;

          // Sync pill label
          __turnMenuState.pill.textContent = v;

          // Fire change for any downstream logic
          __turnMenuState.select.dispatchEvent(new Event('change', { bubbles:true }));

          closeTurnMenu();
        });
      });


      // Delegated TURN pill click (works for all rows, including dynamically added)
      document.addEventListener('click', (ev) => {
        const pill = ev.target && ev.target.closest ? ev.target.closest('.turn-pill') : null;
        if (!pill) return;
        ev.preventDefault();
        ev.stopPropagation();
        openTurnMenuForPill(pill);
      });
// Global close behaviours
      document.addEventListener('click', (ev) => {
        if (!__turnMenuState.open) return;
        if (ev.target && (ev.target.closest('#labTurnMenu') || ev.target.closest('.turn-pill'))) return;
        closeTurnMenu();
      }, true);
      document.addEventListener('keydown', (ev) => {
        if (ev.key === 'Escape' && __turnMenuState.open) closeTurnMenu();
      }, true);
      window.addEventListener('resize', () => { if (__turnMenuState.open) closeTurnMenu(); }, true);
      window.addEventListener('scroll', () => { if (__turnMenuState.open) closeTurnMenu(); }, true);
    }

    document.addEventListener('DOMContentLoaded', initTurnMenu);


    function createRowDom(row) {
      if (!tbody) return null;
      const tpl = rowTemplates[row.type] || rowTemplates.instruction;
      if (!tpl) return null;
      const tr = tpl.cloneNode(true);

      // make sure clones are visible (templates carry .row-template which is display:none)
      tr.classList.remove('row-template');
      tr.style.display = '';


      // SG prep: stable row-type marker + per-row home frame
      tr.setAttribute('data-row-type', rowTypeCamelToKebab(row.type || getRowType(tr)));
      const instrTd = tr.querySelector('td.col-instr');
      if (instrTd && !instrTd.querySelector('.sg-home-frame')) {
        const home = document.createElement('div');
        home.className = 'sg-home-frame';
        home.setAttribute('data-sg-home','');
        instrTd.appendChild(home);
      }
// clear / set row number placeholder (renumbered globally later)
      const numSpan = tr.querySelector('.row-num');
      if (numSpan) numSpan.textContent = '';

      const distInput = tr.querySelector('td.col-dist input[type="text"]');
      const distTick = tr.querySelector('td.col-dist .with-checkbox input[type="checkbox"]');
      const timeInput = tr.querySelector('td.col-time .with-checkbox input[type="text"]');
      const timeTick = tr.querySelector('td.col-time .with-checkbox input[type="checkbox"]');
      const speedInput = tr.querySelector('td.col-speed input[type="text"]');
      const noteTextarea = tr.querySelector('.instruction-input-sl');
      const atSelect = tr.querySelector('.added-select');
      const atTime = tr.querySelector('.time-to-add');
      const turnSelect = tr.querySelector('td.col-turn .turn-select');

      if (distInput) { distInput.value = row.dist; window._pSetForEl(distInput, true);
        // v3.39 — clones must never inherit START-only dist lock
        distInput.readOnly = false;
        distInput.removeAttribute('readonly');
        distInput.removeAttribute('tabindex');
        distInput.classList.remove('start-dist-locked');
      }
      if (distTick) {
        if (row && typeof row.distEnabled === 'boolean') {
          distTick.checked = (row.distEnabled === false);
        } else {
          distTick.checked = false;
        }
      }
      if (timeInput) timeInput.value = row.time;
      if (timeTick) {
        if (row && typeof row.timeEnabled === 'boolean') {
          timeTick.checked = (row.timeEnabled === false);
        } else {
          timeTick.checked = false;
        }
      }
      if (speedInput) { speedInput.value = row.speed; window._pSetForEl(speedInput, true); }
      if (noteTextarea) noteTextarea.value = row.note || '';
      if (atSelect) atSelect.value = row.addedReason || '';
      if (atTime) atTime.value = row.addedTime || '00:00:00';
      // Added Time: NO PRINT flag (print exclusion only)
      try{ const np=tr.querySelector('.at-print-flag'); if(np) np.checked = !!row.noPrint; }catch(_){ }
      if (turnSelect) turnSelect.value = row.turn || '';

      enhanceTurnCell(tr);
      return tr;
    }


    function applyPrintStylesForTr(tr) {
      if (!tr) return;
      const distInput = tr.querySelector('td.col-dist input[type="text"]');
      const distTick = tr.querySelector('td.col-dist .with-checkbox input[type="checkbox"]');
      if (distInput && distTick) {
        if (distTick.checked) {
          distInput.classList.add('unprinted');
        } else {
          distInput.classList.remove('unprinted');
        }
      }
      const timeInput = tr.querySelector('td.col-time .with-checkbox input[type="text"]');
      const timeTick = tr.querySelector('td.col-time .with-checkbox input[type="checkbox"]');
      if (timeInput && timeTick) {
        if (timeTick.checked) {
          timeInput.classList.add('unprinted');
        } else {
          timeInput.classList.remove('unprinted');
        }
      }

	      // v5.41 — mirror TIME print tick to SG lane time paint (lanes have no independent tick state)
	      if (timeTick) {
	        const laneTimes = tr.querySelectorAll('.sg-time-text');
	        laneTimes.forEach(tt => {
	          if (!tt) return;
	          if (timeTick.checked) tt.classList.add('unprinted');
	          else tt.classList.remove('unprinted');
	        });
	      }

      // Marshal rows: lane values are never printed (checkbox hidden via CSS)
      if (tr.classList.contains('marshal-row')){
        tr.querySelectorAll('.sg-time-text').forEach(tt=>tt.classList.add('is-red'));
      }

    }

    function refreshAllPrintStyles() {
      if (!tbody) return;
      const trs = Array.from(tbody.querySelectorAll('tr:not(.row-template)'));
      trs.forEach(applyPrintStylesForTr);
    }


    // v3.39 — START row DIST lock: apply to row 1 only, and ensure clones are cleared
    function setStartDistLockState_(tr, isStart){
      const inp = tr ? tr.querySelector('td.col-dist input[type="text"]') : null;
      if (!inp) return;
      if (isStart){
        inp.readOnly = true;
        inp.setAttribute('readonly','');
        inp.setAttribute('tabindex','-1');
        inp.classList.add('start-dist-locked');
      } else {
        inp.readOnly = false;
        inp.removeAttribute('readonly');
        inp.removeAttribute('tabindex');
        inp.classList.remove('start-dist-locked');
      }
    }


    function renumberControlPrefixes() {
      const tbody = (typeof _getTbody === 'function') ? _getTbody() : document.querySelector('tbody');
      if (!tbody) return;
      let stcN = 0, startStcN = 0, marshalN = 0, openN = 0;
      const trs = Array.from(tbody.querySelectorAll('tr:not(.row-template)'));
      trs.forEach(tr => {
        const prefix = tr.querySelector('.instruction-prefix');
        if (!prefix) return;

        if (tr.classList.contains('stc-row')) {
          stcN += 1;
          prefix.textContent = `STC ${stcN}`;
        } else if (tr.classList.contains('start-stc')) {
          startStcN += 1;
          prefix.textContent = `START STC ${startStcN}`;
        } else if (tr.classList.contains('marshal-row')) {
          marshalN += 1;
          prefix.textContent = `MARSHAL ${marshalN}`;
        } else if (tr.classList.contains('open-control-row')) {
          openN += 1;
          prefix.textContent = `OPEN CONTROL ${openN}`;
        }
      });
    }

function renumberRows() {
      if (!tbody) return;
      const trs = Array.from(tbody.querySelectorAll('tr:not(.row-template)'));
      trs.forEach((tr, idx) => {
        const numSpan = tr.querySelector('.row-num');
        if (numSpan) numSpan.textContent = String(idx + 1);

        // v3.09 — tag the Rally Start row (row 1) for special-case styling
        if (idx === 0) tr.classList.add('start-row');
        else tr.classList.remove('start-row');

        setStartDistLockState_(tr, idx === 0);
});
      // keep JSON indices in sync too
      const rows = window.scheduleRows || [];
      rows.forEach((row, idx) => {
        row.index = idx + 1;
      });      renumberControlPrefixes();

      window.validateAllMonotonicDists_ && window.validateAllMonotonicDists_();
      recalcTimes();
    }

    function addRowFromMenuType(menuType) {
      try{ window.tdTrace && window.tdTrace('[ROW add] ' + String(menuType||'')); }catch(_){ }
      if (!tbody) return;
      // v5.16: structural change - mute commit triggers during build, commit once at end
      window.__TD_SCHEDULE_MUTE = true;
      // v4.18: always resnapshot so manual DIST edits are respected
      window.scheduleRows = snapshotScheduleTable();
    // SG adapter hook (prep): later replaced by real SG module refresh.
    window.sgAdapterRefresh = window.sgAdapterRefresh || function(){};
      const isMulti = (menuType === 'instruction-5');
      const count = isMulti ? 5 : 1;
      const isStartStc = (menuType === 'start-stc');

      // v4.18: Single rule — new DIST = (row above + 1.00)
      // For ADD (append), "row above" is the current last real row.
      let baseDist = NaN;
      try{
        const trs = Array.from(tbody.querySelectorAll('tr:not(.row-template)'));
        const lastTr = trs.length ? trs[trs.length - 1] : null;
        const lastDistInput = lastTr ? lastTr.querySelector('td.col-dist input[type="text"]') : null;
        const lastVal = lastDistInput ? String(lastDistInput.value).trim().replace(',','.') : '';
        const lastNum = parseFloat(lastVal);
        if (Number.isFinite(lastNum)) baseDist = lastNum;
      }catch(_){}
      if(!Number.isFinite(baseDist)) baseDist = 0;

      for (let i = 0; i < count; i++) {
        const rowObj = makeRowObject(menuType);

        if(isStartStc){
          // v5.86 — Start STC DIST is fixed at 0.00 (never auto-increment from prior row)
          rowObj.dist = '0.00';
        }else if(Number.isFinite(baseDist)){
          baseDist = baseDist + 1;
          rowObj.dist = baseDist.toFixed(2);
        }

        window.scheduleRows.push(rowObj);
        const tr = createRowDom(rowObj);
        if (tr) {
          tbody.appendChild(tr);
          if(isStartStc){
            // v5.91 — START STC DIST: hard 0.00, no pristine ring, no red alert
            try{
              const _d = tr.querySelector('td.col-dist input[type="text"]');
              if(_d){ _d.value='0.00'; _d.classList.remove('is-pristine','dist-error'); }
              const _tick = tr.querySelector('td.col-dist .with-checkbox input[type="checkbox"]');
              if(_tick){ _tick.checked = true; }
            }catch(_){ }
          }
          try{ applyPrintStylesForTr(tr); }catch(_){ }
        }
      }

      renumberRows();
      markDuplicateSpeeds();
      scheduleSgRefresh();
      // v5.19: end-of-structural change - unmute and commit once (explicit settle-sync; batch-safe)
      setTimeout(()=>{
        window.__TD_SCHEDULE_MUTE = false;
        const __supp = (window.__TD_SCHEDULE_SUPPRESS_PERSIST||0) > 0;
      const __hydr = (window.__TD_SCHEDULE_HYDRATING||0) > 0;
      if(__supp || __hydr){
        try{ window.tdTrace && window.tdTrace(__supp ? '[SUPPRESS suppress] row-add' : '[HYDRATE suppress] row-add'); }catch(_){ }
      }else{
        try{ if (typeof window._markScheduleDirty_ === 'function') window._markScheduleDirty_('row-add'); else window.__TD_SCHEDULE_DIRTY = true; }catch(_){ }
        try{ if (typeof window.syncScheduleToTdRallies === 'function') window.syncScheduleToTdRallies('ROW_ADD'); }catch(_){ }
      }
      }, 0);
try{ refreshCpSgStackMeta_(); }catch(_){}
    try{ if(window.refreshCpSgMeta) window.refreshCpSgMeta(); }catch(_){}
      if (LAB_DEBUG) console.log('Schedule Table Lab v0.18 – after addRow', menuType, window.scheduleRows);
    }

    function deleteRowByTr(tr) {
      try{ window.tdTrace && window.tdTrace('[ROW delete]'); }catch(_){ }
      if (!tbody || !tr) return;
      // v5.16: structural change - mute commit triggers during build, commit once at end
      window.__TD_SCHEDULE_MUTE = true;
      // Store single-step undo snapshot for Ctrl+Z
      try {
        const all = Array.from(tbody.querySelectorAll('tr:not(.row-template)'));
        const idx = all.indexOf(tr);
        if (idx === -1) return;

        const trClone = tr.cloneNode(true);
        let rowObj = null;
        if (window.scheduleRows && Array.isArray(window.scheduleRows) && window.scheduleRows[idx] != null) {
          // best-effort deep clone
          const src = window.scheduleRows[idx];
          if (typeof structuredClone === 'function') rowObj = structuredClone(src);
          else rowObj = JSON.parse(JSON.stringify(src));
        }
        window.__lastRowDelete = { idx, trClone, rowObj, ts: Date.now() };
      } catch(e) {
                  lastRowTr = snap.trClone;
          window.__lastRowDelete = null;
      }

      const all = Array.from(tbody.querySelectorAll('tr:not(.row-template)'));
      const idx = all.indexOf(tr);
      if (idx === -1) return;

      // v5.82: structural change - mute commit triggers during build, commit once at end
      window.__TD_SCHEDULE_MUTE = true;
      tr.remove();
      if (window.scheduleRows && Array.isArray(window.scheduleRows)) {
        window.scheduleRows.splice(idx, 1);
      }
      // Update canonical active row after delete
      try {
        const now = Array.from(tbody.querySelectorAll('tr:not(.row-template)'));
        lastRowTr = now[idx] || now[idx-1] || null;
      } catch(e) {}
      renumberRows();
      markDuplicateSpeeds();
      scheduleSgRefresh();
      // v5.19: end-of-structural change - unmute and commit once (explicit settle-sync; batch-safe)
      setTimeout(()=>{
        window.__TD_SCHEDULE_MUTE = false;
        if(!window.__TD_SCHEDULE_BOOTSTRAP_DONE){
        try{ window.tdTrace && window.tdTrace('[BOOT suppress] row-delete'); }catch(_){}
      }else{
        try{ _markScheduleDirty_('row-delete'); }catch(_){}
        try{
          // v7.09: persist only for real user row actions (bootstrap suppressed) — exactly one write
          _syncScheduleNow_('row-delete');
        }catch(_){
          try{ if (typeof window.syncScheduleToTdRallies === 'function') window.syncScheduleToTdRallies('ROW_DELETE'); }catch(__){}
        }
      }
      }, 0);
    try{ refreshCpSgStackMeta_(); }catch(_){}
    try{ if(window.refreshCpSgMeta) window.refreshCpSgMeta(); }catch(_){}
      if (typeof recalcTimes === 'function') recalcTimes();
      if (LAB_DEBUG) console.log('Schedule Table Lab v0.18 – after deleteRow index', idx, window.scheduleRows);
    }

    function insertRowBelow(tr, menuType) {
      try{ window.tdTrace && window.tdTrace('[ROW insertBelow] ' + String(menuType||'')); }catch(_){ }
      if (!tbody || !tr) return;
      // v4.18: always resnapshot so manual edits are respected
      window.scheduleRows = snapshotScheduleTable();
      const all = Array.from(tbody.querySelectorAll('tr:not(.row-template)'));
      const idx = all.indexOf(tr);
      if (idx === -1) return;

      // v5.82: structural change - mute commit triggers during build, commit once at end
      window.__TD_SCHEDULE_MUTE = true;

      // v4.18 single rule: new DIST = (row above + 1.00)
      let baseDist = 0;
      try{
        const distInput = tr.querySelector('td.col-dist input[type="text"]');
        const val = distInput ? String(distInput.value).trim().replace(',','.') : '';
        const num = parseFloat(val);
        if (Number.isFinite(num)) baseDist = num;
      }catch(_){}

      const rowObj = makeRowObject(menuType);
      rowObj.dist = (baseDist + 1).toFixed(2);
      // insert into JSON array after current index
      window.scheduleRows.splice(idx + 1, 0, rowObj);

      // create DOM row and insert after current tr
      const newTr = createRowDom(rowObj);
      if (newTr) {
        const next = tr.nextSibling;
        if (next) {
          tbody.insertBefore(newTr, next);
        } else {
          tbody.appendChild(newTr);
        }
        try{ applyPrintStylesForTr(newTr); }catch(_){ }
      }
      renumberRows();
      markDuplicateSpeeds();
      scheduleSgRefresh();
    try{ refreshCpSgStackMeta_(); }catch(_){}
    try{ if(window.refreshCpSgMeta) window.refreshCpSgMeta(); }catch(_){}
      if (LAB_DEBUG) console.log('Schedule Table Lab v0.18 – after insertRowBelow', menuType, window.scheduleRows);
      // v5.82: end-of-structural change - unmute and commit once (explicit settle-sync; batch-safe)
      setTimeout(()=>{
        window.__TD_SCHEDULE_MUTE = false;
        if(!window.__TD_SCHEDULE_BOOTSTRAP_DONE){
        try{ window.tdTrace && window.tdTrace('[BOOT suppress] row-insert'); }catch(_){}
      }else{
        try{ _markScheduleDirty_('row-insert'); }catch(_){}
        try{
          // v7.09: persist only for real user row actions (bootstrap suppressed) — exactly one write
          _syncScheduleNow_('row-insert');
        }catch(_){
          try{ if (typeof window.syncScheduleToTdRallies === 'function') window.syncScheduleToTdRallies('ROW_INSERT'); }catch(__){}
        }
      }
      }, 0);
    }

function parseTimeToSeconds(str){
      if (!str) return 0;
      const m = String(str).trim().match(/^(-?)(\d{1,2}):(\d{2}):(\d{2})$/);
      if (!m) return 0;
      const sign = m[1] === '-' ? -1 : 1;
      const h = parseInt(m[2], 10) || 0;
      const mnt = parseInt(m[3], 10) || 0;
      const s = parseInt(m[4], 10) || 0;
      return sign * (h * 3600 + mnt * 60 + s);
    }

    // Added Time (AT) shorthand parser (page AT only; SG AT stays independent)
    // Accepts:
    //   - HH:MM:SS (optionally with leading -)
    //   - MM.SS or MM:SS
    //   - Digits-only: 1–2 digits => seconds (default NEGATIVE if <60), 3–4 digits => MMSS, otherwise => seconds
    // Examples:
    //   30  -> -00:00:30
    //   60  -> 00:01:00
    //   12.30 / 1230 -> 00:12:30
    function parseAddedTimeShorthandToSeconds(raw){
      if (raw == null) return null;
      let v = String(raw).trim();
      if (!v) return null;

      // Capture explicit sign if provided (positive-only: '-' is invalid)
      let sign = 1;
      if (v.startsWith('-')) { return null; }
      if (v.startsWith('+')) { v = v.slice(1).trim(); }

      // Full HH:MM:SS (with explicit sign already applied above)
      let m = v.match(/^(\d{1,2}):(\d{2}):(\d{2})$/);
      if (m){
        const h = parseInt(m[1],10) || 0;
        const mn = parseInt(m[2],10) || 0;
        const s = parseInt(m[3],10) || 0;
        if (mn>59 || s>59) return null;
        return sign * (h*3600 + mn*60 + s);
      }

      // MM.SS or MM:SS
      m = v.match(/^(\d{1,3})[\.:](\d{1,2})$/);
      if (m){
        const mn = parseInt(m[1],10);
        const s = parseInt(m[2],10);
        if (!Number.isFinite(mn) || !Number.isFinite(s) || s<0 || s>59) return null;
        return sign * (mn*60 + s);
      }

      // Digits-only
      if (!/^\d+$/.test(v)) return null;
      const n = parseInt(v,10);
      if (!Number.isFinite(n)) return null;

      if (v.length <= 2){
        return sign * n;
      }

      if (v.length <= 4){
        const mn = Math.floor(n / 100);
        const s = n % 100;
        if (s>59) return null;
        return sign * (mn*60 + s);
      }

      // 5+ digits: treat as seconds
      return sign * n;
    }


    function normaliseAddedTimeInput(inp, commit=true){
      if (!inp) return false;
      const lastGood = inp.dataset.lastGood || (inp.value ? String(inp.value).trim() : '00:00:00');
      const secs = parseAddedTimeShorthandToSeconds(inp.value);
      if (secs == null){
        if (commit) inp.value = lastGood;
        return false;
      }
      const norm = formatSecondsToTime(secs);
      if (commit) inp.value = norm;
      inp.dataset.lastGood = norm;
      return true;
    }


    function formatSecondsToTime(totalSeconds){
      let sec = Math.max(0, Math.floor(totalSeconds));
      const h = Math.floor(sec / 3600);
      sec -= h * 3600;
      const mnt = Math.floor(sec / 60);
      const s = sec - mnt * 60;
      const pad = (n) => String(n).padStart(2, '0');
      return pad(h) + ':' + pad(mnt) + ':' + pad(s);
    }


    // --- DIST input numeric handling (align with main schedule page) ---
    const distLastOK = new WeakMap();

    function parseNumberLike(v){
      if (typeof v !== 'string') v = String(v ?? '');
      v = v.trim().replace(/\s+/g,'').replace(',', '.');
      if (v.startsWith('.')) v = '0' + v;
      if (!/^\d*(?:\.\d*)?$/.test(v)) return NaN;
      return Number(v);
    }

    function normaliseDistInput(inp, commit=true){
      if (!inp) return false;
      const num = parseNumberLike(inp.value);
      if (isNaN(num)) {
        const fb = distLastOK.has(inp) ? distLastOK.get(inp) : '';
        if (commit) inp.value = fb;
        return false;
      }

// v3.42 — DIST must be non-decreasing down the table (no silent clamping).
function validateMonotonicDist_(inp){
  try{
    if(!inp) return;
    const tr = inp.closest('tr');
    if(!tr) return;
    if(tr.classList.contains('start-row')){
      inp.classList.remove('dist-error');
      return;
    }
    // find previous non-template row
    let prev = tr.previousElementSibling;
    while(prev && (prev.classList && prev.classList.contains('row-template'))) prev = prev.previousElementSibling;
    if(!prev) { inp.classList.remove('dist-error'); return; }

    const prevInp = prev.querySelector('td.col-dist input[type="text"]');
    const prevVal = prevInp ? parseFloat(prevInp.value) : 0;
    const curVal = parseFloat(inp.value);
    if(Number.isFinite(prevVal) && Number.isFinite(curVal) && (curVal + 1e-9) < prevVal){
      inp.classList.add('dist-error');
    }else{
      inp.classList.remove('dist-error');
    }
  }catch(e){}
}
function validateAllMonotonicDists_(){
  try{
    if(!tbody) return;
    const trs = Array.from(tbody.querySelectorAll('tr:not(.row-template)'));
    for(let i=1;i<trs.length;i++){
      const inp = trs[i].querySelector('td.col-dist input[type="text"]');
      if(inp) validateMonotonicDist_(inp);
    }
  }catch(e){}
}

      const clamped = Math.max(0, Math.min(999, num));
      const fixed = clamped.toFixed(2);
      if (commit) inp.value = fixed;
      distLastOK.set(inp, fixed);
      return true;
    }

    function recalcTimes(){
      if (!tbody) return;
      const trs = Array.from(tbody.querySelectorAll('tr:not(.row-template)'));
      if (!trs.length) return;

      // base time: row 0 uses whatever is in its time cell
      const firstTimeInput = trs[0].querySelector('td.col-time .with-checkbox input[type="text"]');
      let currentSeconds = parseTimeToSeconds(firstTimeInput ? firstTimeInput.value : '00:00:00');
      if (firstTimeInput && !firstTimeInput.value) {
        firstTimeInput.value = formatSecondsToTime(currentSeconds);
      }

      for (let i = 1; i < trs.length; i++) {
        const prevTr = trs[i - 1];
        const currTr = trs[i];

        const prevDistInput = prevTr.querySelector('td.col-dist .with-checkbox input[type="text"]');
        const currDistInput = currTr.querySelector('td.col-dist .with-checkbox input[type="text"]');
        const prevSpeedInput = prevTr.querySelector('td.col-speed input[type="text"]');
        const currTimeInput = currTr.querySelector('td.col-time .with-checkbox input[type="text"]');

        // v5.91 — START STC is a hard restart for time accumulator
        if (currTr.classList.contains('start-stc')) {
          currentSeconds = 0;
          const t0 = '00:00:00';
          if (currTimeInput) currTimeInput.value = t0;
          if (currDistInput) currDistInput.classList.remove('dist-invalid');
          if (window.scheduleRows && Array.isArray(window.scheduleRows) && window.scheduleRows[i]) {
            window.scheduleRows[i].time = t0;
          }
          continue;
        }


        const prevRaw = prevDistInput ? String(prevDistInput.value).trim().replace(',','.') : '';
        const currRaw = currDistInput ? String(currDistInput.value).trim().replace(',','.') : '';
        let prevDist = prevRaw ? parseFloat(prevRaw) : 0;
        let currDist = currRaw ? parseFloat(currRaw) : NaN;
        if(!Number.isFinite(prevDist)) prevDist = 0;
        if(!Number.isFinite(currDist)) currDist = prevDist;

        let legDist = currDist - prevDist;
        let isBackwards = Number.isFinite(legDist) && legDist < 0;
        if (!Number.isFinite(legDist)) legDist = 0;
        // Distances should normally be non-decreasing; if not, mark pill and treat leg as 0 for lab
        if (isBackwards) {
          if (typeof LAB_DEBUG !== 'undefined' && LAB_DEBUG) {
            console.warn('Negative legDist detected in lab, treating as 0', { prevDist, currDist });
          }
          legDist = 0;
        }
        if (currDistInput) {
          if (isBackwards) {
            currDistInput.classList.add('dist-invalid');
          } else {
            currDistInput.classList.remove('dist-invalid');
          }
        }

        let speedPrev = prevSpeedInput ? parseFloat(prevSpeedInput.value) || 0 : 0;
        if (speedPrev <= 0) {
          // Zero/invalid speed is not allowed in lab: default to 6 km/h
          speedPrev = 6;
          if (prevSpeedInput) {
            prevSpeedInput.value = String(speedPrev);
            // NOTE v3.86: do not clear pristine on auto-fix during recalc/hydrate
          }
          if (window.scheduleRows && Array.isArray(window.scheduleRows) && window.scheduleRows[i - 1]) {
            window.scheduleRows[i - 1].speed = String(speedPrev);
          }
        }

        let legSeconds = 0;
        if (speedPrev > 0 && legDist > 0) {
          const legHours = legDist / speedPrev;
          legSeconds = legHours * 3600;
        }

        // Added Time: if the previous row has an Added Time pill, include it in the leg
        const atInput = prevTr.querySelector('.time-to-add');
        let addedSec = 0;
        if (atInput && atInput.value) {
          addedSec = parseTimeToSeconds(atInput.value);
        }

        currentSeconds += legSeconds + addedSec;
        const tStr = formatSecondsToTime(currentSeconds);
        if (currTimeInput) {
          currTimeInput.value = tStr;
        }

        if (window.scheduleRows && Array.isArray(window.scheduleRows) && window.scheduleRows[i]) {
          window.scheduleRows[i].time = tStr;
        }
      }
          try{ queueAllLaneRecalc(); }catch(_){ }
    }

    // expose recalcTimes for other modules (e.g. Added Time pill)
    if (!window.scheduleLab) window.scheduleLab = {};

        // Expose row builder for rows import
    window.scheduleLab.createRowDom = createRowDom;
    window.__createRowDom = createRowDom;
// ─────────────────────────────────────────────────────────────
    // Row gear menu wiring (v1.65)
    // ─────────────────────────────────────────────────────────────
    const rowMenu = document.getElementById('labRowMenu');
    let rowMenuForTr = null;
    let lastRowTr = null;

    // Canonical active-row tracking (v1.65)
    // Keep a reliable reference to the last interacted row so hotkeys and menu actions
    // always know which row is "current".
    function setActiveRowFromEl(el){
      if(!tbody || !el || !el.closest) return;
      const tr = el.closest('tr');
      if(!tr) return;
      if(tr.classList && tr.classList.contains('row-template')) return;
      // Only accept rows that belong to the schedule body
      if(tr.parentElement !== tbody) return;
      lastRowTr = tr;
    }
    if(tbody){
      // Capture interactions even when focus is inside inputs.
      tbody.addEventListener('mousedown', (ev)=> setActiveRowFromEl(ev.target), true);
      tbody.addEventListener('focusin', (ev)=> setActiveRowFromEl(ev.target), true);
    }

    function closeRowMenu(){
      if(!rowMenu) return;
      rowMenu.classList.add('hidden');
      rowMenu.setAttribute('aria-hidden','true');
      rowMenuForTr = null;
    }

    function openRowMenu(btn, tr){
      if(!rowMenu || !btn || !tr) return;
      rowMenuForTr = tr;
      lastRowTr = tr;
// Position near the gear icon; keep inside viewport
      const r = btn.getBoundingClientRect();
      rowMenu.classList.remove('hidden');
      rowMenu.setAttribute('aria-hidden','false');

      // Temporarily place offscreen to measure
      rowMenu.style.left = '-9999px';
      rowMenu.style.top = '-9999px';

      const m = rowMenu.getBoundingClientRect();
      const pad = 8;
      let left = window.scrollX + r.right + pad;
      let top  = window.scrollY + r.top;

      // If would overflow right, flip to left side of gear
      if(left + m.width > window.scrollX + window.innerWidth - pad){
        left = window.scrollX + r.left - m.width - pad;
      }
      // If would overflow bottom, align to bottom of gear
      if(top + m.height > window.scrollY + window.innerHeight - pad){
        top = window.scrollY + r.bottom - m.height;
      }
      // Clamp
      left = Math.max(window.scrollX + pad, left);
      top  = Math.max(window.scrollY + pad, top);

      rowMenu.style.left = left + 'px';
      rowMenu.style.top  = top + 'px';
    }

    function toggleRowMenu(btn, tr){
      if(!rowMenu) return;
      const isOpen = !rowMenu.classList.contains('hidden');
      if(isOpen && rowMenuForTr === tr){
        closeRowMenu();
      }else{
        openRowMenu(btn, tr);
      }
    }

    if(rowMenu){
      // Stop clicks inside menu from closing it
      rowMenu.addEventListener('click', ev=>{
        ev.stopPropagation();
        const b = ev.target.closest('button');
        if(!b) return;

        // Insert actions
        const act = b.dataset.act || '';
        const typ = b.dataset.type || '';
        if(act === 'insert-below'){
          if(lastRowTr) insertRowBelow(lastRowTr, typ);
          closeRowMenu();
          return;
        }

        // Delete action (legacy attribute name in markup)
        const del = b.dataset.action || '';
        if(del === 'delete-row'){
          if(lastRowTr){
            // v5.86: Ctrl+Alt+D can request an immediate delete (no confirm)
            const noConfirm = !!window.__TD_DELETE_NO_CONFIRM;
            window.__TD_DELETE_NO_CONFIRM = false;
            if(noConfirm){
              deleteRowByTr(lastRowTr);
              closeRowMenu();
            } else {
              const ok = window.confirm('Delete this row?');
              if(ok){
                deleteRowByTr(lastRowTr);
                closeRowMenu();
              }
            }
          }
return;
        }
      });
    }

    // Delegate gear clicks (works for existing + newly inserted rows)
    if(tbody){
      tbody.addEventListener('click', ev=>{
        const btn = ev.target.closest('button.row-gear');
        if(!btn) return;
        ev.preventDefault();
        ev.stopPropagation();
        const tr = btn.closest('tr');
        if(!tr || tr.classList.contains('row-template')) return;
        toggleRowMenu(btn, tr);
      });
    }


    // Track last active schedule row (so hotkeys work without opening the menu)
    document.addEventListener('mousedown', ev=>{
      const tr = ev.target && ev.target.closest ? ev.target.closest('tr') : null;
      if(tr && tr.querySelector && tr.querySelector('.row-gear')) lastRowTr = tr;
    }, true);

    document.addEventListener('focusin', ev=>{
      const tr = ev.target && ev.target.closest ? ev.target.closest('tr') : null;
      if(tr && tr.querySelector && tr.querySelector('.row-gear')) lastRowTr = tr;
    }, true);

    // Global close handlers
    document.addEventListener('click', ()=> closeRowMenu());
    document.addEventListener('keydown', ev=>{
      const ae = document.activeElement;
      const isTextField = ae && (ae.tagName === 'INPUT' || ae.tagName === 'TEXTAREA' || ae.isContentEditable);

            const isInSg = !!(ev.target && ev.target.closest && ev.target.closest('.sg-home-frame, #sg-transfer-harness-root, #sg-root'));
// Close
      if(ev.key === 'Escape') { closeRowMenu(); return; }


      // Event hygiene: do not run global shortcuts when focus is inside SG.
      if (isInSg) return;
// Delete shortcut (Ctrl+Alt+D) — immediate delete (no confirm) (v5.86)
      if(ev.ctrlKey && ev.altKey && !ev.shiftKey && (ev.key === 'd' || ev.key === 'D')){
        const tr = lastRowTr;
        if(tr){
          ev.preventDefault();
          // Defensive: if any handler routes through the menu delete action, bypass confirm once.
          window.__TD_DELETE_NO_CONFIRM = true;
          try {
            deleteRowByTr(tr);
          } finally {
            window.__TD_DELETE_NO_CONFIRM = false;
          }
          // Close any open row menu UI
          closeRowMenu();
        }
        return;
      }

      // Undo last delete (single-step)
      if(!isTextField && ev.ctrlKey && !ev.shiftKey && !ev.altKey && (ev.key === 'z' || ev.key === 'Z')){
        const snap = window.__lastRowDelete;
        if(snap && snap.trClone && typeof snap.idx === 'number'){
          ev.preventDefault();
          const rows = Array.from(tbody.querySelectorAll('tr:not(.row-template)'));
          const before = rows[snap.idx] || null;
          if(before) tbody.insertBefore(snap.trClone, before);
          else tbody.appendChild(snap.trClone);

          if(window.scheduleRows && Array.isArray(window.scheduleRows) && snap.rowObj != null){
            const ii = Math.max(0, Math.min(snap.idx, window.scheduleRows.length));
            window.scheduleRows.splice(ii, 0, snap.rowObj);
          }
          renumberRows();
          markDuplicateSpeeds();
          if (typeof recalcTimes === 'function') recalcTimes();
                    lastRowTr = snap.trClone;
          window.__lastRowDelete = null;
        }
        return;
      }
    });

    window.scheduleLab.recalcTimes = recalcTimes;

    function markDuplicateSpeeds(){
      const trs = Array.from(tbody.querySelectorAll('tr:not(.row-template)'));
      let prevSpeed = null;
      trs.forEach(tr=>{
        const inp = tr.querySelector('td.col-speed input[type="text"]');
        if(!inp) return;
        const val = inp.value.trim();
        if(prevSpeed!==null && val!=='' && val===prevSpeed){
          inp.classList.add('speed-dup');
        } else {
          inp.classList.remove('speed-dup');
        }
        prevSpeed = val;
      });
    }


    const SPEED_MIN = 6;
    const SPEED_MAX_DEFAULT = 120;

    function _adminSgMax_(sgId){
      try{
        const am = (window.tdScheduleGetAdminMeta_ ? window.tdScheduleGetAdminMeta_() : null);
        const speeds = (am && am.ok) ? (am.speeds || null) : null;
        const v = speeds ? (speeds[String(sgId)] ?? speeds[sgId]) : undefined;
        const n = Number(v);
        return Number.isFinite(n) ? n : NaN;
      }catch(_){ return NaN; }
    }

    function getSpeedMax(sgId = 1){
      // Prefer Admin-provided per-SG maxima when TD_RALLIES is present.
      const adminMax = _adminSgMax_(sgId);
      if(Number.isFinite(adminMax) && adminMax >= SPEED_MIN){
        return Math.max(SPEED_MIN, Math.min(SPEED_MAX_DEFAULT, adminMax));
      }

      // Fallback: legacy JSON global max (offline/standalone mode)
      const j = window.scheduleJson || window.scheduleJSON || window.SCHEDULE_JSON || null;
      const m = j && (j.maxSpeed ?? j.speedMax ?? j.speedMaxKph ?? undefined);

      // Important: if m is null/undefined/blank, treat as "not provided" (don't let Number(null) => 0)
      const n = (m === null || m === undefined || m === '') ? NaN : Number(m);

      // Guard: never allow a max below the minimum; fall back to default (JSON-ready)
      const mx = (Number.isFinite(n) && n >= SPEED_MIN) ? n : SPEED_MAX_DEFAULT;
      return Math.max(SPEED_MIN, Math.min(SPEED_MAX_DEFAULT, mx));
    }

    // Re-clamp existing speeds when Admin lowers SG maxima (system correction).
    // Called after Admin meta refresh; MUST NOT touch pristine markers or row init state.
    window.tdScheduleReClampToAdmin_ = function(reason){
      try{
        if(!tbody) return;
        const trs = Array.from(tbody.querySelectorAll('tr:not(.row-template)'));
        if(!trs.length) return;

        const changedLanes = new Set();
        let changed = 0;

        function _dispatchSpeedEvents(inp){
          try{ inp.dispatchEvent(new Event('input',{bubbles:true})); }catch(_){}
          try{ inp.dispatchEvent(new Event('change',{bubbles:true})); }catch(_){}
        }

        function _clampSpeedInput(inp, mx, lid){
          if(!inp) return false;
          const raw = String(inp.value||'').trim();
          const n = parseInt(raw, 10);
          if(!Number.isFinite(n)) return false;
          const clamped = Math.max(SPEED_MIN, Math.min(mx, n));
          if(clamped === n) return false;

          // Update DOM value
          inp.value = String(clamped);

          // If this is a lane speed, keep the row dataset in sync (lane recalc reads dataset first)
          if(Number.isFinite(lid)){
            try{
              const tr2 = inp.closest('tr');
              if(tr2 && tr2.dataset){
                tr2.dataset["sg"+String(lid)+"Speed"] = String(clamped);
              }
            }catch(_){}
            try{ changedLanes.add(lid); }catch(_){}
          }

          // IMPORTANT: programmatic clamps must behave like a user edit so card logic and lane logic recalc.
          _dispatchSpeedEvents(inp);

          return true;
        }

        // SG1 main grid SPEED
        const mx1 = getSpeedMax(1);

        trs.forEach(tr=>{
          const gridInp = tr.querySelector('td.col-speed input[type="text"]');
          if(_clampSpeedInput(gridInp, mx1, NaN)) changed++;

          // SG inline lane speeds (SG2..SG4 etc.)
          tr.querySelectorAll('.sg-inline-lane[data-lane-id] input.sg-speed-input').forEach(inp=>{
            const lane = inp.closest('.sg-inline-lane');
            const lid = lane ? parseInt(String(lane.getAttribute('data-lane-id')||'').trim(), 10) : NaN;
            if(!Number.isFinite(lid)) return;
            const mx = getSpeedMax(lid);
            if(_clampSpeedInput(inp, mx, lid)) changed++;
          });
        });

        if(!changed) return;

        // Page times (already correct logic; just refresh after clamp)
        try{ recalcTimes(); }catch(_){}

        // Lane times: if a queue helper exists, nudge it once per changed lane.
        // (Events above should already cover normal paths; this is just a safe nudge.)
        try{
          const qlr = (typeof window.queueLaneRecalc === "function") ? window.queueLaneRecalc : null;
          if(qlr && changedLanes.size){
            changedLanes.forEach(lid=>{ try{ qlr(lid); }catch(_){} });
          }
        }catch(_){}

        // Optional toast (if your toast helper exists)
        try{
          if(typeof window.toast === 'function'){
            window.toast('Clamped ' + changed + ' speed value' + (changed===1?'':'s') + ' to new Admin limits');
          }
        }catch(_){}
      }catch(_){}
    };



if (tbody) {
      tbody.addEventListener('input', function(e){
        const t = e.target;
        const speedInput = t.closest('td.col-speed input[type="text"]');
        const distInput = t.closest('td.col-dist .with-checkbox input[type="text"]');

        // Clear pristine ring on first valid edit
        if (t.classList && t.classList.contains('is-pristine')) {
          const td = t.closest('td');
          if (td && td.classList.contains('col-dist')) {
            const v = parseFloat(t.value);
            if (!Number.isNaN(v) && v >= 0) {
              window._pSetForEl(t, false);
            }
          } else if (td && td.classList.contains('col-speed')) {
            const v = parseFloat(t.value);
            const mx = getSpeedMax();
            if (!Number.isNaN(v) && v >= SPEED_MIN && v <= mx) {
              window._pSetForEl(t, false);
            }
          }
        }

        if (speedInput) {
          markDuplicateSpeeds();
          recalcTimes();
        } else if (distInput) {
          // live typing in DIST still recalcs, normalisation happens on blur/change
          recalcTimes();
        }
      });


      // v6.81 — record prior SPEED value on focus so blur can distinguish click-vs-edit (pristine clears only on change)
      tbody.addEventListener('focusin', function(e){
        const speedInput = e.target.closest && e.target.closest('td.col-speed input[type="text"]');
        if (speedInput) {
          speedInput.dataset.tdPrevVal = String(speedInput.value || '').trim();
        }
      }, true);

      // On blur, normalise DIST to NN.NN and clamp 0..999; reject rubbish back to last good/blank
      tbody.addEventListener('blur', function(e){
        const distInput = e.target.closest('td.col-dist input[type="text"]');
        if (distInput) {
          normaliseDistInput(distInput, true);
          validateMonotonicDist_(distInput);
          recalcTimes();
          try{ if(typeof sgAdapterRefresh==='function') sgAdapterRefresh(); }catch(_){ }
          return;
        }

        const speedInput = e.target.closest('td.col-speed input[type="text"]');
        if (speedInput) {
          const mx = getSpeedMax();
          const raw = String(speedInput.value || '').trim();
          const n = parseInt(raw, 10);
          if (Number.isFinite(n)) {
            const clamped = Math.max(SPEED_MIN, Math.min(mx, n));
            const newStr = String(clamped);
            // Always normalise the displayed value (idempotent if unchanged)
            speedInput.value = newStr;

            // v6.81 — only clear pristine if the user actually changed the value
            const prev = (speedInput.dataset && typeof speedInput.dataset.tdPrevVal === 'string')
              ? speedInput.dataset.tdPrevVal
              : null;
            const isPristine = !!(speedInput.classList && speedInput.classList.contains('is-pristine'));
            if (isPristine && prev !== null && prev.trim() === newStr) {
              window._pSetForEl(speedInput, true); // click/focus/blur with no change
            } else {
              window._pSetForEl(speedInput, false);
            }
          } else {
            // invalid -> keep pristine (do not coerce)
            window._pSetForEl(speedInput, true);
          }
          markDuplicateSpeeds();
          recalcTimes();
          try{ if(typeof sgAdapterRefresh==='function') sgAdapterRefresh(); }catch(_){ }
          return;
        }

        // Added Time (page): validate-on-commit; revert to last-good if invalid
        const atInput = e.target.closest('input.time-to-add');
        if (atInput) {
          if (atInput.closest('.ncard')) return; // SG cards stay independent
          normaliseAddedTimeInput(atInput, true);
          recalcTimes();

          // v6.39: AT edits must mark dirty + persist (Bake B regression fix)
          try{ _markScheduleDirty_(); }catch(_){ }
          try{
            if (typeof window._scheduleSettleSync_ === 'function') window._scheduleSettleSync_(450);
            else if (typeof window.syncScheduleToTdRallies === 'function') setTimeout(()=>window.syncScheduleToTdRallies('AT_EDIT'), 0);
          }catch(_){ }
        }

        // SG card Added Time: validate-on-commit; revert to last-good if invalid (independent per lane)
        const sgAtInput = e.target.closest('input.card-at-input');
        if (sgAtInput) {
          normaliseAddedTimeInput(sgAtInput, true);
          const lane = sgAtInput.closest('.sg-inline-lane');
          if (lane) lane.dataset.atValue = sgAtInput.value;
        }
      }, true);

      // Added Time (page): Enter commits (blur triggers validation/normalisation)
      tbody.addEventListener('keydown', function(e){
        const inp = e.target;
        if (!(inp instanceof HTMLInputElement)) return;
        const isPageAT = inp.classList.contains('time-to-add');
        const isCardAT = inp.classList.contains('card-at-input');
        if (!isPageAT && !isCardAT) return;
        // page AT ignores SG cards; SG card AT is separate
        if (isPageAT && inp.closest('.ncard')) return;
        if (e.key === 'Enter') {
          e.preventDefault();
          inp.blur();
        }
      });


      // Select-all on focus for DIST/SPEED and Added Time (page) (matches ref behaviour)
      tbody.addEventListener('focusin', function(e){
        const inp = e.target;
        if (!(inp instanceof HTMLInputElement)) return;

        // Added Time input lives inside the instruction cell (no col-* td)
        if (inp.classList.contains('time-to-add')) {
          if (inp.closest('.ncard')) return; // SG cards stay independent
          if (!inp.dataset.lastGood) {
            inp.dataset.lastGood = (inp.value && String(inp.value).trim()) ? String(inp.value).trim() : '00:00:00';
          }
          setTimeout(function(){
            try { inp.select(); } catch(_) {}
          }, 0);
          return;
        }

        // SG card Added Time: focus-select + seed lastGood (parity with page AT; still independent)
        if (inp.classList.contains('card-at-input')) {
          if (!inp.dataset.lastGood) {
            inp.dataset.lastGood = (inp.value && String(inp.value).trim()) ? String(inp.value).trim() : '00:00:00';
          }
          setTimeout(function(){
            try { inp.select(); } catch(_) {}
          }, 0);
          return;
        }

        const td = inp.closest('td');
        if (!td) return;
        if (!td.classList.contains('col-dist') && !td.classList.contains('col-speed')) return;
        setTimeout(function(){
          try { inp.select(); } catch(_) {}
        }, 0);
      });

      // Prevent first mouseup from clearing the selection
      tbody.addEventListener('mouseup', function(e){
        const inp = e.target;
        if (!(inp instanceof HTMLInputElement)) return;

        if (inp.classList.contains('time-to-add')) {
          if (inp.closest('.ncard')) return; // SG cards stay independent
          e.preventDefault();
          return;
        }

        // SG card Added Time: prevent mouseup from clearing the selection
        if (inp.classList.contains('card-at-input')) {
          e.preventDefault();
          return;
        }

        const td = inp.closest('td');
        if (!td) return;
        if (!td.classList.contains('col-dist') && !td.classList.contains('col-speed')) return;
        e.preventDefault();
      });
      // Checkbox changes – update print styles (DIST/TIME colours)
      tbody.addEventListener('change', function(e){
        const cb = e.target.closest('.with-checkbox input[type="checkbox"]');
        if (!cb) return;
        const tr = cb.closest('tr');
        if (tr) applyPrintStylesForTr(tr);
      });

      // TURN select changes – keep pill label in sync
      tbody.addEventListener('change', function(e){
        const sel = (e.target && e.target.closest) ? e.target.closest('select.turn-select') : null;
        if (!sel) return;
        try{ _syncTurnPillForSelect_(sel); }catch(_){}
      });

    }

// Expose the snapshot + current rows + addRow/insert/deleteRow on window for now
    window.scheduleLab = window.scheduleLab || {};
    window.scheduleLab.snapshot = snapshotScheduleTable;
    window.scheduleLab.addRowFromMenuType = addRowFromMenuType;
    window.scheduleLab.insertRowBelow = insertRowBelow;
    window.scheduleLab.deleteRowByTr = deleteRowByTr;
    window.scheduleRows = snapshotScheduleTable();

    // Initialize TURN pills for existing rows
    if (tbody) {
      const trsInit = Array.from(tbody.querySelectorAll('tr:not(.row-template)'));
      trsInit.forEach(enhanceTurnCell);
      // First default row is the fixed start row: DIST is fixed 0.00 (no pristine),
      // but SPEED must still be confirmed by the user (keep its orange ring).
      if (trsInit.length > 0) {
        const first = trsInit[0];
        const firstDist = first.querySelector('td.col-dist input[type="text"]');
        if (firstDist) window._pSetForEl(firstDist, false);
      }
      refreshAllPrintStyles();
    }

    if (LAB_DEBUG) console.log('Schedule Table Lab v0.18 – scheduleRows', window.scheduleRows);
  })();
</script>
<div aria-hidden="true" class="sg-quarantine-root" id="sg-transfer-harness-root" style="display:none;"></div>
<script id="sg1-mount-instruction-only">
(() => {
  "use strict";

  const LANE_IDS = [2,3,4];


  const SPEED_MIN = 6;
    const SPEED_MAX_DEFAULT = 120;

    function _adminSgMax_(sgId){
      try{
        const am = (window.tdScheduleGetAdminMeta_ ? window.tdScheduleGetAdminMeta_() : null);
        const speeds = (am && am.ok) ? (am.speeds || null) : null;
        const v = speeds ? (speeds[String(sgId)] ?? speeds[sgId]) : undefined;
        const n = Number(v);
        return Number.isFinite(n) ? n : NaN;
      }catch(_){ return NaN; }
    }

    function sgGetSpeedMax(sgIdOrEl){
      // Accept either an SG id (1..4) OR an input element inside a lane.
      let sgId = sgIdOrEl;
      try{
        if(sgIdOrEl && (sgIdOrEl instanceof Element)){
          const lane = sgIdOrEl.closest('.sg-inline-lane');
          if(lane && lane.dataset && lane.dataset.laneId) sgId = lane.dataset.laneId;
        }
      }catch(_){}

      // Prefer Admin-provided per-SG maxima when TD_RALLIES is present.
      const adminMax = _adminSgMax_(sgId);
      if(Number.isFinite(adminMax) && adminMax >= SPEED_MIN){
        return Math.max(SPEED_MIN, Math.min(SPEED_MAX_DEFAULT, adminMax));
      }

      // Fallback: legacy JSON global max (offline/standalone mode)
      const j = window.scheduleJson || window.scheduleJSON || window.SCHEDULE_JSON || null;
      const m = j && (j.maxSpeed ?? j.speedMax ?? j.speedMaxKph ?? undefined);

      const n = (m === null || m === undefined || m === '') ? NaN : Number(m);
      const mx = (Number.isFinite(n) && n >= SPEED_MIN) ? n : SPEED_MAX_DEFAULT;
      return Math.max(SPEED_MIN, Math.min(SPEED_MAX_DEFAULT, mx));
    }
// v3.77 — SG monitor model (core switch)
  // Authoritative state lives on the table rows (DOM), not a separate lane model.
  // Each TR stores per-lane speed/tick/AT in data-* so rebuild/add-row stays stable.

  function ensureRowUid(tr){
    if(!tr) return null;

    // If this TR was cloned, it may already carry a uid that belongs to another row.
    // Treat that as invalid and allocate a fresh uid so state doesn't "bleed" across rows.
    let uid = tr.dataset.sgRowUid || null;
    if(uid){
      const existing = document.querySelector(`tr[data-sg-row-uid="${uid}"]`);
      if(existing && existing !== tr){
        uid = null;
        try{ delete tr.dataset.sgRowUid; }catch(_){}
      }
    }
    if(!uid){
      uid = "r" + (Date.now().toString(36) + Math.random().toString(36).slice(2,6));
      tr.dataset.sgRowUid = uid;
      tr.dataset.sgFresh = "1";
    }
    return uid;
  }

  function _dsGet(tr, k, fallback=null){
    const v = tr && tr.dataset ? tr.dataset[k] : undefined;
    return (v === undefined || v === null || v === "") ? fallback : v;
  }
  function _dsSet(tr, k, v){
    if(!tr || !tr.dataset) return;
    if(v === undefined || v === null || v === ""){ try{ delete tr.dataset[k]; }catch(_){ tr.dataset[k] = ""; } return; }
    tr.dataset[k] = String(v);
  }
  function _laneKey(lid, suffix){ return "sg" + String(lid) + suffix; }

  function getLaneStateFromRow(tr, laneId){
    const lid = String(laneId);
    ensureRowUid(tr);

    // speed
    let speed = null;
    const dsSpeed = _dsGet(tr, _laneKey(lid, "Speed"), null);
    if(dsSpeed != null){
      const n = parseInt(String(dsSpeed).trim(), 10);
      if(Number.isFinite(n)) speed = n;
    }
    if(speed === null){
      // fallback from DOM
      const sp = tr.querySelector(`.sg-inline-lane[data-lane-id="${lid}"] input.sg-speed-input`);
      const n = sp ? parseInt(String(sp.value||"").trim(), 10) : NaN;
      if(Number.isFinite(n)) speed = n;
    }
    // tick boxes are display-only from v5.41 (page TIME tick is source of truth)
    const tick = false;

    // AT (HH:MM:SS string; only meaningful on addedTime rows)
    const at = _dsGet(tr, _laneKey(lid, "At"), "");

    const speedUser = _dsGet(tr, _laneKey(lid, "SpeedUser"), "0") === "1";
    const atUser = _dsGet(tr, _laneKey(lid, "AtUser"), "0") === "1";

    return { speed, speedUser, tick, at, atUser };
  }

  function snapshotRowFromDom(tr){
    // Best-effort: harvest current DOM values into row dataset BEFORE we rebuild lanes.
    try{
      if(!tr) return;
      ensureRowUid(tr);
      tr.querySelectorAll(".sg-inline-lane").forEach(lane=>{
        const lid = lane.dataset.laneId;
        if(!lid) return;

        const sp = lane.querySelector("input.sg-speed-input");
        if(sp){
          const n = parseInt(String(sp.value||"").trim(), 10);
          if(Number.isFinite(n)) _dsSet(tr, _laneKey(lid, "Speed"), n);
        }

        const at = lane.querySelector("input.card-at-input");
        if(at){
          const v = String(at.value||"").trim() || "00:00:00";
          _dsSet(tr, _laneKey(lid, "At"), v);
        }
      });
    }catch(_){}
  }

  function hydrateLaneFromModel(tr, lane, laneId){
    // "Model" == row dataset state (monitor model)
    const lid = String(laneId);
    const st = getLaneStateFromRow(tr, lid);

    // Speed
    const sp = lane.querySelector("input.sg-speed-input");
    if(sp){
      if(Number.isFinite(st.speed)){
        sp.value = String(Math.max(SPEED_MIN, Math.min(sgGetSpeedMax(lid), st.speed)));
      }
      if(st.speedUser) sp.classList.remove("is-pristine");
      else sp.classList.add("is-pristine");
    }

    // Tick
    const cb = lane.querySelector("input.sg-time-checkbox");
    if(cb){
      cb.checked = false;
      // Paint-only: reflect state visually without wiring events.
      // v5.41: never disrows import lane-tick change; mirror comes from row TIME tick.
      const wrap = cb.closest('.pill-time-zone') || cb.parentElement;
      const tt = wrap ? wrap.querySelector('.sg-time-text') : null;
      if(tt){
        // keep neutral here; final paint is applied by row TIME mirror pass
        tt.classList.remove('is-red');
      }
    }

    // AT (only present on addedTime rows)
    const at = lane.querySelector("input.card-at-input");
    if(at){
      if(st.at) at.value = st.at;
      if(st.atUser) at.dataset.userEdited = "1";
      else at.removeAttribute("data-user-edited");
    }
  }

  function writeSpeedToModelFromInput(inp){
    const tr = inp.closest("tr");
    const lane = inp.closest(".sg-inline-lane");
    if(!tr || !lane) return;
    const lid = lane.dataset.laneId;
    ensureRowUid(tr);

    const n = parseInt(String(inp.value||"").trim(),10);
    if(Number.isFinite(n)) _dsSet(tr, _laneKey(lid, "Speed"), n);
    _dsSet(tr, _laneKey(lid, "SpeedUser"), "1");

    queueLaneRecalc(lid);
  }

  function writeAtToModel(inp){
    const tr = inp.closest("tr");
    const lane = inp.closest(".sg-inline-lane");
    if(!tr || !lane) return;
    const lid = lane.dataset.laneId;
    ensureRowUid(tr);

    const v = String(inp.value||"").trim() || "00:00:00";
    _dsSet(tr, _laneKey(lid, "At"), v);
    _dsSet(tr, _laneKey(lid, "AtUser"), "1");

    inp.dataset.userEdited = "1";
    queueLaneRecalc(lid);
  }
// v3.28 — SG time recompute (per lane; write times only; never touches speed/pristine)
  // Distances come from the table. Each lane (SG2/3/4) computes its own running time stream.
  function _sgParseHms(str){
    if(!str) return 0;
    const m = String(str).trim().match(/^(-?)(\d{1,2}):(\d{2}):(\d{2})$/);
    if(!m) return 0;
    const sign = m[1] === '-' ? -1 : 1;
    const h = parseInt(m[2],10) || 0;
    const mn = parseInt(m[3],10) || 0;
    const s = parseInt(m[4],10) || 0;
    return sign * (h*3600 + mn*60 + s);
  }
  function _sgPad2(n){ return String(Math.max(0, n|0)).padStart(2,'0'); }
  function _sgFormatHms(totalSeconds){
    let t = (Number.isFinite(totalSeconds) ? Math.round(totalSeconds) : 0);
    const sign = t < 0 ? '-' : '';
    t = Math.abs(t);
    const h = Math.floor(t/3600);
    const mn = Math.floor((t%3600)/60);
    const s = t%60;
    return sign + _sgPad2(h) + ':' + _sgPad2(mn) + ':' + _sgPad2(s);
  }

  const __SG_RECALC_PENDING__ = Object.create(null);
  function queueLaneRecalc(laneId){
    const lid = String(laneId);
    if(__SG_RECALC_PENDING__[lid]) return;
    __SG_RECALC_PENDING__[lid] = true;
    setTimeout(()=>{
      __SG_RECALC_PENDING__[lid] = false;
      try{ recalcLaneTimes(laneId); }catch(_){}
    }, 0);
  }
  function queueAllLaneRecalc(){
    LANE_IDS.forEach(id=>queueLaneRecalc(id));
  }

  function recalcLaneTimes(laneId){
    const tbody = document.querySelector('tbody');
    if(!tbody) return;
    const trs = Array.from(tbody.querySelectorAll('tr:not(.row-template)'));
    if(!trs.length) return;

    // Seed time from the start row time cell (same seed for all lanes; lanes diverge via their own speeds/AT)
    const firstTimeInput = trs[0].querySelector('td.col-time .with-checkbox input[type="text"]');
    let curSec = _sgParseHms(firstTimeInput ? firstTimeInput.value : '00:00:00');

    let pendingAddSec = 0; // one-shot Added Time injected before the *next* row only

    // Row 0: write into lane time text (if lane exists)
    const row0lane = trs[0].querySelector('.sg-inline-lane[data-lane-id="' + String(laneId) + '"]');
    if(row0lane){
      const tt = row0lane.querySelector('.sg-time-text');
      if(tt) tt.textContent = _sgFormatHms(curSec);
    }

    for(let i=1;i<trs.length;i++){
      const prevTr = trs[i-1];
      const tr = trs[i];

      // v5.91 — START STC is a hard restart for lane time accumulator
      if(tr.classList.contains('start-stc')){
        curSec = 0;
        pendingAddSec = 0;
        const lane0 = tr.querySelector('.sg-inline-lane[data-lane-id="' + String(laneId) + '"]');
        if(lane0){
          const tt0 = lane0.querySelector('.sg-time-text');
          if(tt0) tt0.textContent = _sgFormatHms(curSec);
        }
        continue;
      }

      // Apply any Added Time from the previous Added Time row (one-shot)
      if(pendingAddSec){ curSec += pendingAddSec; pendingAddSec = 0; }

      const prevDistInp = prevTr.querySelector('td.col-dist .with-checkbox input[type="text"]');
      const distInp = tr.querySelector('td.col-dist input[type="text"]');
      const prevDist = prevDistInp ? (parseFloat(prevDistInp.value) || 0) : 0;
      const distNow = distInp ? (parseFloat(distInp.value) || prevDist) : prevDist;
      let dKm = distNow - prevDist;
      if(!Number.isFinite(dKm) || dKm < 0) dKm = 0;

      // Speed comes from previous row's row-state (dataset)
      const prevSt = getLaneStateFromRow(prevTr, laneId);
      const speedPrev = (prevSt && Number.isFinite(prevSt.speed) && prevSt.speed > 0) ? prevSt.speed : 0;

      if(speedPrev > 0 && dKm > 0){
        const legSec = (dKm / speedPrev) * 3600; // km / (km/h) => hours; *3600 => seconds
        curSec += legSec;
      }

      const lane = tr.querySelector('.sg-inline-lane[data-lane-id="' + String(laneId) + '"]');
      if(lane){
        const tt = lane.querySelector('.sg-time-text');
        if(tt) tt.textContent = _sgFormatHms(curSec);
      }


      // Added Time rows: inject AT once into the *next* row only (does not change this row's displayed time)
      if(tr.classList.contains('added-time')){
        const st = getLaneStateFromRow(tr, laneId);
        const atSec = (st && st.at) ? _sgParseHms(st.at) : 0;
        const isOn = !(st && st.tick === true);
        if(isOn && atSec){ pendingAddSec += atSec; }
      }
    }


    // v3.31 — repeated-speed red hint (visual only; no state/pristine impact)
    try{ updateLaneRepeatSpeeds(laneId); }catch(_){ }
}

  // v3.31 — Apply repeated-speed hint per lane.
  // Rule: if row i speed equals row i-1 speed, row i speed text turns red (.is-repeat).
  // Visual only: does not affect model, maths, or pristine flags.
  function updateLaneRepeatSpeeds(laneId){
    const tbody = document.querySelector('tbody');
    if(!tbody) return;
    const trs = Array.from(tbody.querySelectorAll('tr:not(.row-template)'));
    if(trs.length < 2) return;
    const lid = String(laneId);

    // Clear all first
    for(let i=0;i<trs.length;i++){
      const lane = trs[i].querySelector('.sg-inline-lane[data-lane-id="' + lid + '"]');
      const inp = lane ? lane.querySelector('input.sg-speed-input') : null;
      if(inp) inp.classList.remove('is-repeat');
    }

    for(let i=1;i<trs.length;i++){
      const prevS = getLaneStateFromRow(trs[i-1], lid);
      const curS  = getLaneStateFromRow(trs[i], lid);
      const prevV = (prevS && Number.isFinite(prevS.speed)) ? prevS.speed : null;
      const curV  = (curS && Number.isFinite(curS.speed)) ? curS.speed : null;
      if(prevV === null || curV === null) continue;
      if(prevV !== curV) continue;
      const lane = trs[i].querySelector('.sg-inline-lane[data-lane-id="' + lid + '"]');
      const inp = lane ? lane.querySelector('input.sg-speed-input') : null;
      if(inp) inp.classList.add('is-repeat');
    }
  }


  function getRowType(tr){
    if(tr.classList.contains('start-stc')) return 'startStc';
    if(tr.classList.contains('stc-row')) return 'stc';
    if(tr.classList.contains('marshal-row')) return 'marshal';
    if(tr.classList.contains('open-control-row')) return 'openControl';
    if(tr.classList.contains('added-time')) return 'addedTime';
    return 'instruction';
  }

  // v5.36 — SG lane ticks interactive + immediate persist on toggle (fix refresh revert).
  const SG_PAINT_ONLY = false;
  function buildLanePill(laneId) {
    const lane = document.createElement("div");
    lane.className = "sg-inline-lane sg-lane-" + laneId + " sg-template-row1";
    lane.dataset.laneId = String(laneId);

    const pill = document.createElement("div");
    pill.className = "sg-pill-row1";

    const line1 = document.createElement("div");
    line1.className = "pill-line1";

    const timeZone = document.createElement("div");
    timeZone.className = "pill-time-zone";

    const timeText = document.createElement("span");
    timeText.className = "sg-time-text";
    timeText.textContent = "00:00:00";

    const tick = document.createElement("input");
    tick.type = "checkbox";
    tick.className = "sg-time-checkbox";
    tick.checked = false;

    timeZone.appendChild(timeText);
    timeZone.appendChild(tick);

    const speedZone = document.createElement("div");
    speedZone.className = "pill-speed-zone";

    const speedInput = document.createElement("input");
    speedInput.type = "text";
    speedInput.inputMode = "numeric";
    speedInput.className = "sg-speed-input is-pristine";
    speedInput.value = String((laneId===2||laneId==="2") ? 70 : (laneId===3||laneId==="3") ? 60 : 50); // v6.03 defaults: SG2=70 SG3=60 SG4=50

    if(!SG_PAINT_ONLY){
      // Focus-select
      speedInput.addEventListener("focus", () => {
        try { speedInput.select(); } catch(e) {}
      });

      // Wheel adjust (0–120)
      speedInput.addEventListener("wheel", (ev) => {
        if(document.activeElement !== speedInput) return;
        ev.preventDefault();
        const cur = parseInt(String(speedInput.value||"0").trim(), 10);
        const base = Number.isFinite(cur) ? cur : 0;
        const delta = (ev.deltaY < 0) ? 1 : -1;
        let v = base + delta;
        const mx = sgGetSpeedMax(speedInput);
        v = Math.max(SPEED_MIN, Math.min(mx, v));
        speedInput.value = String(v);
        speedInput.dispatchEvent(new Event("input", {bubbles:true}));
      }, {passive:false});

      // Pristine clearing + clamp on blur
      let _userInteracted = false;
      speedInput.addEventListener("input", () => { _userInteracted = true; writeSpeedToModelFromInput(speedInput); });
      speedInput.addEventListener("blur", () => {
        // IMPORTANT: blur can fire during rebuild (inputs removed/recreated).
        // Never treat that as a user edit, or we wipe pristine rings card-wide.
        if (!_userInteracted) return;

        const raw = String(speedInput.value || "").trim();
        const num0 = parseInt(raw, 10);
        const mx0 = sgGetSpeedMax(speedInput);
        const inRange0 = Number.isFinite(num0) && num0 >= SPEED_MIN && num0 <= mx0;

        if (inRange0) speedInput.classList.remove("is-pristine");
        else speedInput.classList.add("is-pristine");

        let v = num0;
        if (!Number.isFinite(v)) v = 0;
        const mx = sgGetSpeedMax(speedInput);
        v = Math.max(SPEED_MIN, Math.min(mx, v));
        speedInput.value = String(v);

        // Write-through to model only for real user edits.
        writeSpeedToModelFromInput(speedInput);
      });
    } else {
      // Paint-only: block interaction but keep visuals.
      speedInput.readOnly = true;
      speedInput.tabIndex = -1;
      speedInput.style.pointerEvents = 'none';
    }

    speedZone.appendChild(speedInput);

    line1.appendChild(timeZone);
    line1.appendChild(speedZone);
    pill.appendChild(line1);
    lane.appendChild(pill);

    // v5.41: SG lane tick boxes are display-only (disabled).
    tick.disabled = true;
    tick.tabIndex = -1;
    tick.style.pointerEvents = 'none';

    return lane;
  }

  function applyRowTypeParity(tr){
    const rowType = getRowType(tr);
    const lanes = tr.querySelectorAll(".sg-inline-lane");
    lanes.forEach(lane => {
      const t = lane.querySelector(".sg-time-text");
      const cb = lane.querySelector("input.sg-time-checkbox");
      const sp = lane.querySelector("input.sg-speed-input");

      // Defaults
      if(cb){
        cb.style.visibility = "";
        cb.disabled = true;
        cb.tabIndex = -1;
        cb.style.pointerEvents = 'none';
      }
      if(t){
        t.classList.remove("is-red");
      }
      if(sp){
        sp.style.color = "";
        sp.style.fontWeight = "";
        if(SG_PAINT_ONLY){
          sp.readOnly = true;
          sp.tabIndex = -1;
          sp.style.pointerEvents = 'none';
        }
      }

      if(rowType === "stc"){
        // STC: hide tick (keep space), force red time (won't print)
        if(cb){
          cb.checked = false;
          cb.disabled = true;
          cb.style.visibility = "hidden";
          cb.style.pointerEvents = "none";
        }
        if(t){
          t.classList.add("is-red");
        }
      }

      if(rowType === "startStc"){
        // Start STC: fixed 00:00:00 (table + SG lane) + hidden tick footprint
        // 1) SG lane time (if present)
        if(t){
          t.textContent = "00:00:00";
          t.classList.remove("is-red");
        }
        // 2) Table TIME input (always fixed)
        const timeInput = tr.querySelector('td.col-time input[type="text"]');
        if(timeInput){
          timeInput.value = "00:00:00";
          timeInput.readOnly = true;
          // keep it visually "fixed" (blue) but do not disturb layout
          timeInput.style.color = "#2563eb";
          timeInput.style.fontWeight = "400";
        }
        if(cb){
          cb.checked = false;
          cb.disabled = true;
          cb.style.visibility = "hidden";
          cb.style.pointerEvents = "none";
        }
      }

      if(rowType === "marshal"){
        // Marshal: hide tick footprint; force time+speed red
        if(cb){
          cb.checked = false;
          cb.disabled = true;
          cb.style.visibility = "hidden";
          cb.style.pointerEvents = "none";
        }
        if(t){
          t.classList.add("is-red");
        }
        if(sp){
          sp.style.color = "#dc2626";
          sp.style.fontWeight = "400";
        }
      }

      // Open Control uses CSS background parity already; no special JS.
    });
  }
  function isAddedTimeRow(tr){
    if(!tr) return false;
    if(tr.classList.contains("added-time")) return true;
    const rt = (tr.getAttribute("data-row-type") || "").toLowerCase();
    return rt === "addedtime" || rt === "added-time" || rt === "added_time";
  }

  function applyAddedTimeDeck(tr){
    const lanes = tr.querySelectorAll(".sg-home-frame[data-sg-home] .sg-inline-lane");

    // Always clear any existing AT blocks first (idempotent)
    lanes.forEach(lane => {
      lane.querySelectorAll(":scope .card-at").forEach(n=>n.remove());
      lane.querySelectorAll(":scope .sg-at-row").forEach(n=>n.remove());
      lane.classList.remove("has-at","sg-at-deck");
    });

    if(!isAddedTimeRow(tr)) { tr.classList.remove("sg-at-tall"); return; }

    // Added Time rows: SG lane becomes a 2-row deck:
    // Row 1 = time + speed (existing pill)
    // Row 2 = AT pill (independent per lane)
    tr.classList.add("sg-at-tall");

    lanes.forEach(lane => {
      lane.classList.add("has-at","sg-at-deck");

      // Ensure row1 pill stays first
      const pill = lane.querySelector(":scope > .sg-pill-row1");
      if(pill){
        // nothing
      }

      // Row 2 container
      const row2 = document.createElement("div");
      row2.className = "sg-at-row";

      const at = document.createElement("div");
      at.className = "card-at";
      const lab = document.createElement("span");
      lab.className = "card-at-label";
      lab.textContent = "AT";
      const inp = document.createElement("input");
      inp.className = "card-at-input";
      inp.type = "text";
      inp.readOnly = false;
      inp.tabIndex = 0;
      inp.autocomplete = "off";

      const st = getLaneStateFromRow(tr, lane.dataset.laneId);
      const laneAT = (st && st.at != null) ? String(st.at) : "";
      inp.value = laneAT || "00:00:00";
      inp.dataset.lastGood = inp.value;

      inp.addEventListener("input", ()=>{ writeAtToModel(inp); });
      inp.addEventListener("blur",  ()=>{ writeAtToModel(inp); });

      at.appendChild(lab);
      at.appendChild(inp);
      row2.appendChild(at);

      // Insert row2 directly after the row1 pill (or at end)
      if(pill && pill.parentNode === lane){
        pill.insertAdjacentElement("afterend", row2);
      } else {
        lane.appendChild(row2);
      }
    });
  }

  function mountRow(tr){
    const home = tr.querySelector(".sg-home-frame[data-sg-home]");
    if(!home) return;

    // Ensure stable uid for model storage
    ensureRowUid(tr);

    // Keep home as the non-interactive container; lanes inside are interactive.
    home.style.pointerEvents = "none";

    let strip = home.querySelector(".sg-lanes-strip");
    if(!strip){
      strip = document.createElement("div");
      strip.className = "sg-lanes-strip";
      home.appendChild(strip);
    }
    strip.style.pointerEvents = "auto";

    // v3.23: Non-destructive SG refresh.
    // Harvest current DOM values into the model (best-effort), then UPDATE existing lane DOM.
    // IMPORTANT: we do NOT clear/rebuild the lane strip; lanes are created once per row.
    // If this row was just allocated a fresh uid (often because it was cloned),
    // it may be carrying cloned lane DOM values from another row. Never snapshot those.
    // Instead, wipe any cloned lane nodes and let the model initialise defaults for this row.
    const isFresh = (tr.dataset.sgFresh === "1");
    if(isFresh){
      try{ strip.innerHTML = ""; }catch(_){}
      try{ delete tr.dataset.sgFresh; }catch(_){}
    }else{
      snapshotRowFromDom(tr);
    }
LANE_IDS.forEach(id => {
      let lane = strip.querySelector('.sg-inline-lane[data-lane-id="' + id + '"]');
      if(!lane){
        lane = buildLanePill(id);
      }
      hydrateLaneFromModel(tr, lane, id);
      // Ensure stable ordering by appending in LANE_IDS order (moves existing nodes if needed)
      strip.appendChild(lane);
    });

    applyRowTypeParity(tr);
    applyAddedTimeDeck(tr);
  }

  function mountAll(){
    const rows = document.querySelectorAll("#schedule-body tr:not(.row-template)");
    rows.forEach(tr => mountRow(tr));
    requestDockWidth();
  }


  // v5.2 — Control-panel SG stack meta (speeds + assignment)
  function getCpSgMeta_(){
    try{
      const am = (window.tdScheduleGetAdminMeta_ ? window.tdScheduleGetAdminMeta_() : { ok:false });
      if(am && am.ok){
        const sgCount = Math.max(1, Math.min(4, Number(am.sgCount||1)||1));
        const enabled = {1:true,2:(sgCount>=2),3:(sgCount>=3),4:(sgCount>=4)};

        return { speeds: am.speeds || {}, enabled };
      }
    }catch(_){ }
    return null;
  }

  function refreshCpSgStackMeta_(){
    const meta = getCpSgMeta_();
    const stack = document.querySelector('.card-toggle-stack');
    if(!stack) return;

    // Update speed labels
    stack.querySelectorAll('.sg-max[data-sg]').forEach(sp=>{
      const sg = parseInt(sp.getAttribute('data-sg')||'',10);
      if(!sg) return;
      const v = meta && meta.speeds ? meta.speeds[sg] : null;
      if(v !== null && v !== undefined && v !== '') sp.textContent = String(v);
    });

    // Assignment: hide tick box for unassigned SG (leave line as a cue)
    [2,3,4].forEach(sg=>{
      const label = stack.querySelector('.card-toggle[data-sg="'+sg+'"]');
      const cb = label ? label.querySelector('input.toggle-card[data-card="'+sg+'"]') : null;
      if(!label || !cb) return;

      const assigned = !!(meta && meta.enabled && meta.enabled[sg]);
      label.classList.toggle('sg-unassigned', !assigned);
      if(!assigned){
        cb.checked = false;
        // apply hide classes immediately (mirrors initToggles apply())
        try{
          document.body.classList.add('hide-sg-' + sg);
          document.body.classList.add('hide-card-' + sg);
        }catch(_){ }
      }
    });
  }

  // Expose for Admin stub to call after changes
  window.refreshCpSgStackMeta_ = refreshCpSgStackMeta_;
  function initToggles(){
    const toggles = document.querySelectorAll("input.toggle-card[data-card]");
    // SG toggle state:
    // - We keep a session-only mask so checkbox choices survive rebuilds (e.g. Add Row).
    // - On first boot: SG2-4 default OFF. (SG1 has no checkbox in this UI block.)
    const firstBoot = !window.SG_TOGGLE_DEFAULTS_APPLIED;
    window.SG_TOGGLE_STATE = window.SG_TOGGLE_STATE || {};

    toggles.forEach(cb => {
      const n = String(cb.getAttribute("data-card") || "").trim();
      if(!n) return;

      const hasState = Object.prototype.hasOwnProperty.call(window.SG_TOGGLE_STATE, n);

      if(firstBoot){
        // Default OFF unless an existing state is already present.
        if(!hasState) window.SG_TOGGLE_STATE[n] = false;
        cb.checked = !!window.SG_TOGGLE_STATE[n];
      }else{
        // Rebuild path: re-apply saved state (or seed from DOM if this is the first time we see it).
        if(hasState){
          cb.checked = !!window.SG_TOGGLE_STATE[n];
        }else{
          window.SG_TOGGLE_STATE[n] = !!cb.checked;
        }
      }

      const apply = () => {
        // Persist choice for future rebuilds.
        window.SG_TOGGLE_STATE[n] = !!cb.checked;

        const off = !cb.checked;
        document.body.classList.toggle("hide-sg-" + n, off);
        document.body.classList.toggle("hide-card-" + n, off);
        requestDockWidth();
      };

      // Bind once.
      if(cb.dataset.bound !== "1"){
        cb.addEventListener("change", apply);
        cb.dataset.bound = "1";
      }
      apply();
    });

    try{ updateCpSgMeta(); }catch(_){}

    try{ refreshCpSgStackMeta_(); }catch(_){}

    window.SG_TOGGLE_DEFAULTS_APPLIED = true;
  }

  // UI v5.2 — keep SG stack speeds + assignment state in sync with Admin meta/stub.
  function updateCpSgMeta(){
    // Robust default: until Admin allocation is known, treat only SG1 as assigned.
    let sgCount = 1;
    let speeds = {};
    try{
      const am = (window.tdScheduleGetAdminMeta_ ? window.tdScheduleGetAdminMeta_() : { ok:false });
      speeds = (am && am.ok && am.speeds) ? am.speeds : {};
      const n = Number(am && am.ok ? am.sgCount : 1);
      if(Number.isFinite(n)) sgCount = Math.max(1, Math.min(4, n));
    }catch(_e){
      sgCount = 1;
      speeds = {};
    }
    const enabled = {1:true,2:(sgCount>=2),3:(sgCount>=3),4:(sgCount>=4)};

    // v6.65: if Admin increases SG allocation while Schedule is open, auto-open the newly-added SG card(s)
    const stack = document.getElementById('cpSgStack') || document.querySelector('.card-toggle-stack');
    // so the lane DOM exists and the existing sync/export paths can persist them.
    const prevSgCount = stack ? Math.max(1, Math.min(4, Number(stack.dataset.prevSgCount||1)||1)) : sgCount;

    // Update speed numbers in the SG stack if present.
    try{
      document.querySelectorAll('.card-toggle-stack .sg-max[data-sg]').forEach(sp=>{
        const sg = Number(sp.getAttribute('data-sg')||'0');
        if(!sg) return;
        const v = (speeds && (speeds[String(sg)]!=null ? speeds[String(sg)] : speeds[sg]));
        if(v != null && v !== '') sp.textContent = String(v);
      });
    }catch(_e){}

    // Mark unassigned SG3/4 (and SG2 if sgCount=1) + force OFF toggles.
    [2,3,4].forEach(sg=>{
      const lab = document.querySelector('.card-toggle-stack .card-toggle[data-sg="'+sg+'"]');
      if(!lab) return;
      const cb = lab.querySelector('input.toggle-card');
      const assigned = !!enabled[sg];
      lab.classList.toggle('sg-unassigned', !assigned);
      if(cb){
        if(!assigned){
          cb.checked = false;
          cb.setAttribute('aria-disabled','true');
        }else{
          cb.removeAttribute('aria-disabled');
          // v6.69: if this SG has just become assigned, do a short visual peek only (no checkbox forcing)
          if(sg > prevSgCount){
            try{
              const cls = 'sg-peek-' + sg;
              document.body.classList.add(cls);
              setTimeout(()=>{ try{ document.body.classList.remove(cls); }catch(_){ } }, 2000);
            }catch(_e){}
          }
}
      }
    });

    // Dock width may change when SG visibility is forced.
    try{ requestDockWidth(); }catch(_){ }

    // If Timeline overlay is open, re-apply enabled lanes to the widget (true reflow happens inside widget).
    try{ applyTimelineEnabledFromAdmin_(); }catch(_){ }

    // v6.65: remember last seen sgCount so we can detect newly-added groups next time.
    try{ if(stack) stack.dataset.prevSgCount = String(sgCount); }catch(_e){}
  }

  // v6.69: provide a stable public wrapper name for legacy hooks
  function cpRefreshSgStackMeta(){
    return refreshCpSgStackMeta_();
  }

  // Expose so callers (and legacy hooks) can trigger a refresh.
  window.cpRefreshSgStackMeta = cpRefreshSgStackMeta;


  function updateDockWidth(){
    // Measure current visible lanes strip width and use it as the dock width.
    const strip = document.querySelector(".sg-home-frame[data-sg-home] .sg-lanes-strip");
    if(!strip){
      document.documentElement.style.setProperty("--sg-dock-w", "0px");
      return;
    }
    const r = strip.getBoundingClientRect();
    const w = Math.max(0, Math.ceil(r.width));
    document.documentElement.style.setProperty("--sg-dock-w", w + "px");
  }

  let _dockRaf = 0;
  function requestDockWidth(){
    if(_dockRaf) cancelAnimationFrame(_dockRaf);
    _dockRaf = requestAnimationFrame(() => {
      _dockRaf = 0;
      updateDockWidth();
    });
  }


  // Expose adapter hook used by the table when rows are added.
  window.sgAdapterRefresh = function(){
    initToggles();
    cpRefreshSgStackMeta();
    mountAll();
    requestDockWidth();
    queueAllLaneRecalc();
  };

  document.addEventListener("DOMContentLoaded", () => {
    scheduleSgRefresh();
    try{ refreshCpSgStackMeta_(); }catch(_){}
    try{ if(window.refreshCpSgMeta) window.refreshCpSgMeta(); }catch(_){}
    try{ window.cpRefreshSgStackMeta && window.cpRefreshSgStackMeta(); }catch(_){}


    // v3.60: SG speed inputs may be cloned during hydrate/import.
    // Use delegation to (re)wire any sg-speed-input that doesn't have its listeners attached.
    const _tbody = document.getElementById("schedule-body");
    if(_tbody){
      // Mark existing SG speed inputs as already wired (fresh-load path uses per-input listeners).
      _tbody.querySelectorAll("input.sg-speed-input").forEach(inp => { inp.__sgSpeedWired = true; });

      function wireSgSpeedInput(inp){
        if(!inp || inp.__sgSpeedWired === true) return;
        inp.__sgSpeedWired = true;

        // Focus-select
        inp.addEventListener("focus", () => { setTimeout(() => { try { inp.select(); } catch(e){} }, 0); });

        // Wheel adjust (SPEED_MIN–sgGetSpeedMax)
        inp.addEventListener("wheel", (ev) => {
          if(document.activeElement !== inp) return;
          ev.preventDefault();
          const cur = parseInt(String(inp.value||"0").trim(), 10);
          const base = Number.isFinite(cur) ? cur : 0;
          const delta = (ev.deltaY < 0) ? 1 : -1;
          let v = base + delta;
          const mx = sgGetSpeedMax(inp);
          v = Math.max(SPEED_MIN, Math.min(mx, v));
          inp.value = String(v);
          inp.dispatchEvent(new Event("input", {bubbles:true}));
        }, {passive:false});

        // Pristine clearing + clamp on blur
        let _userInteracted = false;
        inp.addEventListener("input", () => { _userInteracted = true; writeSpeedToModelFromInput(inp); });
        inp.addEventListener("blur", () => {
          if(!_userInteracted) return;
          const raw = String(inp.value || "").trim();
          const num0 = parseInt(raw, 10);
          const mx0 = sgGetSpeedMax(inp);
          const inRange0 = Number.isFinite(num0) && num0 >= SPEED_MIN && num0 <= mx0;

          if(inRange0) inp.classList.remove("is-pristine");
          else inp.classList.add("is-pristine");

          let v = num0;
          if(!Number.isFinite(v)) v = 0;
          const mx = sgGetSpeedMax(inp);
          v = Math.max(SPEED_MIN, Math.min(mx, v));
          inp.value = String(v);
          writeSpeedToModelFromInput(inp);
        });
      }


      // v6.33 — SG speed click/focus: single rule (no caret vs select duelling)
      // Use capturing pointerdown + preventDefault to suppress caret placement, then force focus+select.
      document.addEventListener("pointerdown", (e) => {
        const el = e.target;
        if(!(el instanceof Element)) return;
        const inp = el.closest('input.sg-speed-input');
        if(!inp) return;

        e.preventDefault();
        try { inp.focus({ preventScroll: true }); } catch(_) { inp.focus(); }
        requestAnimationFrame(() => { try { inp.select(); } catch(_){} });
      }, true);

      _tbody.addEventListener("focusin", (ev) => {
        const t = ev.target;
        if(!(t instanceof HTMLInputElement)) return;
        if(!t.classList.contains("sg-speed-input")) return;
        // Only rewire cloned/unwired inputs; fresh-load inputs already have listeners.
        if(t.__sgSpeedWired === true) return;
        wireSgSpeedInput(t);
      });
    }
window.addEventListener("resize", requestDockWidth);
    // Also resync lane time when TIME input changes (rare; but covers load/JSON later)
    document.addEventListener("input", (ev) => {
      const t = ev.target;
      if(!(t instanceof HTMLElement)) return;
      if(t.matches("td.col-time input[type='text'], td.col-time input[type='checkbox']")){
        const tr = t.closest("tr");
        if(tr) {
          applyRowTypeParity(tr);
        }
      }
    });
  });
})();

    // v3.09 TURN header print toggle (hidden tick behaviour)

</script>

<script>

(function(){
  function parseDist_(s){
    const n = Number(String(s||'').trim().replace(',', '.'));
    return Number.isFinite(n) ? n : NaN;
  }
  window.validateMonotonicDist_ = function(inp){
    try{
      if(!inp) return;
      const tr = inp.closest('tr');
      const tbody = document.querySelector('tbody');
      if(!tr || !tbody) return;
      const rows = Array.from(tbody.querySelectorAll('tr:not(.row-template)'));
      const i = rows.indexOf(tr);
      if(i <= 0) { inp.classList.remove('dist-error'); return; }
      // START STC: allow DIST to go backwards (e.g., user may set 0.00) — no red warning
      if((tr.classList && tr.classList.contains('start-stc')) || (tr.dataset && tr.dataset.rowType === 'start-stc')){ inp.classList.remove('dist-error'); return; }
      const prevInp = rows[i-1].querySelector('td.col-dist input[type="text"]');
      if(!prevInp){ inp.classList.remove('dist-error'); return; }
      const prevVal = parseDist_(prevInp.value);
      const curVal  = parseDist_(inp.value);
      if(Number.isFinite(prevVal) && Number.isFinite(curVal) && (curVal + 1e-9) < prevVal){
        inp.classList.add('dist-error');
      }else{
        inp.classList.remove('dist-error');
      }
    }catch(e){}
  };
  window.validateAllMonotonicDists_ = function(){
    try{
      const tbody = document.querySelector('tbody');
      if(!tbody) return;
      const rows = Array.from(tbody.querySelectorAll('tr:not(.row-template)'));
      for(let i=1;i<rows.length;i++){
        const inp = rows[i].querySelector('td.col-dist input[type="text"]');
        if(inp) window.validateMonotonicDist_(inp);
      }
    }catch(e){}
  };
})();
</script>

<div id="timelineOverlayMount" aria-hidden="true">
  <div class="timeline-mount-card" role="dialog" aria-modal="true" aria-label="Timeline">
    <div class="timeline-mount-head">
      <div>
        <div class="timeline-mount-title">Timeline - Slower groups starting first</div>
</div>
      <button id="timelineMountClose" type="button">Close</button>
    </div>
    <div class="timeline-mount-body">
      <div id="timelineWidgetHost" style="width:100%; height:100%;"></div>
      </div>
    </div>
  </div>
</div>


<script src="./timeline_widget.js"></script>

<script id="js-timeline-mount-v4-05">
(function(){
  'use strict';

  const overlay = document.getElementById('timelineDockMount');
  const closeBtn = document.getElementById('timelineDockClose');
  const refreshBtn = document.getElementById('timelineDockRefresh');
  const compactBtn = document.getElementById('timelineDockCompact');
  try{ if (compactBtn) compactBtn.textContent = overlay.classList.contains('tlw-compact85') ? 'Compact' : 'Normal'; }catch(_e){}

    const floatBtn = document.getElementById('timelineDockFloat');

  // v6.60 — Page 85% zoom toggle (screen only)
  const pageZoomBtn = document.getElementById('pageZoomBtn');
  const PAGE_ZOOM_KEY = () => 'TD_PAGE_ZOOM85_' + String(getRallyId ? getRallyId() : 'r000');

  function _syncPageZoomBtn_(){
    if(!pageZoomBtn) return;
    const on = document.body.classList.contains('page-zoom85');
    pageZoomBtn.setAttribute('aria-pressed', on ? 'true' : 'false');
    pageZoomBtn.textContent = on ? 'Compact' : 'Normal';
    pageZoomBtn.title = on ? 'Compact view (screen only)' : 'Normal view (screen only)';
  }

  function _applyPageZoom_(on){
    if(on) document.body.classList.add('page-zoom85');
    else document.body.classList.remove('page-zoom85');
    _syncPageZoomBtn_();
    try{ localStorage.setItem(PAGE_ZOOM_KEY(), on ? '1' : '0'); }catch(_){}
  }

  function _restorePageZoom_(){
    try{
      const v = localStorage.getItem(PAGE_ZOOM_KEY());
      if(v === '1') document.body.classList.add('page-zoom85');
      else document.body.classList.remove('page-zoom85');
    }catch(_){}
    _syncPageZoomBtn_();
  }

  if(pageZoomBtn){
    pageZoomBtn.addEventListener('click', () => {
      const on = !document.body.classList.contains('page-zoom85');
      _applyPageZoom_(on);
    });
  }
  // v6.62 — restore Page 85% preference on load
  try{ _restorePageZoom_(); }catch(_){ }

// v6.47 — "stale" wink: when schedule changes while dock is open, nudge user to hit Refresh.
  let tlDockStale = false;
  let tlLastWinkAt = 0;

  
  
  // v6.60 — Float/Dock toggle label + float (draggable) mode
  const TL_FLOAT_KEY = () => 'TD_TL_FLOAT_POS_' + String(getRallyId ? getRallyId() : 'r000');
  const TL_FLOAT_W_KEY = () => 'TD_TL_FLOAT_W_' + String(getRallyId ? getRallyId() : 'r000');
  const TL_MODE_KEY  = () => 'TD_TL_MODE_' + String(getRallyId ? getRallyId() : 'r000');

  
  function _syncTlModeButton_(){
    if (!floatBtn) return;
    const isFloat = document.body.classList.contains('timeline-float-open');
    floatBtn.textContent = isFloat ? 'Dock' : 'Float';
    floatBtn.title = isFloat ? 'Dock Timeline (return to split view)' : 'Float Timeline (draggable)';
  }

function _isTlOpen_(){
    return document.body.classList.contains('timeline-dock-open') || document.body.classList.contains('timeline-float-open');
  }

  function _applyTlMode_(mode){
    const m = (mode === 'float') ? 'float' : 'dock';
    if (m === 'float'){
      document.body.classList.remove('timeline-dock-open');
      document.body.classList.add('timeline-float-open');
      if (floatBtn) floatBtn.setAttribute('aria-pressed','true');
      // v6.60: float width is independent of dock width; apply saved float width if available
      _restoreTlFloatW_();
    } else {
      document.body.classList.remove('timeline-float-open');
      document.body.classList.add('timeline-dock-open');
      if (floatBtn) floatBtn.setAttribute('aria-pressed','false');
      // v6.60: clear inline width so dock mode obeys --tl-dock-w
      overlay.style.width = '';
    }
    _syncTlModeButton_();
    try{ localStorage.setItem(TL_MODE_KEY(), m); }catch(_){}
  }

  function _restoreTlFloatPos_(){
    try{
      const raw = localStorage.getItem(TL_FLOAT_KEY());
      if(!raw) return;
      const pos = JSON.parse(raw);
      if(!pos) return;
      const x = Number(pos.x); const y = Number(pos.y);
      if(!isFinite(x) || !isFinite(y)) return;
      overlay.style.left = x + 'px';
      overlay.style.top  = y + 'px';
    }catch(_){}
  }
  function _clampFloatW_(w){
    const vw = window.innerWidth || 0;
    const pad = 16;
    const maxW = Math.min(1200, Math.max(360, vw - pad));
    const n = Number(w);
    if(!isFinite(n)) return null;
    return Math.max(360, Math.min(maxW, n));
  }

  function _restoreTlFloatW_(){
    // If we have a saved float width, apply it as an inline width (float mode only).
    try{
      const raw = localStorage.getItem(TL_FLOAT_W_KEY());
      if(!raw) return;
      const w = _clampFloatW_(raw);
      if(!w) return;
      overlay.style.width = Math.round(w) + 'px';
    }catch(_){}
  }



  function _clampFloatPos_(x,y){
    const pad = 8;
    const r = overlay.getBoundingClientRect();
    const vw = window.innerWidth || 0;
    const vh = window.innerHeight || 0;
    const maxX = Math.max(pad, vw - r.width - pad);
    const maxY = Math.max(pad, vh - r.height - pad);
    return { x: Math.max(pad, Math.min(maxX, x)), y: Math.max(pad, Math.min(maxY, y)) };
  }
// v6.55 — Compact 85% real density toggle (UI only)
  function toggleCompact_(){
    try{
      const on = overlay.classList.toggle('tlw-compact85');
      if (compactBtn) compactBtn.setAttribute('aria-pressed', on ? 'true' : 'false');
      if (compactBtn) compactBtn.textContent = on ? 'Compact' : 'Normal';

      // v6.55 — Dock height follows Compact (reduce reserved vertical space)
      const dockEl = overlay.closest('.timeline-dock');
      if (dockEl){
        dockEl.style.height = on ? '548px' : '';
      }
    }catch(_){}
  }

function setRefreshStale_(isStale){
    tlDockStale = !!isStale;
    if (!refreshBtn) return;
    try{
      if (tlDockStale) refreshBtn.dataset.stale = "1";
      else delete refreshBtn.dataset.stale;
    }catch(_){}
  }

  function winkRefresh_(){
    if (!refreshBtn) return;
    const now = Date.now();
    if (now - tlLastWinkAt < 700) return; // debounce
    tlLastWinkAt = now;
    try{
      refreshBtn.classList.remove('tlw-wink');
      // force reflow so repeated winks work
      void refreshBtn.offsetWidth;
      refreshBtn.classList.add('tlw-wink');
      window.setTimeout(()=>{ try{ refreshBtn.classList.remove('tlw-wink'); }catch(_){ } }, 450);
    }catch(_){ }
  }

  // v6.47 — Auto-refresh debounce (only while dock is open)
  const TL_AUTO_REFRESH_MS = 1300;
  let tlAutoTimer = 0;
  let tlIgnoreUntil = 0;

  function scheduleAutoRefresh_(){
    if (!_isTlOpen_()) return;
    if (tlAutoTimer) { try{ clearTimeout(tlAutoTimer); }catch(_){ } }
    tlAutoTimer = window.setTimeout(()=>{
      tlAutoTimer = 0;
      if (!_isTlOpen_()) return;
      // Remount once after edits go quiet
      try{
        tlIgnoreUntil = Date.now() + 800;
        remountTimelineDock_();
      }catch(_){ }
    }, TL_AUTO_REFRESH_MS);
  }

  function onScheduleChanged_(){
    // Only react while dock is open
    if (!_isTlOpen_()) return;
    // Guard against any echo events during/after remount
    if (Date.now() < tlIgnoreUntil) return;

    setRefreshStale_(true);
    winkRefresh_();
    scheduleAutoRefresh_();
  }

  // Listen for the same change event emitted when Schedule syncs TD_RALLIES.
  try{ window.addEventListener('TD_RALLIES_CHANGED', onScheduleChanged_, { passive:true }); }catch(_){}

  function getRallyId(){
    try {
      const qs = new URLSearchParams(location.search);
      const fromUrl = (qs.get('rallyId') || '').trim();
      if (fromUrl) return fromUrl;
    } catch(_){ }
    try{
      const td = (window.tdScheduleRead_ ? window.tdScheduleRead_() : null);
      const rid = (window.tdScheduleGetActiveRid_ ? window.tdScheduleGetActiveRid_() : null);
      if(rid) return rid;
    }catch(_){ }
    try {
      const last = (localStorage.getItem('rally:last') || '').trim();
      if (last) return last;
    } catch(_){ }
    return '';
  }

  // v5.72 - Read Admin day start time from TD_RALLIES (admin.days[dayKey].start) and trace it.
  function readAdminDayStartFromStore_(){
    // v6.32 — TL start-time: robust RID fallback (supports td.global.activeRallyId and single-rally stores)
    try{
      const raw = localStorage.getItem('TD_RALLIES');
      if(!raw) return '';
      const td = JSON.parse(raw);

      const dayKey = (window.getScheduleDayKey_?window.getScheduleDayKey_():'1');

      // Resolve rally id as robustly as possible without changing any storage.
      let rid = (typeof getRallyId === 'function') ? getRallyId() : '';
      const hasRallies = !!(td && td.rallies && typeof td.rallies === 'object');

      // Prefer td.global.activeRallyId / lastRallyId if host RID is missing.
      try{
        if(!rid && td && td.global){
          rid = td.global.activeRallyId || td.global.lastRallyId || rid;
        }
      }catch(_){}

      // If rid is still missing/invalid, fall back to single-rally store or other known keys.
      if(hasRallies && (!rid || !td.rallies[rid])){
        const keys = Object.keys(td.rallies);
        if(keys.length === 1){
          rid = keys[0];
        }else{
          const fb = (td && (td.activeRallyId || (td.meta && td.meta.activeRallyId) || (td.global && (td.global.activeRallyId || td.global.lastRallyId)))) || '';
          if(fb && td.rallies[fb]) rid = fb;
        }
      }

      const rally = (hasRallies && rid) ? td.rallies[rid] : null;
      const ad = rally && rally.admin && rally.admin.days ? rally.admin.days[dayKey] : null;
      const start = ad && typeof ad.start === 'string' ? ad.start : '';
      try{ false && false && console.log('[TL_START]', { rid, dayKey, start }); }catch(_){ }
      return start;
    }catch(_e){ return ''; }
  }


  // v5.5 — Timeline delay UI hook (no widget source edits):
  // 1) Remove SG4 Delay(min) input.
  // 2) Cascade delay edits upward (SG3 → SG2+SG1; SG2 → SG1).
  
  // v6.03 — TLW: reapply SG entrant counts on every open (derived from TD_RALLIES admin.entries[].speedGroup)
  function tlwApplyGroupCountsFromTdRallies_(host, labelMapOpt){
    try{
      if(!host) return;
      const raw = localStorage.getItem('TD_RALLIES');
      const td = raw ? JSON.parse(raw) : null;
      if(!td) return;

      const rid = (() => {
        const g = td.global || {};
        return (
          td.currentRid ||
          td.activeRid ||
          td.currentRallyId ||
          g.activeRallyId ||
          g.activeRid ||
          Object.keys(td.rallies || {})[0] ||
          null
        );
      })();

      const entries = (rid && td.rallies && td.rallies[rid] && td.rallies[rid].admin && Array.isArray(td.rallies[rid].admin.entries))
        ? td.rallies[rid].admin.entries : null;
      if(!entries) return;

      const counts = {1:0,2:0,3:0,4:0};
      for(const e of entries){
        const sgRaw = (e && (e.speedGroup ?? e.sgIdx ?? e.sg ?? e.speed_group));
        const sg = Number(sgRaw);
        if(sg>=1 && sg<=4) counts[sg] = (counts[sg]||0) + 1;
      }

      const labelMap = labelMapOpt || (() => {
        const lm = {};
        const rows = host.querySelectorAll('tr');
        rows.forEach(tr=>{
          const first = tr.querySelector('th,td');
          if(!first) return;
          const label = (first.textContent || '').replace(/\s+/g,' ').trim();
          const m = /\bSG\s*([1-4])\b/i.exec(label) || /\bSG([1-4])\b/i.exec(label);
          if(!m) return;
          const sg = Number(m[1]);
          if(sg>=1 && sg<=4) lm[sg] = first;
        });
        return lm;
      })();

      for(let i=1;i<=4;i++){
        const cell = labelMap[i];
        if(!cell) continue;
        cell.textContent = 'SG' + i + ' (' + (counts[i]||0) + ')';
      }
    }catch(_){ }
  }

function hookTimelineDelayUi_(host){
    if(!host) return;

    const MAX = 90; // ~1.5s worst-case at 60fps
    let tries = 0;


    // Re-apply delay UI rules when TLW re-renders rows (e.g., enabled groups change after mount).
    if(!host.__tlwDelayObserver){
      let t;
      const kick = ()=>{
        if(t) cancelAnimationFrame(t);
        t = requestAnimationFrame(()=>{ try{ findAndBind(); }catch(_e){} });
      };
      host.__tlwDelayObserver = new MutationObserver(()=>{ kick(); });
      try{ host.__tlwDelayObserver.observe(host, { childList:true, subtree:true }); }catch(_){}
    }

    const findAndBind = ()=>{
      tries++;

      // Find rows by first cell label ("SG1", "SG2", etc.).
      const map = {};
      const labelMap = {};
      const rows = host.querySelectorAll('tr');
      rows.forEach(tr=>{
        const first = tr.querySelector('th,td');
        if(!first) return;
        const label = (first.textContent || '').replace(/\s+/g,' ').trim();
        const m = /\bSG\s*([1-4])\b/i.exec(label) || /\bSG([1-4])\b/i.exec(label);
        if(!m) return;
        const sg = Number(m[1]);
        labelMap[sg] = first;
        const inp = tr.querySelector('input[type="number"]');
        if(inp) map[sg] = inp;
      });

      // We consider the widget ready when we can see at least SG1+SG2.
      if(!map[1] || !map[2]){
        if(tries < MAX) requestAnimationFrame(findAndBind);
        return;
      }


      // v6.80 — Determine whether SG4 is enabled *before* we remove the SG4 delay input.
      const hasSg4 = !!labelMap[4];
      host.__tlwDelayHasSg4 = hasSg4;

      // v6.80 — SG4 delay input is never used. Remove/hide it unconditionally.
      if(map[4]){
        try{
          const cell4 = map[4].closest('td') || map[4].parentElement;
          if(cell4) cell4.innerHTML = '';
        }catch(_e){}
        delete map[4];
      }

      // Option 2 (cascade-only): if SG4 is not present/enabled, hide the SG3 delay input.
      // This avoids having two "top" delay inputs when only SG1–SG3 are available.
      if(!hasSg4 && map[3]){
        try{
          const cell3 = map[3].closest('td') || map[3].parentElement;
          if(cell3) cell3.innerHTML = '';
        }catch(_e){}
        delete map[3];
      }

      // v6.03 — SG entrant counts: reapply after widget is ready (and on every open).
      try{ tlwApplyGroupCountsFromTdRallies_(host, labelMap); }catch(_){ }

      // Mark that base delay hook plumbing is installed (but allow re-apply on rerenders).
      host.__tlwDelayHooked = true;

      // v5.25 — Persist timeline plan (delaysMin sg1-3 + carsEstimate) on user edits only
      if(!host.__tlwPlanPersist){
        host.__tlwPlanPersist = true;
        let tSave;
        const readPlan = ()=>{
          const plan = { delaysMin:{}, carsEstimate:{} };
          const tbl = host.querySelector('table');
          if(!tbl) return plan;
          const heads = Array.from(tbl.querySelectorAll('thead th, thead td')).map(el=>(el.textContent||'').trim().toLowerCase());
          const delayIdx = heads.findIndex(h=>h.includes('delay'));
          const carsIdx  = heads.findIndex(h=>h.includes('cars'));
          const rows = Array.from(tbl.querySelectorAll('tbody tr'));
          for(const tr2 of rows){
            const first = tr2.querySelector('th,td');
            if(!first) continue;
            const m = /sg\s*([1-4])/i.exec((first.textContent||''));
            if(!m) continue;
            const sg = m[1];
            const tds = Array.from(tr2.children);
            const num = (cell)=>{
              if(!cell) return null;
              const inp = cell.querySelector('input[type=number]');
              const v = inp ? inp.value : (cell.textContent||'');
              const n = Number(String(v||'').trim());
              return Number.isFinite(n) ? n : null;
            };
            if(carsIdx>=0){
              const n = num(tds[carsIdx]);
              if(n!=null) plan.carsEstimate['sg'+sg]=n;
            }
            if(delayIdx>=0 && sg!=='4'){
              const n = num(tds[delayIdx]);
              if(n!=null) plan.delaysMin['sg'+sg]=n;
            }
          }
          return plan;
        };
        const persist = ()=>{
          try{
            if(window.__TD_SCHEDULE_MUTE) return;
            if(typeof window.__TD_SCHEDULE_HYDRATING!== 'undefined' && window.__TD_SCHEDULE_HYDRATING>0) return;
            const raw = localStorage.getItem('TD_RALLIES');
            if(!raw) return;
            const td = JSON.parse(raw);
            const rid = getRallyId();
            const dayKey = (window.getScheduleDayKey_?window.getScheduleDayKey_():'1');
            td.rallies = td.rallies||{};
            const rally = td.rallies[rid];
            if(!rally || !rally.schedule || !rally.schedule.days || !rally.schedule.days[dayKey]) return;
            const d = rally.schedule.days[dayKey];
            d.timeline = d.timeline||{};
            const plan = readPlan();
            d.timeline.delaysMin = plan.delaysMin;
            d.timeline.carsEstimate = plan.carsEstimate;
            localStorage.setItem('TD_RALLIES', JSON.stringify(td));
          }catch(_e){}
        };
        host.addEventListener('input', (ev)=>{
          const t = ev.target;
          if(!t || t.tagName!=='INPUT' || t.type!=='number') return;
          clearTimeout(tSave);
          tSave=setTimeout(persist, 400);
        }, true);
      }

      const setVal = (inp, v)=>{
        if(!inp) return;
        const s = (v === null || v === undefined) ? '' : String(v);
        if(inp.value === s) return;
        inp.value = s;
        // Bubble both input + change so the widget's own listeners run.
        try{ inp.dispatchEvent(new Event('input', { bubbles:true })); }catch(_e){}
        try{ inp.dispatchEvent(new Event('change', { bubbles:true })); }catch(_e){}
      };


      // Cascade-only delay edits (delegated, bound once; resilient to rerenders).
      if(!host.__tlwDelayCascadeBound){
        host.__tlwDelayCascadeBound = true;
        host.addEventListener('input', (ev)=>{
          try{
            if(host.__tlwDelayCascadeInProgress) return;
            const t = ev.target;
            if(!t || t.tagName!=='INPUT' || t.type!=='number') return;
            const tr = t.closest('tr');
            if(!tr) return;
            const first = tr.querySelector('th,td');
            if(!first) return;
            const label = (first.textContent||'').trim();
            const mm = /sg\s*([1-4])/i.exec(label);
            if(!mm) return;
            const sg = Number(mm[1]);

            // Determine delay column index (so we don't react to Cars inputs).
            const tbl = t.closest('table');
            if(!tbl) return;
            const heads = Array.from(tbl.querySelectorAll('thead th, thead td')).map(el=>(el.textContent||'').trim().toLowerCase());
            const delayIdx = heads.findIndex(h=>h.includes('delay'));
            if(delayIdx < 0) return;
            const td = t.closest('td,th');
            if(!td) return;
            // Column index within the row (include leading label cell).
            const cells = Array.from(tr.children);
            const colIdx = cells.indexOf(td);
            if(colIdx !== delayIdx) return;

            // Rebuild current map (inputs may have rerendered).
            const cur = {};
            Array.from(tbl.querySelectorAll('tbody tr')).forEach(r=>{
              const f = r.querySelector('th,td'); if(!f) return;
              const m2 = /sg\s*([1-4])/i.exec((f.textContent||'')); if(!m2) return;
              const n = Number(m2[1]);
              const c2 = Array.from(r.children)[delayIdx];
              const i2 = c2 ? c2.querySelector('input[type="number"]') : null;
              if(i2) cur[n]=i2;
            });

            // Option 2 extra rule: if no SG4, ignore SG3 edits (SG3 input should be hidden anyway).
            if(!host.__tlwDelayHasSg4 && sg===3) return;

            const v = t.value;
            host.__tlwDelayCascadeInProgress = true;
            try{
              if(sg===4){
                setVal(cur[3], v);
                setVal(cur[2], v);
                setVal(cur[1], v);
              }else if(sg===3){
                setVal(cur[2], v);
                setVal(cur[1], v);
              }else if(sg===2){
                setVal(cur[1], v);
              }
            }finally{
              host.__tlwDelayCascadeInProgress = false;
            }
          }catch(_e){}
        }, true);
      }
    };

    requestAnimationFrame(findAndBind);
  }


  // v5.6 — Timeline Focus selector label hook (no widget source edits):
  // Remove the leading row index + separator so labels start with DIST.
  function hookTimelineFocusLabelsUi_(host){
    if(!host || host.__tlwFocusHooked) return;

    const stripLeadingIndex = (s)=>{
      const t = String(s||'');
      // e.g. '2 - 8.5 - MARSHAL - ...' -> '8.5 - MARSHAL - ...'
      return t.replace(/^\s*\d+\s*-\s*/,'').trim();
    };

    const selectFixOnce = ()=>{
      const selects = host.querySelectorAll('select');
      selects.forEach(sel=>{
        const opts = sel && sel.options ? Array.from(sel.options) : [];
        if(opts.length < 2) return;

        // Heuristic: only selects whose options look like our Focus labels
        // (contain ' - ' separators and start with a numeric index).
        let looks = 0;
        for(const o of opts.slice(0, Math.min(6, opts.length))){
          const tx = (o.textContent||'').trim();
          if(/^\d+\s*-\s*\d/.test(tx) && tx.includes(' - ')) looks++;
        }
        if(looks == 0) return;

        opts.forEach(o=>{
          if(o.__tlwLabelAdjusted) return;
          const before = (o.textContent||'').trim();
          const after = stripLeadingIndex(before);
          if(after && after != before) o.textContent = after;
          o.__tlwLabelAdjusted = true;
        });
      });
    };

    host.__tlwFocusHooked = true;

    // Rows import now + keep rows imported if the widget rebuilds options
    selectFixOnce();
    const mo = new MutationObserver(()=>{ selectFixOnce(); });
    try{ mo.observe(host, {subtree:true, childList:true}); }catch(_){ }
  }

  // v6.71 — Suppress the widget's Focus/ETA info text block (UI-only).
  // We do NOT hide containers by broad textContent matching; instead we locate the smallest
  // leaf-like element that contains the known label text and remove just that node.
  function hookTimelineFocusInfoSuppress_(host){
    if(!host || host.__tlwFocusInfoSuppressed) return;

    const LABELS = [
      'ETAs at selected point',
      'Selected point',
      'ETAs at'
    ];

    const isLeafish = (el)=>{
      if(!el || el.nodeType !== 1) return false;
      // Avoid accidentally targeting large layout containers.
      if(el.querySelector && el.querySelector('canvas,svg,table,select,input,textarea,button')) return false;
      // Prefer elements with few/none element children.
      const kids = el.children ? el.children.length : 0;
      return kids === 0 || kids === 1;
    };

    const findAndRemove = ()=>{
      try{
        const all = host.querySelectorAll('*');
        let best = null;
        for(const el of all){
          const t = (el.textContent||'').trim();
          if(!t) continue;
          let hit = false;
          for(const lab of LABELS){
            if(t.includes(lab)){ hit = true; break; }
          }
          if(!hit) continue;

          // Pick the smallest leaf-like element to remove, not a parent wrapper.
          if(!isLeafish(el)) continue;

          // Prefer the shortest text node (most specific).
          if(!best || t.length < (best.textContent||'').trim().length){
            best = el;
          }
        }
        if(best){
          // Remove the whole block element.
          best.remove();
        }
      }catch(_){}
    };

    host.__tlwFocusInfoSuppressed = true;

    // Run now and on future widget updates.
    findAndRemove();
    const mo = new MutationObserver(()=>{ findAndRemove(); });
    try{ mo.observe(host, {subtree:true, childList:true, characterData:true}); }catch(_){ }
  }



  // v5.71 — Hydrate Timeline plan (delays + cars) from TD_RALLIES.schedule.days[day].timeline on open.
  function hydrateTimelinePlanFromStore_(host){
    try{
      const raw = localStorage.getItem('TD_RALLIES');
      if(!raw) return;
      const td = JSON.parse(raw);
      const rid = getRallyId();
      const dayKey = (window.getScheduleDayKey_?window.getScheduleDayKey_():'1');
      const rally = td && td.rallies ? td.rallies[rid] : null;
      const d = rally && rally.schedule && rally.schedule.days ? rally.schedule.days[dayKey] : null;
      const plan = d && d.timeline ? d.timeline : null;
      if(!plan) return;

      const delaysMin = plan.delaysMin || {};
      const carsEstimate = plan.carsEstimate || {};

      // Trace (one line) so we can prove RID/day + payload.
      try{ false && false && console.log('[TL_HYDRATE]', { rid, dayKey, delaysMin, carsEstimate }); }catch(_){ }

      const MAX = 90; // ~1.5s
      let tries = 0;

      const applyOnce = ()=>{
        tries++;
        const tbl = host && host.querySelector ? host.querySelector('table') : null;
        const thead = tbl ? tbl.querySelector('thead') : null;
        const tbody = tbl ? tbl.querySelector('tbody') : null;
        if(!tbl || !thead || !tbody){
          if(tries < MAX) return requestAnimationFrame(applyOnce);
          return;
        }

        const heads = Array.from(thead.querySelectorAll('th,td')).map(el=>(el.textContent||'').trim().toLowerCase());
        const delayIdx = heads.findIndex(h=>h.includes('delay'));
        const carsIdx  = heads.findIndex(h=>h.includes('cars'));
        if(delayIdx < 0 && carsIdx < 0){
          if(tries < MAX) return requestAnimationFrame(applyOnce);
          return;
        }

        const setVal = (inp, v)=>{
          if(!inp) return;
          const s = (v === null || v === undefined) ? '' : String(v);
          if(inp.value === s) return;
          inp.value = s;
          try{ inp.dispatchEvent(new Event('input', { bubbles:true })); }catch(_e){}
          try{ inp.dispatchEvent(new Event('change', { bubbles:true })); }catch(_e){}
        };

        // Guard so our own hook's persist() does not write back.
        try{ window.__TD_SCHEDULE_HYDRATING = (window.__TD_SCHEDULE_HYDRATING||0) + 1; }catch(_){ }

        try{
          const rows = Array.from(tbody.querySelectorAll('tr'));
          for(const tr of rows){
            const first = tr.querySelector('th,td');
            if(!first) continue;
            const m = /sg\s*([1-4])/i.exec((first.textContent||''));
            if(!m) continue;
            const sg = m[1];
            const key = 'sg' + sg;
            const cells = Array.from(tr.children);

            if(carsIdx >= 0 && carsIdx < cells.length){
              const cell = cells[carsIdx];
              const inp = cell ? cell.querySelector('input[type=number]') : null;
              if(inp && carsEstimate && (key in carsEstimate)) setVal(inp, carsEstimate[key]);
            }

            if(delayIdx >= 0 && delayIdx < cells.length && sg !== '4'){
              const cell = cells[delayIdx];
              const inp = cell ? cell.querySelector('input[type=number]') : null;
              if(inp && delaysMin && (key in delaysMin)) setVal(inp, delaysMin[key]);
            }
          }
        }catch(_e){}
        finally{
          try{ window.__TD_SCHEDULE_HYDRATING = Math.max(0, (window.__TD_SCHEDULE_HYDRATING||1) - 1); }catch(_){ }
        }
      };

      requestAnimationFrame(applyOnce);
    }catch(_e){}
  }
  // v5.10: Drive widget lane reflow from Admin meta (SG1/SG2 always on).
  function applyTimelineEnabledFromAdmin_(host){
    try{
      if(!host) host = document.getElementById('timelineWidgetHost');
      const inst = host && host.__tlwInstance;
      if(!inst || typeof inst.setEnabledGroups !== 'function') return;
      const am = (window.tdScheduleGetAdminMeta_ ? window.tdScheduleGetAdminMeta_() : { ok:false });
      const sgCount = (am && am.ok) ? Math.max(1, Math.min(4, Number(am.sgCount||1)||1)) : 1;
      const sg3 = (sgCount >= 3);
      const sg4 = (sgCount >= 4);
      inst.setEnabledGroups({ SG3: sg3, SG4: sg4 });
    }catch(_){ }
  }

  
// v6.47 — Manual Timeline refresh (remount). This mirrors the mount-on-open path.
function remountTimelineDock_(){
  if (!overlay) return;

  try{ setRefreshStale_(false); }catch(_){ }
  const host = document.getElementById('timelineDockHost');
  if (!host) return;

  // Idempotent mount (unmount first just in case)
  try { if (window.Timeline && window.Timeline.unmount) window.Timeline.unmount(host); } catch(_){}
  try{ delete host.__tlwInstance; }catch(_){ }

  if (window.Timeline && window.Timeline.mount){
    const dayKey = (window.getScheduleDayKey_?window.getScheduleDayKey_():'1');
    const dayStart = readAdminDayStartFromStore_();
    const inst = window.Timeline.mount(host, { rallyId: getRallyId(), mode: 'embed', dayKey, dayStart, startTime: dayStart });
    try{ host.__tlwInstance = inst; }catch(_){ }
    try{ if(inst && typeof inst.setDayStart === 'function') inst.setDayStart(dayStart); }catch(_){ }
    try{ if(inst && typeof inst.setStartTime === 'function') inst.setStartTime(dayStart); }catch(_){ }
    try{ applyTimelineEnabledFromAdmin_(host); }catch(_){ }
    // Apply Timeline delay UI/logic hook after mount.
    hookTimelineDelayUi_(host);
    // Apply Focus selector label hook after mount.
    hookTimelineFocusLabelsUi_(host);
    // Suppress Focus/ETA info block text (UI-only)
    hookTimelineFocusInfoSuppress_(host);
    // Apply saved delays/cars into widget UI (post-mount).
    try{ hydrateTimelinePlanFromStore_(host); }catch(_){ }
    try{ tlwApplyGroupCountsFromTdRallies_(host); }catch(_){ }
    try{ requestAnimationFrame(()=>{ try{ tlwApplyGroupCountsFromTdRallies_(host); }catch(_){ } }); }catch(_){ }
  } else {
    host.innerHTML = '<div style="padding:12px; font-family:system-ui,-apple-system,Segoe UI,sans-serif; color:#b91c1c;">timeline_widget.js not found (Timeline.mount missing)</div>';
  }
}

function openOverlay(){
    if (!overlay) return;
    overlay.setAttribute('aria-hidden','false');

    // Restore last mode (dock/float)
    let mode = 'dock';
    try{ mode = localStorage.getItem(TL_MODE_KEY()) || 'dock'; }catch(_){}
    _applyTlMode_(mode);

    // Restore float position (if any)
    if (document.body.classList.contains('timeline-float-open')){
      _restoreTlFloatPos_();
    }

    try{ if (compactBtn) compactBtn.setAttribute('aria-pressed', overlay.classList.contains('tlw-compact85') ? 'true' : 'false'); }catch(_){ }
    // v5.23 — Timeline is read-only: do not force any TD_RALLIES sync on open.

    // Mount (or remount) widget into host
    remountTimelineDock_();
  }

  function closeOverlay(){
    if (!overlay) return;

    try{ setRefreshStale_(false); }catch(_){ }
    // Unmount widget
    const host = document.getElementById('timelineDockHost');
    if (host){
      try { if (window.Timeline && window.Timeline.unmount) window.Timeline.unmount(host); } catch(_){}
      try{ delete host.__tlwInstance; }catch(_){ }
    }

    overlay.setAttribute('aria-hidden','true');
    document.body.classList.remove('timeline-dock-open');
        document.body.classList.remove('timeline-float-open');
}

  // Close button
  if (closeBtn) closeBtn.addEventListener('click', closeOverlay);
  if (refreshBtn) refreshBtn.addEventListener('click', remountTimelineDock_);
  if (compactBtn) compactBtn.addEventListener('click', toggleCompact_);

    if (floatBtn) floatBtn.addEventListener('click', ()=>{
    if (!overlay) return;
    const wantFloat = !document.body.classList.contains('timeline-float-open');
    _applyTlMode_(wantFloat ? 'float' : 'dock');
    if (wantFloat) _restoreTlFloatPos_();
  });
// Delegated open (survives table rebuilds)
  document.addEventListener('click', (ev)=>{
    const btn = ev.target && ev.target.closest ? ev.target.closest('#timelineBtn,[data-cp-action="timeline"]') : null;
    if (!btn) return;
    ev.preventDefault();
openOverlay();
  });
  // v6.56 — Draggable float within viewport (drag header)
  (function(){
    const head = overlay ? overlay.querySelector('.timeline-dock-head') : null;
    if (!head) return;

    let dragging = false;
    let offX = 0;
    let offY = 0;

    const onMove = (ev)=>{
      if (!dragging) return;
      const next = _clampFloatPos_(ev.clientX - offX, ev.clientY - offY);
      overlay.style.left = next.x + 'px';
      overlay.style.top  = next.y + 'px';
      ev.preventDefault();
    };
    const onUp = ()=>{
      if (!dragging) return;
      dragging = false;
      document.removeEventListener('mousemove', onMove, true);
      document.removeEventListener('mouseup', onUp, true);
      document.body.style.userSelect = '';
      try{
        const r = overlay.getBoundingClientRect();
        localStorage.setItem(TL_FLOAT_KEY(), JSON.stringify({ x: Math.round(r.left), y: Math.round(r.top) }));
      }catch(_){}
    };

    head.addEventListener('mousedown', (ev)=>{
      if (!document.body.classList.contains('timeline-float-open')) return;
      // Ignore drags that start on buttons
      if (ev.target && ev.target.closest && ev.target.closest('button')) return;
      const r = overlay.getBoundingClientRect();
      offX = ev.clientX - r.left;
      offY = ev.clientY - r.top;
      dragging = true;
      document.body.style.userSelect = 'none';
      document.addEventListener('mousemove', onMove, true);
      document.addEventListener('mouseup', onUp, true);
      ev.preventDefault();
    });
  })();

  // Keep float within viewport on resize
  window.addEventListener('resize', ()=>{
    if (!document.body.classList.contains('timeline-float-open')) return;
    try{
      // v6.60: clamp width to viewport while floating
      if (overlay.style.width){
        const cw = _clampFloatW_(parseFloat(overlay.style.width));
        if (cw) overlay.style.width = Math.round(cw) + 'px';
      }
      const r = overlay.getBoundingClientRect();
      const next = _clampFloatPos_(r.left, r.top);
      overlay.style.left = next.x + 'px';
      overlay.style.top  = next.y + 'px';
    }catch(_){}
  }, { passive:true });



  // v6.44 — dock resizer (simple drag handle)
  (function(){
    const divider = document.getElementById('timelineDivider');
    if (!divider) return;
    let dragging = false;
    let startX = 0;
    let startW = 0;
    let startLeft = 0;
    let startRight = 0;

const root = document.documentElement;

    const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));

    const onMove = (ev)=>{
      if (!dragging) return;
      const dx = (ev.clientX - startX);
      const maxW = Math.min(1200, (window.innerWidth || 0) - 24);
     const next = clamp(startW - dx, 360, maxW);
      root.style.setProperty('--tl-dock-w', next + 'px');
      ev.preventDefault();
    };
    const onUp = ()=>{
      if (!dragging) return;
      dragging = false;
      document.removeEventListener('mousemove', onMove, true);
      document.removeEventListener('mouseup', onUp, true);
      document.body.style.userSelect = '';
    };

    divider.addEventListener('mousedown', (ev)=>{
      if (!_isTlOpen_()) return;
      dragging = true;
      startX = ev.clientX;
      const cs = getComputedStyle(root);
      const w = parseFloat(cs.getPropertyValue('--tl-dock-w')) || 520;
      startW = w;
      document.body.style.userSelect = 'none';
      document.addEventListener('mousemove', onMove, true);
      document.addEventListener('mouseup', onUp, true);
      ev.preventDefault();
    });
  })();

  // v6.60 — float width resizer (left edge grip)
  ;(function(){
    const grip = document.getElementById('timelineFloatResizer');
    if (!grip || !overlay) return;

    let dragging = false;
    let startX = 0;
    let startW = 0;
    let startLeft = 0;
    let startRight = 0;

    const onMove = (ev)=>{
      if (!dragging) return;
      const dx = (ev.clientX - startX);
      const vw = window.innerWidth || 0;
      const pad = 16;
      // Left-edge resize: keep the right edge anchored at drag-start.
      const maxW = Math.min(1200, Math.max(360, startRight - pad));
      const nextW = Math.max(360, Math.min(maxW, startW - dx));
      const nextLeft = Math.max(pad, Math.round(startRight - nextW));
      overlay.style.width = Math.round(nextW) + 'px';
      overlay.style.left  = nextLeft + 'px';

      // keep within viewport if width change would push it out
      try{
        const r = overlay.getBoundingClientRect();
        const pos = _clampFloatPos_(r.left, r.top);
        overlay.style.left = pos.x + 'px';
        overlay.style.top  = pos.y + 'px';
      }catch(_){}
      ev.preventDefault();
    };

    const onUp = ()=>{
      if (!dragging) return;
      dragging = false;
      document.removeEventListener('mousemove', onMove, true);
      document.removeEventListener('mouseup', onUp, true);
      document.body.style.userSelect = '';
      try{
        const r = overlay.getBoundingClientRect();
        localStorage.setItem(TL_FLOAT_W_KEY(), String(Math.round(r.width)));
      }catch(_){}
    };

    grip.addEventListener('mousedown', (ev)=>{
      if (!document.body.classList.contains('timeline-float-open')) return;
      const r = overlay.getBoundingClientRect();
      startX = ev.clientX;
      startW = r.width;
      startLeft = r.left;
      startRight = r.right;
      dragging = true;
      document.body.style.userSelect = 'none';
      document.addEventListener('mousemove', onMove, true);
      document.addEventListener('mouseup', onUp, true);
      ev.preventDefault();
      ev.stopPropagation();
    });
  })();
;

})();
</script>


<script>
(function(){
  function readTdRallies_(){
    const raw = localStorage.getItem('TD_RALLIES');
    if(!raw) return null;
    try{ return JSON.parse(raw); }catch(e){ return null; }
  }


  // v4.33: Controls feed — build ordered controlTimes (ETA by SG) from current DOM state

  // v5.49 — Controls store (dev reset): simple ordered array with label + sgTimes
  function getRallySgCount_(td, rid){
    try{
      const rally = td && td.rallies && td.rallies[rid] ? td.rallies[rid] : null;
      const admin = rally && rally.admin ? rally.admin : null;
      const ui = admin && admin.ui ? admin.ui : null;
      const n = ui ? Number(ui.sgCount||1) : 1;
      return Math.max(1, Math.min(4, Number.isFinite(n)?n:1));
    }catch(_e){
      return 1;
    }
  }

  function buildControlsStoreFromDom_(dayKey, sgCount){
    // Simple, readable controls store: an ordered array of { type, n, label, sgTimes }
    // - Order matches the schedule page order (top-to-bottom)
    // - n is per-type (STC 1, Marshal 1, etc.)
    // - sgTimes keys are limited to rally sgCount
    const out = [];

    const isVisibleRow = (tr)=>{
      if(!tr) return false;
      if(tr.classList && tr.classList.contains('row-template')) return false;
      if(tr.offsetParent === null) return false;
      if(!tr.getClientRects || tr.getClientRects().length === 0) return false;
      const cs = window.getComputedStyle ? getComputedStyle(tr) : null;
      if(cs && (cs.display === 'none' || cs.visibility === 'hidden')) return false;
      return true;
    };

    const timeOk = (s)=>/^\d{2}:\d{2}:\d{2}$/.test(String(s||'').trim());

    const tbody = document.getElementById('schedule-body');
    if(!tbody) return out;

    const mapType = (tr)=>{
      if(tr.classList.contains('stc-row')) return 'STC';
      if(tr.classList.contains('marshal-row')) return 'Marshal';
      if(tr.classList.contains('open-control-row')) return 'Open Control';
      if(tr.classList.contains('start-stc')) return 'Start STC';
      return null;
    };

    const readSgTimes = (tr, type)=>{
      const times = {};
      for(let lid=1; lid<=sgCount; lid++) times[String(lid)] = '';

      // Start STC: Schedule is NOT the source of truth for start times.
      // We export blank sgTimes keys (structure only) so Controls can own the entered Start STC times.
      if(type === 'Start STC'){
        for(let lid=1; lid<=sgCount; lid++) times[String(lid)] = '';
        return times;
      }
// SG1 from the row time input
      const t1 = tr.querySelector('td.col-time input[type="text"], td.col-time input');
      if(t1 && timeOk(t1.value)) times['1'] = String(t1.value).trim();

      // SG2.. from inline lanes (only up to rally sgCount)
      for(let lid=2; lid<=sgCount; lid++){
        const lane = tr.querySelector(`.sg-inline-lane[data-lane-id="${lid}"]`);
        if(!lane) continue;
        const tEl = lane.querySelector('.sg-time-text') || lane.querySelector('input.sg-time-input') || lane.querySelector('input[type="text"].sg-time-input');
        const tv = tEl ? (tEl.value != null ? tEl.value : tEl.textContent) : '';
        if(timeOk(tv)) times[String(lid)] = String(tv).trim();
      }
      return times;
    };

    const counts = { 'STC':0, 'Marshal':0, 'Open Control':0, 'Start STC':0 };

    const trs = [...tbody.querySelectorAll('tr')];
    trs.forEach((tr)=>{
      const type = mapType(tr);
      if(!type) return;
      counts[type] = (counts[type]||0) + 1;
      const n = counts[type];
      const label = `${type} ${n}`;
      out.push({ type, n, label, sgTimes: readSgTimes(tr, type) });
    });

    return out;
  }

// v6.41 — restore global dataset helper used by extractScheduleRows (was previously scoped inside SG IIFE)
function _dsGet(tr, k, fallback=null){
  try{
    const v = tr && tr.dataset ? tr.dataset[k] : undefined;
    return (v === undefined || v === null || v === "") ? fallback : v;
  }catch(_){ return fallback; }
}

// v6.84 — Global pristine reader (needed by extractScheduleRows)
function _pKey(rowId, field){ return String(rowId) + "|" + String(field); }
function _pGet(rowId, field, fallbackEl){
  try{
    const m = window.__tdPristineMap;
    if(m && (m instanceof Map)){
      const k = _pKey(rowId, field);
      if(m.has(k)) return m.get(k);
    }
  }catch(_){ /* ignore */ }
  try{
    if(fallbackEl && typeof fallbackEl.value !== 'undefined') return String(fallbackEl.value || "");
  }catch(_){ /* ignore */ }
  return "";
}

function extractScheduleRows(){
    try{ window.tdTrace && window.tdTrace('[EXTRACT begin]'); }catch(_){ }
    // v6.96 — guard: day switching can temporarily present an empty grid; never persist that.
    if(window.__TD_SCHED_DAY_SWITCHING) return false;
    // v5.68 — STRICT: Schedule never creates TD_RALLIES or rally nodes.
    const raw0 = localStorage.getItem('TD_RALLIES');
    if(!raw0) return false;
    let td = null;
    try{ td = JSON.parse(raw0); }catch(_){ return false; }
    const rid = (window.tdScheduleGetActiveRid_ ? window.tdScheduleGetActiveRid_() : null) || null;
    if(!td || !td.rallies || !rid || !td.rallies[rid]){
      try{ console.warn('[SCHEDULE] No Admin rally in TD_RALLIES; not writing schedule.'); }catch(_){ }
      return false;
    }
    const rally = td.rallies[rid];
    rally.schedule = rally.schedule || { days: {} };
    rally.schedule.days = rally.schedule.days || {};
    const dayKey = (window.getScheduleDayKey_?window.getScheduleDayKey_():'1');
    rally.schedule.days[dayKey] = rally.schedule.days[dayKey] || { rows: [] };

// v6.38 — (Bake B) Removed legacy Added-Time overlay dataset harvest.
// Helpers remain: HH:MM:SS <-> seconds.
const _hmsToSec = (hms)=>{
  const s = String(hms||'').trim();
  if(!s) return null;
  const parts = s.split(':').map(p=>Number(p));
  if(parts.some(n=>!Number.isFinite(n))) return null;
  let h=0,m=0,sec=0;
  if(parts.length===3){ [h,m,sec]=parts; }
  else if(parts.length===2){ [m,sec]=parts; }
  else if(parts.length===1){ sec=parts[0]; }
  else return null;
  return Math.max(0, Math.round(h*3600 + m*60 + sec));
};
const _secToHms=(s)=>{s=Math.max(0,Math.round(Number(s)||0));const h=Math.floor(s/3600);s-=h*3600;const m=Math.floor(s/60);const sec=s-m*60;const z=(n)=>String(n).padStart(2,'0');return `${z(h)}:${z(m)}:${z(sec)}`;};

// v6.38 — Model-first Added-Time lane harvest (legacy overlay dataset is view-only).
// We snapshot lane DOM -> row dataset, then derive atTimeBySg/atSecBySg keyed by laneId.
// This replaces the older dataset.sg1At/sg2At... harvest for persistence.
// (Legacy block remains for now but is no longer used by the save path.)
const _atModelByRowId = {};
Array.from(document.querySelectorAll('tr[data-row-type="added-time"][data-row-id]')).forEach(tr=>{
  const rid = tr.dataset.rowId;
  if(!rid) return;

  // Ensure latest DOM values are written into the row's model dataset.
  try{ snapshotRowFromDom(tr); }catch(_e){}

  const _t=(x)=>(String(x||'').trim()||null);
  const atTimeBySg = {
    '1': _t(_dsGet(tr, _laneKey('1','At'), '')),
    '2': _t(_dsGet(tr, _laneKey('2','At'), '')),
    '3': _t(_dsGet(tr, _laneKey('3','At'), '')),
    '4': _t(_dsGet(tr, _laneKey('4','At'), '')),
  };

  const atSecBySg = {
    '1': _hmsToSec(atTimeBySg['1']),
    '2': _hmsToSec(atTimeBySg['2']),
    '3': _hmsToSec(atTimeBySg['3']),
    '4': _hmsToSec(atTimeBySg['4']),
  };

  // Keep tick mirror if present (display-only in UI; timeline may still read it).
  const atTick = {
    '1': tr.dataset.sg1Tick ? 1 : 0,
    '2': tr.dataset.sg2Tick ? 1 : 0,
    '3': tr.dataset.sg3Tick ? 1 : 0,
    '4': tr.dataset.sg4Tick ? 1 : 0,
  };

  _atModelByRowId[rid] = { atSecBySg, atTick, atTimeBySg };
});

    // Rebuild from the VISIBLE table only (hard replace; no merge)
    const rawRows = [];
    const isVisibleRow = (tr)=>{
      if(!tr) return false;
      if(tr.classList && tr.classList.contains('row-template')) return false;
      if(tr.offsetParent === null) return false;
      if(!tr.getClientRects || tr.getClientRects().length === 0) return false;
      const cs = window.getComputedStyle ? getComputedStyle(tr) : null;
      if(cs && (cs.display === 'none' || cs.visibility === 'hidden')) return false;
      return true;
    };
    const trs = Array.from(document.querySelectorAll('tbody#schedule-body tr'));
    trs.forEach((tr,i)=>{
      const distEl  = tr.querySelector('td.col-dist input[type="text"]');
      const instrEl = tr.querySelector('.instruction-input-sl');
      if(!distEl || !instrEl) return;

      if(!tr.dataset.rowId){
        tr.dataset.rowId = 'r' + String(Date.now()) + '_' + String(i) + '_' + String(Math.floor(Math.random()*1000000));
      }

      let type = 'INSTRUCTION';
      if(tr.classList.contains('start-row')) type='START';
      else if(tr.classList.contains('stc-row')) type='STC';
      else if(tr.classList.contains('marshal-row')) type='MARSHAL';
      else if(tr.classList.contains('open-control-row')) type='OPEN';
      else if(tr.classList.contains('start-stc')) type='START_STC';
      else if(tr.classList.contains('added-time')) type='ADDED_TIME';

      const turnEl = tr.querySelector('td.col-turn .turn-select');
      const distRaw = String((distEl && distEl.value!=null) ? distEl.value : '').trim();
      const parsedDist = Number(distRaw.replace(',','.'));
      // v4.23 storage hygiene: carry-forward distance for control rows that are visually tied to the prior waypoint
      // (prevents 0.0km phantom focus items for START_STC / OPEN when their DIST cell is blank/locked)
      let dist = (Number.isFinite(parsedDist) ? parsedDist : 0);
      const distIsBlank = (distRaw === '');
      if(type !== 'START' && distIsBlank && rawRows.length>0){
        const last = rawRows[rawRows.length-1];
        if(last && typeof last.dist === 'number' && last.dist > 0 && (type==='START_STC' || type==='OPEN')){
          dist = last.dist;
        }


      // Enforce 2dp distance (storage key standard)
      dist = Number((Number(dist)||0).toFixed(2));
}

      // v5.26 — Normalise DIST display to X.XX (UI + future parses)
      try{ if(distEl) distEl.value = (Number(dist)||0).toFixed(2); }catch(_){}

      // SG speeds: lane 1 from grid SPEED, lanes 2–4 from inline lanes
      const sgSpeeds = {};
      const _toNum = (v)=>{ const n = Number(String(v??'').replace(',','.')); return (Number.isFinite(n)) ? n : null; };
      const sp1El = tr.querySelector('td.col-speed input[type="text"], td.col-speed input');
      const sp1 = sp1El ? _toNum(sp1El.value) : null;
      if(sp1!=null) sgSpeeds['1'] = sp1;
      for(let lid=2; lid<=4; lid++){
        const spEl = tr.querySelector(`.sg-inline-lane[data-lane-id="${lid}"] input.sg-speed-input`);
        const sp = spEl ? _toNum(spEl.value) : null;
        if(sp!=null) sgSpeeds[String(lid)] = sp;
      }

            // Added Time (ADDED_TIME rows):
      // - atLabel/atTime come from the page dropdown + page AT box (legacy UI)
      // - per-SG atSec/ticks are harvested from the SG overlay <tr data-row-type="added-time"> dataset (authoritative for SG lanes)
      let atLabel = null;
      let atTime = null;
      let atSec  = null;
      let atTick = null;
      let overlayRef = null;
      if(type === 'ADDED_TIME'){
        const atSelect = tr.querySelector('select.added-select');
        if(atSelect){
          const opt = atSelect.selectedIndex >= 0 ? atSelect.options[atSelect.selectedIndex] : null;
          atLabel = opt && opt.textContent ? opt.textContent.trim() : null;
        }
        const atBox = tr.querySelector('input.time-to-add');
        atTime = atBox ? (String(atBox.value || '').trim() || null) : null;

        overlayRef = _atModelByRowId[tr.dataset.rowId];
        if(overlayRef && overlayRef.atSecBySg){
          // Prefer overlay per-lane values
          atSec  = overlayRef.atSecBySg;
          atTick = overlayRef.atTick || null;

          // v6.36 — SG1 parity: for ADDED_TIME rows, SG1 is driven by the page AT box (atTime),
          // not the overlay lane text (which can show a derived/non-authoritative value for SG1).
          if(atTime){
            const s1 = _hmsToSec(atTime);
            if(s1!=null){
              atSec['1'] = s1;
              if(overlayRef.atTimeBySg){ overlayRef.atTimeBySg['1'] = atTime; }
            }
          }
        } else if(atTime){
          // Fallback: apply page AT box to all lanes (seconds)
          const s = _hmsToSec(atTime);
          if(s!=null){
            atSec = { '1': s, '2': s, '3': s, '4': s };
          }
        }
      }


      // v5.25 — Row UI state (pristine + tick intent)
      const rowId = tr.dataset.rowId || _ensureUid(tr);
      const ui = { distPristine: _pGet(rowId,'dist',distEl), speedPristine: _pGet(rowId,'speed',sp1El) };
      const _printed = (type==='INSTRUCTION' || type==='ADDED_TIME' || type==='OPEN');
      let distEnabled = true;
      let timeEnabled = true;
      if(_printed){
        const dt = tr.querySelector('td.col-dist .with-checkbox input[type="checkbox"]');
        const tt = tr.querySelector('td.col-time .with-checkbox input[type="checkbox"]');
        if(dt) distEnabled = !dt.checked;
        if(tt) timeEnabled = !tt.checked;
      }
      const sgUi = {};
      for(let lid=2; lid<=4; lid++){
        const lane = tr.querySelector(`.sg-inline-lane[data-lane-id="${lid}"]`);
        if(!lane) continue;
        const spEl = lane.querySelector('input.sg-speed-input');
        const o = { speedPristine: _pGet(rowId, `sg${lid}speed`, spEl) };
        sgUi[String(lid)] = o;
      }
      if(Object.keys(sgUi).length) ui.sg = sgUi;

const rowObj = {
  id: rowId,
  type,
  dist,
  instr: instrEl.value||'',
  turn: turnEl ? (turnEl.value||'') : '',
  sgSpeeds,
  distEnabled,
  timeEnabled,
  ui
};
if(type === 'ADDED_TIME'){
  rowObj.atLabel = atLabel;
  try{ const np = tr.querySelector('.at-print-flag'); if(np) rowObj.noPrint = !!np.checked; }catch(_){ }
  // v6.36: Persist page-level Added Time separately from per-SG lane AT
  if(atTime){ rowObj.atAddTime = atTime; rowObj.atAddSec = _hmsToSec(atTime); }
  // Legacy alias (kept for back-compat with older saves)
  if(atTime) rowObj.atTime = atTime;
  // Prefer overlay strings; fallback from seconds
  if(overlayRef && overlayRef.atTimeBySg){ rowObj.atTimeBySg = overlayRef.atTimeBySg; }
  else if(atSec){ const m={}; for(const k in atSec){ const v=atSec[k]; m[k]= (v==null?null:_secToHms(v)); } rowObj.atTimeBySg = m; }
  // v5.25: persist HH:MM:SS Added Time strings (canonical)
  if(atSec)  rowObj.atSecBySg = atSec;
  if(atTick) rowObj.atTick    = atTick;
}
rawRows.push(rowObj);
    });

    // Ensure START is rowNo 1 (move it to front if needed)
    const startIdx = rawRows.findIndex(r=>r.type==='START');
    if(startIdx > 0){
      const startRow = rawRows.splice(startIdx,1)[0];
      rawRows.unshift(startRow);
    }

    // Re-index rowNo 1..N (ignore any DOM row labels)
    const rows = rawRows.map((r,idx)=>({ ...r, rowNo: idx+1 }));
    // v4.33: also persist speeds in a lean, stable map keyed by row id (for Timeline)
    const rowSpeedsById = {};
    for(const rr of rows){
      if(!rr || !rr.id) continue;
      if(rr.sgSpeeds && Object.keys(rr.sgSpeeds).length){
        rowSpeedsById[rr.id] = rr.sgSpeeds;
      }
    }

    rally.schedule.days[dayKey] = rally.schedule.days[dayKey] || {};
    // v4.44: single source of truth — purge any legacy Added-Time cache/index
    try{ delete rally.schedule.days[dayKey].addedTimeDeck; }catch(_){}
    rally.schedule.days[dayKey].rows = rows; // hard replace
    rally.schedule.days[dayKey].rowSpeedsById = rowSpeedsById; // v4.33
        // v5.49: Controls store — replace subtree (dev reset; simple array model)
    try{
      const rid = (window.tdScheduleGetActiveRid_ ? window.tdScheduleGetActiveRid_() : null) || null;
      const sgCount = getRallySgCount_(td, rid);
      rally.schedule.days[dayKey].controls = buildControlsStoreFromDom_(dayKey, sgCount);
    }catch(_e){}


    // v6.90 — Day summary (drive/add/total) derived from rows + rowSpeedsById (no DOM; no SG-card helpers)
    try{
      const sgCountSum = getRallySgCount_(td, rid) || 1;
      const _num = (v)=>{ const n=Number(v); return Number.isFinite(n)?n:0; };
      const _getSpeed = (map,rowId,sg)=>{
        const o = (map && rowId) ? map[rowId] : null;
        if(!o) return null;
        const v = (o[sg] ?? o[String(sg)]);
        const n = Number(v);
        return Number.isFinite(n) ? n : null;
      };
      const bySg = {};
      const lastSpeed = {};
      for(let sg=1; sg<=sgCountSum; sg++){
        bySg[sg] = { driveSec: 0, addedSec: 0, totalSec: 0 };
        lastSpeed[sg] = 0;
      }
      let totalDist = 0;
      for(let i=0;i<rows.length;i++){
        const dk = _num(rows[i]?.dist);
        if(dk > totalDist) totalDist = dk;
      }
      for(let i=1;i<rows.length;i++){
        const a = rows[i-1], b = rows[i];
        const d = _num(b?.dist) - _num(a?.dist);
        if(d > 0){
          for(let sg=1; sg<=sgCountSum; sg++){
            const sp = _getSpeed(rowSpeedsById, b?.id, sg) ?? _getSpeed(rowSpeedsById, a?.id, sg) ?? lastSpeed[sg];
            if(sp && sp > 0){
              bySg[sg].driveSec += (d / sp) * 3600;
              lastSpeed[sg] = sp;
            }
          }
        }
        if(b && b.type === 'ADDED_TIME'){
          // v6.96 — Added Time is per-SG: use atSecBySg[sg] only (no global add)
          const atMap = b.atSecBySg;
          if(atMap){
            for(let sg=1; sg<=sgCountSum; sg++){
              const v = Number(atMap[sg] ?? atMap[String(sg)]);
              if(Number.isFinite(v) && v > 0) bySg[sg].addedSec += v;
            }
          }
        }

      }
      for(let sg=1; sg<=sgCountSum; sg++){
        bySg[sg].driveSec = Math.round(bySg[sg].driveSec);
        bySg[sg].addedSec = Math.round(bySg[sg].addedSec);
        bySg[sg].totalSec = bySg[sg].driveSec + bySg[sg].addedSec;
      }
      rally.schedule.days[dayKey].summary = { totalDist: Math.round(totalDist*100)/100, bySg: bySg };
    }catch(_e){}

if(!localStorage.getItem('TD_RALLIES')) return false;
    try{ localStorage.setItem('TD_RALLIES', JSON.stringify(td)); }catch(_e){ return false; }

    // v5.49 — broadcast for Controls page readers
    try{ window.dispatchEvent(new CustomEvent('TD_RALLIES_CHANGED', { detail:{ rid: (window.tdScheduleGetActiveRid_?window.tdScheduleGetActiveRid_():null) || '', dayKey: dayKey, reason: 'SCHEDULE_SYNC' } })); }catch(_e){}
  }

  
// v7.05 — TRACE DOCK default ON + TD_RALLIES setItem stack sniffer (trace-only build)
(function(){
  if(window.__TD_SCHED_TRACE_INIT) return;
  window.__TD_SCHED_TRACE_INIT = true;

  const TRACE = window.__TD_SCHED_TRACE = window.__TD_SCHED_TRACE || { enabled:true, lines:[], max:500 };
  function _ts(){
    try{
      const d=new Date();
      const hh=String(d.getHours()).padStart(2,'0');
      const mm=String(d.getMinutes()).padStart(2,'0');
      const ss=String(d.getSeconds()).padStart(2,'0');
      const ms=String(d.getMilliseconds()).padStart(3,'0');
      return `${hh}:${mm}:${ss}.${ms}`;
    }catch(_){ return ''; }
  }

  function ensureDock(){
    let dock=document.getElementById('tdTraceDock');
    if(dock) return dock;
    dock=document.createElement('div');
    dock.id='tdTraceDock';
    dock.style.cssText='position:fixed;right:10px;bottom:10px;z-index:99999;'+
      'width:420px;max-width:calc(100vw - 20px);height:190px;'+
      'background:rgba(17,24,39,0.92);color:#e5e7eb;'+
      'font:12px/1.3 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;'+
      'border:1px solid rgba(148,163,184,0.45);border-radius:10px;'+
      'box-shadow:0 8px 24px rgba(0,0,0,0.25);display:none;overflow:hidden;';
    const head=document.createElement('div');
    head.style.cssText='display:flex;gap:8px;align-items:center;'+
      'padding:6px 8px;background:rgba(15,23,42,0.9);border-bottom:1px solid rgba(148,163,184,0.25);';
    const ttl=document.createElement('div');
    ttl.textContent='TRACE (Ctrl+`)';
    ttl.style.cssText='font-weight:700;letter-spacing:0.2px;flex:1;';
    const btnCopy=document.createElement('button');
    btnCopy.type='button';
    btnCopy.textContent='Copy';
    btnCopy.style.cssText='padding:2px 8px;border-radius:8px;border:1px solid rgba(148,163,184,0.35);'+
      'background:rgba(51,65,85,0.65);color:#e5e7eb;cursor:pointer;';
    const btnClear=document.createElement('button');
    btnClear.type='button';
    btnClear.textContent='Clear';
    btnClear.style.cssText=btnCopy.style.cssText;
    head.appendChild(ttl);
    head.appendChild(btnCopy);
    head.appendChild(btnClear);

    const body=document.createElement('div');
    body.id='tdTraceDockBody';
    body.style.cssText='padding:6px 8px;white-space:pre-wrap;word-break:break-word;'+
      'height:calc(100% - 34px);overflow:auto;';

    btnClear.addEventListener('click', ()=>{
      TRACE.lines.length = 0;
      body.textContent = '';
    });
    btnCopy.addEventListener('click', async ()=>{
      const txt = TRACE.lines.join('\n');
      try{
        if(navigator.clipboard && navigator.clipboard.writeText){
          await navigator.clipboard.writeText(txt);
        }else{
          const ta=document.createElement('textarea');
          ta.value=txt;
          ta.style.position='fixed'; ta.style.left='-9999px';
          document.body.appendChild(ta);
          ta.select();
          document.execCommand('copy');
          ta.remove();
        }
        ttl.textContent='TRACE (copied)';
        setTimeout(()=>{ ttl.textContent='TRACE (Ctrl+`)'; }, 650);
      }catch(_e){
        ttl.textContent='TRACE (copy failed)';
        setTimeout(()=>{ ttl.textContent='TRACE (Ctrl+`)'; }, 900);
      }
    });

    dock.appendChild(head);
    dock.appendChild(body);
    document.body.appendChild(dock);
    return dock;
  }

  // Default ON (v7.05): show dock immediately for copy/paste during debugging
  try{
    TRACE.enabled = true;
    const _dock = ensureDock();
    _dock.style.display = 'block';
    const _body = document.getElementById('tdTraceDockBody');
    if(_body){ _body.textContent = TRACE.lines.join('\n'); }
  }catch(_e){}

  window.tdTrace = function(msg, extra){
    const line = `[${_ts()}] ${String(msg||'')}`;
    TRACE.lines.push(line);
    if(TRACE.lines.length > TRACE.max) TRACE.lines.splice(0, TRACE.lines.length - TRACE.max);
    try{
      if(TRACE.enabled){
        const dock=ensureDock();
        const body=document.getElementById('tdTraceDockBody');
        if(body){
          body.textContent = TRACE.lines.join('\n');
          body.scrollTop = body.scrollHeight;
        }
        dock.style.display='block';
      }
    }catch(_){}
    // Always keep console log too (easy to correlate with stacks)
    try{
      if(extra!==undefined) console.log(line, extra);
      else console.log(line);
    }catch(_){}
  };

  // Toggle
  document.addEventListener('keydown', (ev)=>{
    if(ev.ctrlKey && !ev.shiftKey && !ev.altKey && (ev.key==='`' || ev.code==='Backquote')){
      ev.preventDefault();
      TRACE.enabled = !TRACE.enabled;
      try{
        const dock=ensureDock();
        dock.style.display = TRACE.enabled ? 'block' : 'none';
        if(TRACE.enabled){
          const body=document.getElementById('tdTraceDockBody');
          if(body){
            body.textContent = TRACE.lines.join('\n');
            body.scrollTop = body.scrollHeight;
          }
        }
      }catch(_){}
    }
  }, true);

  // TD_RALLIES setItem stack sniffer (Option A)
  try{
    if(!window.__TD_TDR_SETITEM_SNIFF){
      window.__TD_TDR_SETITEM_SNIFF = true;
      const _orig = localStorage.setItem.bind(localStorage);
      localStorage.setItem = function(k,v){
        try{
          if(k==='TD_RALLIES'){
            const stack = (new Error('TD_RALLIES setItem')).stack;
            window.tdTrace && window.tdTrace('[TD_RALLIES setItem]', { key:k, len:(v?String(v).length:0), stack });
          }
        }catch(_e){}
        return _orig(k,v);
      };
    }
  }catch(_e){}
})();

// v4.35 — TD_RALLIES sync hygiene:
  // - Track dirty state for cross-page consumers (Timeline, Controls, etc.)
  // - Coalesce writes (debounce) for a sensible human rate
  // - Expand the sync trigger set to include SG speed + Added Time (AT) edits
  window.__TD_SCHEDULE_DIRTY = false;

  // v4.44 — Hydration gate + settle-sync:
  // Prevent TD_RALLIES writes while a JSON rows import is building/mounting rows.
  window.__TD_SCHEDULE_HYDRATING = 0;

  function _beginScheduleHydrate_(){ window.__TD_SCHEDULE_HYDRATING = (window.__TD_SCHEDULE_HYDRATING||0) + 1; }
  function _endScheduleHydrate_(){ window.__TD_SCHEDULE_HYDRATING = Math.max(0, (window.__TD_SCHEDULE_HYDRATING||0) - 1); }
  function _isScheduleHydrating_(){ return (window.__TD_SCHEDULE_HYDRATING||0) > 0; }

  // v5.26 — Auto-hydrate + tick restore + 2dp DIST normalise
  // - No writes
  // - Runs after page settle
  // - Builds DOM rows from stored TD_RALLIES rows, then reapplies tick/pristine from stored row.ui
  window.autoHydrateScheduleFromTdRallies = function(dayKeyOpt){
    try{
      const raw = localStorage.getItem('TD_RALLIES');
      if(!raw) return false;
      let td;
      try{ td = JSON.parse(raw); }catch(_){ return false; }
      const meta = (window.tdScheduleGetAdminMeta_?window.tdScheduleGetAdminMeta_():{ok:false});
      const rid = meta.ok ? meta.rid : null;
      const rally = (td && rid && td.rallies && td.rallies[rid]) ? td.rallies[rid] : null;
      const dayKey = (window.getScheduleDayKey_?window.getScheduleDayKey_():'1');
      const storedRows = rally && rally.schedule && rally.schedule.days && rally.schedule.days[dayKey] && Array.isArray(rally.schedule.days[dayKey].rows) ? rally.schedule.days[dayKey].rows : null;
      if(!storedRows || !storedRows.length) return false;

      const typeMap = {
        'START':'instruction',
        'INSTRUCTION':'instruction',
        'ADDED_TIME':'added-time',
        'STC':'stc',
        'MARSHAL':'marshal',
        'OPEN':'open-control',
        'START_STC':'start-stc'
      };

      // Build rows import rows + pristine bitmap (touched mask) from stored ui.pristine
      const touched = {};
      const B = { DIST:1<<0, TIME:1<<1, SPEED:1<<2, SG2:1<<3, SG3:1<<4, SG4:1<<5, AT2:1<<6, AT3:1<<7, AT4:1<<8 };

      const storedRowsPayload = storedRows.map((r,i)=>{
        const id = (r && r.id) ? String(r.id) : null;
        const t = typeMap[String(r && r.type || 'INSTRUCTION')] || 'instruction';
        const out = {
          id,
          type: t,
          dist: (r && r.dist!=null) ? ((Number(String(r.dist).replace(',','.'))||0).toFixed(2)) : '',
          instr: (r && r.instr!=null) ? String(r.instr) : '',
          turn: (r && r.turn!=null) ? String(r.turn) : '',
          distEnabled: (r && typeof r.distEnabled==='boolean') ? r.distEnabled : (r && r.ui && r.ui.distTick!=null ? (r.ui.distTick?false:true) : true),
          timeEnabled: (r && typeof r.timeEnabled==='boolean') ? r.timeEnabled : (r && r.ui && r.ui.timeTick!=null ? (r.ui.timeTick?false:true) : true),
          sgSpeeds: (r && r.sgSpeeds) ? r.sgSpeeds : {},
          atSec: {},
          atLabel: (r && r.atLabel!=null) ? String(r.atLabel) : null,
          atTime: (r && r.atTime!=null) ? String(r.atTime) : null
        };
        if(r && r.type==='ADDED_TIME'){
          if(r.atSecBySg){
            for(const k in r.atSecBySg){
              const v = r.atSecBySg[k];
              if(v==null) continue;
              out.atSec[String(k)] = Number(v)||0;
            }
          }
        }

        let m = 0;
        const ui = (r && r.ui) ? r.ui : {};
        if(ui && ui.distPristine===0) m |= B.DIST;
        if(ui && ui.speedPristine===0) m |= B.SPEED;
        const sg = ui && ui.sg ? ui.sg : null;
        if(sg && sg['2'] && sg['2'].speedPristine===0) m |= B.SG2;
        if(sg && sg['3'] && sg['3'].speedPristine===0) m |= B.SG3;
        if(sg && sg['4'] && sg['4'].speedPristine===0) m |= B.SG4;
        if(id) touched[id] = m;
        return out;
      });

      const payload = { schema: 'td.rallies.snapshot', createdAt: new Date().toISOString(), rows: storedRowsPayload, ui: { touched } };

      try{ window.__TD_SCHEDULE_MUTE = true; }catch(_){ }
      try{ _beginScheduleHydrate_ && _beginScheduleHydrate_(); }catch(_){ }
      try{
        if(window.tdHydrateScheduleFromRows && typeof window.tdHydrateScheduleFromRows==='function'){
          window.tdHydrateScheduleFromRows(payload);
        } else {
          return false;
        }
      } finally {
        try{ _endScheduleHydrate_ && _endScheduleHydrate_(); }catch(_){ }
        try{ window.__TD_SCHEDULE_MUTE = false; }catch(_){ }
      }
      try{ window.__TD_SCHEDULE_DIRTY = false; }catch(_){ }
      try{ _syncAllTurnPills_(); }catch(_){ }
      return true;
    }catch(_){ return false; }
  };


  const _scheduleSettleSync_ = (()=>{
    let t;
    return (delayMs=250)=>{
      clearTimeout(t);
      t = setTimeout(()=>{
        if(_isScheduleHydrating_()) return;
        try{ _syncScheduleNow_('settle'); }catch(e){}
      }, delayMs);
    };
  })();

  window._scheduleSettleSync_ = _scheduleSettleSync_;


  function _markScheduleDirty_(reason){
    if((window.__TD_SCHEDULE_SUPPRESS_PERSIST||0)>0) { try{ window.tdTrace && window.tdTrace('[DIRTY suppress] ' + (reason||'unknown')); }catch(_){ } return; }
    window.__TD_SCHEDULE_DIRTY = true;
    try{ window.tdTrace && window.tdTrace('[DIRTY set] ' + (reason||'unknown')); }catch(_){ }
  }

  function _syncScheduleNow_(reason){
    try{ window.tdTrace && window.tdTrace('[SYNC enter] ' + (reason||'unknown') + ' dirty=' + (!!window.__TD_SCHEDULE_DIRTY)); }catch(_){ }
    if((window.__TD_SCHEDULE_SUPPRESS_PERSIST||0)>0){ try{ window.tdTrace && window.tdTrace('[SYNC suppress] ' + (reason||'unknown')); }catch(_){ } return; }
    if(typeof _isScheduleHydrating_ === 'function' && _isScheduleHydrating_()) return;

    const __dirty = !!window.__TD_SCHEDULE_DIRTY;
    if(!__dirty){
      const __r = (reason||'').toLowerCase();
      // Guard: never write TD_RALLIES on selection/settle/init when not dirty
      if(__r==='settle' || __r==='select' || __r==='open' || __r==='init' || __r==='hydrate' || __r==='load'){
        try{ window.tdTrace && window.tdTrace('[SYNC skip] ' + (__r||'unknown') + ' dirty=false'); }catch(_){ }
        return;
      }
    }

    // v4.44: do not depend on non-global helpers; only sync when at least one REAL visible row exists
    const trs = Array.from(document.querySelectorAll('tbody#schedule-body tr'))
      .filter(tr => !(tr.classList && tr.classList.contains('row-template')))
      .filter(tr => tr.offsetParent !== null);

    if(!trs.length) return;

    const ok = extractScheduleRows();
    if(ok){
      window.__TD_SCHEDULE_DIRTY = false;
      try{ window.tdTrace && window.tdTrace('[DIRTY clear] ' + (reason||'unknown')); }catch(_){ }
    }
    try{ window.tdTrace && window.tdTrace('[SYNC exit] ' + (reason||'unknown') + ' ok=' + (!!ok)); }catch(_){ }
  }

  // Expose: force snapshot write before opening Timeline (programmatic loads may not fire input events)
  window.syncScheduleToTdRallies = _syncScheduleNow_;

  const debounced = (()=>{
    let t;
    return ()=>{
      clearTimeout(t);
      t = setTimeout(()=>_syncScheduleNow_('debounced'), 400);
    };
  })();

  // v5.21 — Added Time delta-gate: remember focus value so blur can no-op when unchanged
  document.addEventListener('focusin', e=>{
    const t = e.target;
    if(!t || !t.matches) return;
    if(t.matches('input.time-to-add') && !t.closest('.ncard')){
      t.dataset.atFocusVal = String(t.value || '').trim();
    }
  }, true);

// v5.19 — Dedupe commits: text inputs commit on blur; select/checkbox commit on change
  // Use capture because blur does not bubble.
  document.addEventListener('blur', e=>{
    if(typeof _isScheduleHydrating_ === 'function' && _isScheduleHydrating_()) return;
    if(window.__TD_SCHEDULE_MUTE) return;
    const t = e.target;
    if(!t) return;

    // v5.21: Added Time pill should not commit on touch-only (focus->blur with no change)
    if(t.matches && t.matches('input.time-to-add') && !t.closest('.ncard')){
      const cur = String(t.value || '').trim();
      const prev = String(t.dataset.atFocusVal || '').trim();
      if(prev && cur === prev){
        return;
      }
    }

    if(
      t.closest('.col-dist') ||
      t.closest('.col-speed') ||
      t.closest('.instruction-input-sl') ||
      t.closest('.sg-speed-input') ||
      t.closest('.card-at-input') ||
      t.matches('input.time-to-add') ||
      (t.matches('input[type="text"]') && t.closest('#ncard-layer')) || t.closest('.speed-dup')
    ){
      _markScheduleDirty_('input');
      debounced();
    }
  }, true);

  // Also catch select/checkbox changes that affect computation/exports
  document.addEventListener('change', e=>{
    if(typeof _isScheduleHydrating_ === 'function' && _isScheduleHydrating_()) return;
    if(window.__TD_SCHEDULE_MUTE) return;
    const t = e.target;
    if(
      t.matches('select') ||
      t.matches('input[type="checkbox"], input[type="radio"]')
    ){
      _markScheduleDirty_('change');
      debounced();
    }
  }, { passive: true });
})();

</script>


<!-- v5.63 — Print Options + Print Wrapper (Admin-style) -->
<div id="printOptionsOverlay" aria-hidden="true">
  <div id="printOptionsModal" role="dialog" aria-label="Print options" aria-modal="true">
    <div class="po-title">Print options</div>
    <div class="po-grid">
      <label class="po-l" for="poDay">Day</label>
      <select id="poDay"></select>

      <label class="po-l" for="poSg">Speed Group</label>
      <select id="poSg"></select>
      <!-- TURN print is controlled by the page TURN toggle (no per-print override). -->
    </div>
    <div class="po-actions">
      <button class="btn btn-secondary" id="poCancel" type="button">Cancel</button>
      <button class="btn btn-primary" id="poPrint" type="button">Print</button>
    </div>
    <div class="po-mini">Header prints: Rally title — Day — SG.</div>
  </div>
</div>

<div id="schedulePrintWrapper" aria-hidden="true">
  <div class="print-page">
    <div class="print-head" id="schedulePrintHead">Rally — Day 1 — SG1</div>
    <table class="print-table" id="schedulePrintTable" cellspacing="0" cellpadding="0"></table>
  </div>
</div>

<div id="tdToast" role="status" aria-live="polite" aria-atomic="true"></div>

<!-- v5.97 — Load Rally File warning (shown before file picker) -->
<div id="loadWarnModal" aria-hidden="true">
  <div class="lw-card" role="dialog" aria-modal="true" aria-label="Load Rally File warning">
    <div class="lw-title">Load Rally File</div>
    <div class="lw-msg">Loading will overwrite current work. Consider saving first.</div>
    <div class="lw-actions">
      <button type="button" class="lw-btn" id="lwCancelBtn">Cancel</button>
      <button type="button" class="lw-btn primary" id="lwLoadBtn">Load…</button>
    </div>
  </div>
</div>





<script>
(function(){
  if (window.__TD_SUMMARY_SG1_PATCHED__) return;
  window.__TD_SUMMARY_SG1_PATCHED__ = true;

  // Ensure SG1 is always present using main grid speed if cards are absent
  function getActiveSgSpeedsWithSg1_(){
    let speeds = {};
    try{
      if (typeof window.__tdScheduleGetActiveSgSpeeds__ === 'function'){
        speeds = window.__tdScheduleGetActiveSgSpeeds__() || {};
      }
      // SG1 fallback: main grid speed from first valid row
      if (!speeds["1"]){
        const gridRows = document.querySelectorAll('#schedule-body tr');
        for (const tr of gridRows){
          const sp = tr.querySelector('input.speed');
          if (sp && sp.value){
            const v = Number(sp.value);
            if (!isNaN(v) && v>0){ speeds["1"] = v; break; }
          }
        }
      }
    }catch(e){}
    return speeds;
  }

  const orig = window.syncScheduleToTdRallies;
  if (typeof orig === 'function'){
    window.syncScheduleToTdRallies = function(reason){
      const res = orig.apply(this, arguments);
      try{
        const raw = localStorage.getItem('TD_RALLIES');
        if (!raw) return res;
        const td = JSON.parse(raw);
        const rid = td?.global?.activeRallyId || td?.global?.lastRallyId;
        const dayKey = (window.getScheduleDayKey_ && window.getScheduleDayKey_()) || '1';
        const rally = td?.rallies?.[rid];
        const day = rally?.schedule?.days?.[dayKey];
        if (!day || !day.rows) return res;

        // reuse existing summary compute if present
        if (typeof window.computeDaySummary_ === 'function'){
          const speeds = getActiveSgSpeedsWithSg1_();
          day.summary = window.computeDaySummary_(day.rows, speeds);

          // v7.03 — Never full-write TD_RALLIES on navigation/day switch; respect write fences
          if (reason === 'DAY_SWITCH' || window.__TD_SCHED_DAY_SWITCHING) return res;
          if ((window.__TD_SCHEDULE_SUPPRESS_PERSIST||0) > 0) { try{ window.tdTrace && window.tdTrace('[SYNC suppress] SG1_SUMMARY'); }catch(_){ } return res; }
          if (typeof window.tdWrite_ === 'function') { window.tdWrite_(td); }
          else { localStorage.setItem('TD_RALLIES', JSON.stringify(td)); }
        }
      }catch(e){ console.warn('SG1 summary patch skipped', e); }
      return res;
    };
  }
})();
</script>



<script>
(function(){
  if (window.__TD_SUMMARY_ROWSPD_PATCHED_V688__) return;
  window.__TD_SUMMARY_ROWSPD_PATCHED_V688__ = true;

  function num_(x){
    const n = Number(x);
    return Number.isFinite(n) ? n : null;
  }
  function round2_(n){ return Math.round(n * 100) / 100; }

  // Schema-aware SG1 summary:
  // - dist is stored as "dist" (unit-agnostic)
  // - rowSpeedsById is { rowId: { "1":80, "2":70, ... } } (may also use numeric keys)
  // - Added Time rows store seconds as addedSec / addSec / added
  function computeSg1Summary_(day){
    if (!day || !Array.isArray(day.rows) || day.rows.length < 2) return null;

    const rows = day.rows;
    const spMap = day.rowSpeedsById || {};
    let driveSec = 0;
    let addedSec = 0;
    let totalDist = 0;
    let lastSp1 = null;

    function sp1ForRow_(row){
      if (!row || !row.id) return null;
      const rec = spMap[row.id];
      if (!rec) return null;
      // allow "1" or 1 key
      const v = (rec["1"] != null) ? rec["1"] : (rec[1] != null ? rec[1] : null);
      return num_(v);
    }

    for (let i = 1; i < rows.length; i++){
      const a = rows[i-1];
      const b = rows[i];

      const d0 = num_(a && a.dist) ?? 0;
      const d1 = num_(b && b.dist) ?? 0;
      const d = d1 - d0;

      if (d1 > totalDist) totalDist = d1;

      // Determine speed for SG1: prefer destination row speed, else source, else last seen
      let sp1 = sp1ForRow_(b);
      if (sp1 == null) sp1 = sp1ForRow_(a);
      if (sp1 == null) sp1 = lastSp1;

      if (sp1 != null && sp1 > 0) lastSp1 = sp1;

      if (d > 0 && sp1 != null && sp1 > 0){
        driveSec += (d / sp1) * 3600;
      }

      // Added time contribution (applies regardless of distance)
      if (b && b.type === 'AddedTime'){
        const add = (b.addedSec != null) ? b.addedSec :
                    (b.addSec != null) ? b.addSec :
                    (b.added != null) ? b.added : null;
        const addN = num_(add);
        if (addN != null && addN > 0) addedSec += addN;
      }
    }

    driveSec = Math.round(driveSec);
    addedSec = Math.round(addedSec);

    // Store unitless totalDist (distance has no unit in schema)
    return {
      totalDist: round2_(totalDist),
bySg: { "1": { driveSec: driveSec, addedSec: addedSec, totalSec: driveSec + addedSec } }
    };
  }

  const orig = window.syncScheduleToTdRallies;
  if (typeof orig === 'function'){
    window.syncScheduleToTdRallies = function(reason){
      const res = orig.apply(this, arguments);
      try{
        const raw = localStorage.getItem('TD_RALLIES');
        if (!raw) return res;
        const td = JSON.parse(raw);
        const rid = td?.global?.activeRallyId || td?.global?.lastRallyId;
        const dayKey = (window.getScheduleDayKey_ && window.getScheduleDayKey_()) || '1';
        const day = td?.rallies?.[rid]?.schedule?.days?.[dayKey];
        const summary = computeSg1Summary_(day);
        if (summary){
          day.summary = summary;
          localStorage.setItem('TD_RALLIES', JSON.stringify(td));
        }
      }catch(e){ console.warn('SG1 rowSpeeds summary skipped', e); }
      return res;
    };
  }
})();
</script>

</body>
</html>